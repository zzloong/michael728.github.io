<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Michael翔</title>
  
  <subtitle>因上努力，果上随缘！</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://michael728.github.io/"/>
  <updated>2021-02-12T13:27:05.289Z</updated>
  <id>https://michael728.github.io/</id>
  
  <author>
    <name>Michael翔</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>安卓手机必备 APP 清单</title>
    <link href="https://michael728.github.io/2021/02/12/mobile-app-backup/"/>
    <id>https://michael728.github.io/2021/02/12/mobile-app-backup/</id>
    <published>2021-02-12T13:27:05.289Z</published>
    <updated>2021-02-12T13:27:05.289Z</updated>
    
    <content type="html"><![CDATA[<p>APP 清单</p><h2 id="效率"><a href="#效率" class="headerlink" title="效率"></a>效率</h2><ul><li>滴答清单</li><li>shadowsocks</li></ul><h2 id="阅读"><a href="#阅读" class="headerlink" title="阅读"></a>阅读</h2><ul><li>Fasthub</li><li>多看</li><li>微信阅读</li><li>豆瓣阅读</li><li>开发者头条</li><li>Pocket</li><li>极客时间</li><li>西梅</li><li>译学馆</li></ul><h2 id="摄影"><a href="#摄影" class="headerlink" title="摄影"></a>摄影</h2><ul><li>必剪</li><li>剪映</li><li>Vue Vlog</li><li>美图秀秀</li><li>黄油</li><li>一刻相册</li><li>MIX</li></ul><h2 id="视频"><a href="#视频" class="headerlink" title="视频"></a>视频</h2><ul><li>央视频</li><li>QQ 音乐</li><li>KMPlayer</li></ul><h2 id="办公"><a href="#办公" class="headerlink" title="办公"></a>办公</h2><ul><li>BOSS</li><li>拉钩</li><li>QQ 邮箱</li><li>扫描全能王</li><li>白描</li><li>WPS</li><li>个人所得税</li><li>QQ 浏览器</li></ul><h2 id="APP"><a href="#APP" class="headerlink" title="APP"></a>APP</h2><ul><li>酷安</li><li>应用宝</li><li>Play 商店</li><li>APKPure</li></ul><h2 id="笔记"><a href="#笔记" class="headerlink" title="笔记"></a>笔记</h2><ul><li>印象笔记</li></ul><h2 id="智联"><a href="#智联" class="headerlink" title="智联"></a>智联</h2><ul><li>米家</li><li>Andpods</li><li>万能遥控器</li><li>小米 WiFi</li><li>唯乐</li><li>小爱音箱</li><li>乐播投屏</li><li>精臣云打印</li></ul><h2 id="金融"><a href="#金融" class="headerlink" title="金融"></a>金融</h2><ul><li>老虎证券</li><li>货币 Pro</li><li>兴业银行</li><li>动卡空间</li><li>掌上生活</li><li>招商银行</li><li>云闪付</li></ul><h2 id="购物"><a href="#购物" class="headerlink" title="购物"></a>购物</h2><ul><li>饿了么</li><li>拼多多</li><li>严选</li><li>苏宁易购</li><li>小米有品</li><li>悦拜</li><li>一淘</li><li>京粉</li><li>当当</li><li>盒马</li><li>瑞幸</li></ul><h2 id="生活"><a href="#生活" class="headerlink" title="生活"></a>生活</h2><ul><li>化妆品监管</li><li>食药云搜</li><li>贝壳</li><li>透明家</li><li>浙里办</li><li>丁香医生</li><li>美柚</li><li>网上国网</li></ul><h2 id="工具"><a href="#工具" class="headerlink" title="工具"></a>工具</h2><ul><li>百度网盘</li><li>手机营业厅</li><li>手机助手</li><li>倒数日</li><li>SpeedTest</li><li>QQ同步助手</li><li>一键测速</li><li>QQ 输入法</li><li>AirDroid</li><li>身份验证器</li><li>v2rayNG</li></ul><h2 id="新闻"><a href="#新闻" class="headerlink" title="新闻"></a>新闻</h2><ul><li>学习强国</li></ul><h2 id="出行"><a href="#出行" class="headerlink" title="出行"></a>出行</h2><ul><li>高德</li><li>嘀嗒出行</li><li>哈喽出行</li><li>滴滴出行</li><li>iAdmin</li><li>花小猪</li><li>T3 出行</li><li>携程</li><li>飞猪</li><li>巴士管家</li><li>慧通</li><li>马蜂窝</li><li>穷游</li><li>航旅纵横</li><li>铁路 12306</li></ul><h2 id="社交"><a href="#社交" class="headerlink" title="社交"></a>社交</h2><ul><li>QQ</li><li>订阅号助手</li><li>Telegram</li><li>脉脉</li><li>抖音</li><li>微博</li></ul><h2 id="兴趣"><a href="#兴趣" class="headerlink" title="兴趣"></a>兴趣</h2><ul><li>西窗烛</li><li>活动性</li><li>懂车帝</li><li>汽车之家</li><li>懒饭</li><li>好好住</li></ul><p>## </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;APP 清单&lt;/p&gt;
&lt;h2 id=&quot;效率&quot;&gt;&lt;a href=&quot;#效率&quot; class=&quot;headerlink&quot; title=&quot;效率&quot;&gt;&lt;/a&gt;效率&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;滴答清单&lt;/li&gt;
&lt;li&gt;shadowsocks&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;阅读&quot;&gt;&lt;
      
    
    </summary>
    
      <category term="Life" scheme="https://michael728.github.io/categories/Life/"/>
    
    
      <category term="APP" scheme="https://michael728.github.io/tags/APP/"/>
    
  </entry>
  
  <entry>
    <title>IT程序员的装修笔记——软装篇</title>
    <link href="https://michael728.github.io/2021/01/30/life-shopping-soft-decoration/"/>
    <id>https://michael728.github.io/2021/01/30/life-shopping-soft-decoration/</id>
    <published>2021-01-30T21:29:08.000Z</published>
    <updated>2021-02-12T13:27:05.289Z</updated>
    
    <content type="html"><![CDATA[<h2 id="被子"><a href="#被子" class="headerlink" title="被子"></a>被子</h2><h3 id="被子分类"><a href="#被子分类" class="headerlink" title="被子分类"></a>被子分类</h3><ul><li>棉花被：属于植物纤维，价格适中，性价比高。如果想更保暖，往往比较笨重。</li><li>化纤被：人造纤维（聚酯纤维）填充的被子。价格比棉花还便宜，其中最受欢迎的是七孔被。松软，保温效果也不错，比起自然纤维，坚固耐用、抗皱免烫，不像羽绒被一样老爱“掉毛”</li><li>羊毛被</li><li>羽绒被：羽绒取自鹅、鸭身上的绒毛。同样的体积，羽绒被重量只有棉被的三分之一</li><li>蚕丝被：讲究人专用</li></ul><blockquote><p>棉花被导热系数比较低低，所以相对来说比较保暖。但是它升温时间慢，我们需要用自己的体温先去捂热被子。羽绒被，轻盈的羽绒被的重量仅为同体积棉被的1/3、羊毛被的1/2，使用时不会对人体造成压迫感。</p></blockquote><h3 id="品牌"><a href="#品牌" class="headerlink" title="品牌"></a>品牌</h3><ul><li>原装进口品牌：德国peter kohl，110年历史，是欧洲著名的羽绒供应厂家；德国obb royal bed 博登，成立于1900年，hanskruchen成立于1900年，billerbeck betten成立于1921年；奥地利kauffmann，日本西川</li><li>国外品牌+国内代工：澳大利亚的downia、日本的interlagos、英国downland、美国pacific coast、奥地利的SIDANDA</li><li>新国货品牌：网易严选、淘宝心选、京造，除此以外，以前和大型酒店供货的厂商也开始做自己的品牌，例如浙江三星羽绒厂的格兰贝恩</li><li>老牌国货：一类企业，在国内有比较长的历史了，集中分布在安徽、浙江羽绒生产基地。例如安徽鸿润、安徽霞珍、浙江雁皇</li><li>家纺品牌：一般都是跟江苏南通、浙江萧山、安徽等当地的企业进行OEM的定制，比如罗莱、水星、富安娜等家纺品牌</li></ul><p>补充知识：</p><ul><li>OBM：A设计，A生产，A品牌，A销售==工厂自己设计自产自销</li><li>ODM：B设计，B生产，A品牌，A销售==俗称“贴牌”，就是工厂的产品，别人的品牌</li><li>OEM：A设计，B生产，A品牌，A销售==代工，代生产，别人的技术和品牌，工厂只生产<h3 id="如何选择羽绒"><a href="#如何选择羽绒" class="headerlink" title="如何选择羽绒"></a>如何选择羽绒</h3></li></ul><p>常见羽绒的品质排序如下：白鹅绒＞灰鹅绒＞白鸭绒＞灰鸭绒。</p><p>鹅绒比鸭绒的绒多更大、蓬松度也更好。关注常规绒与大朵绒的比列，大朵绒比例高比较好。</p><blockquote><p>逆光看充绒是均匀整齐的、异色绒少、能看到朵朵绒。记住：真正的朵朵绒，在逆光下一定是点点状，而如果暗度差不多，说明里面的很充绒绒丝、碎羽毛多</p></blockquote><p>核心参数指标：</p><ul><li>清洁度：1000+，表示没有任何杂质、细菌的残留（国标是 450mm）</li><li>蓬松度：800+</li><li>含绒量：95% 含绒量就算比较高的</li><li>填充量：</li><li>面料支数：60S，支数越高，不仅意味着面料越细腻光滑，还代表内容物能更好地包裹其中</li></ul><blockquote><p>数据编辑很容易，要有相关检验检疫证明才可靠！</p></blockquote><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><ul><li>羽绒和羊毛都可以干洗，但不可以在阳光下暴晒。羽绒和羊毛不需要频繁晾晒，也不可以直接让毒辣的阳光照射。因为高温会让羽毛、羊毛中的油分起变化，产生腐臭味。解决办法：可以选择通风干燥日，把杯子放在阳关直射不到的地方，晾一两个小时就能达到杀菌除湿的效果了。</li><li><p>羽绒被更不能使劲拍打，绒毛也容易断裂成细小的“羽尘”，羽绒保温性能会大幅降低。</p><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3></li><li><p><a href="https://post.smzdm.com/p/a99v9ggo/p19/#comments" target="_blank" rel="noopener">什么值得买/2019鹅绒被值得买 篇二：双十一最全的鹅绒被清单在这里！</a></p></li><li><a href="https://post.smzdm.com/p/a83g3ve0/" target="_blank" rel="noopener">什么值得买/70款鹅绒被实力PK：2020双十一鹅绒被购买攻略</a></li><li><a href="https://post.smzdm.com/p/awxln5gk/" target="_blank" rel="noopener">什么值得买/总抱怨没有深睡眠？可能是你盖错了被子！</a></li><li><a href="https://www.zhihu.com/question/20323695" target="_blank" rel="noopener">ODM 和 OEM 分别是什么？两者有什么本质区别？</a></li><li><a href="https://post.smzdm.com/p/ar07g8xg/" target="_blank" rel="noopener">什么值得买/鹅绒被什么值得买系列 篇八：关于羽绒行业，这次干脆跟你们交个底儿……（附双十二超值好价</a><h2 id="窗帘"><a href="#窗帘" class="headerlink" title="窗帘"></a>窗帘</h2><h3 id="窗帘配色："><a href="#窗帘配色：" class="headerlink" title="窗帘配色："></a>窗帘配色：</h3></li><li>不知道选什么颜色，选纯色无脑灰肯定不会错</li><li>选择与墙面、地板相近或稍深的颜色，整体和谐统一</li><li>选择与软装点缀色相近或相似的颜色，掏钱可爱</li></ul><h3 id="窗帘配色原则："><a href="#窗帘配色原则：" class="headerlink" title="窗帘配色原则："></a>窗帘配色原则：</h3><ul><li>同色系和谐不出错，</li><li>对比色系个性吸睛，红和绿、蓝和橙、黑和白</li><li>上浅下深显层高</li></ul><ol><li>根据墙面颜色：选择和家里大面积颜色同色系的，一般都不会出错，比如选择与墙面颜色相近或稍深的配色，显得整体和谐</li><li>根据地板的颜色：选择和地板颜色相近或稍深的窗帘也都没有问题（但要特别注意，如果你家连墙面带地面都是白色的，窗帘打死也别选白色）</li><li>根据软装的颜色：选择与软装色彩相近或相似的窗帘，整体感显而易见（参考物有沙发、茶几、地毯、床品、床头柜、保证、花瓶、绿植等）</li></ol><p>“白纱＋灰帘”这个神仙组合，一层白纱窗帘，搭配任何明度的灰色布帘，几乎能和所有空间风格完美融合</p><h3 id="窗帘面料"><a href="#窗帘面料" class="headerlink" title="窗帘面料"></a>窗帘面料</h3><ul><li>纯棉布：褪色爱皱“洗一次缩一半”，求你打死别买</li><li>亚麻：窗帘全屋适用，但缩水爱皱又透光。亚麻窗帘适合选择困难星人，在窗帘款式上举棋不定的话，选亚麻一定不会出错</li><li>天鹅绒：卧室需要保护隐私或隔音，选厚一些的窗帘最佳，想低成本装出惊艳效果的，首选天鹅绒</li><li>亚麻或纱帘：客厅、阳台、书房等需要保证充足阳光的空间，选薄质的亚麻或纱帘</li><li>怕光星人追求颜值，可以选“薄帘+遮光帘”双层组合</li><li>高精密遮光布：想遮光又隔热，就买高精密遮光布</li></ul><h3 id="参考-1"><a href="#参考-1" class="headerlink" title="参考"></a>参考</h3><ul><li><a href="https://www.zhihu.com/question/22923832/answer/942328402" target="_blank" rel="noopener">家居搭配窗帘有什么技巧？ - 住范儿石乐天的回答 - 知乎</a></li></ul><h2 id="新房-Tips"><a href="#新房-Tips" class="headerlink" title="新房 Tips"></a>新房 Tips</h2><h3 id="验房"><a href="#验房" class="headerlink" title="验房"></a>验房</h3><p>目前国内开发商都很强势，都会要求先签字收房再验房，先验后拿需要业主自己去争取。如果只能拿房后验房的话，大家不要着急，有问题也还是开发商的责任，提醒大家在拿房当天物业给你们的房屋确认书签字栏里写一句话：“以本人找的第三方检测公司出具的验房报告为准，房屋有待维修。”后期如果验出大问题，也可以起诉索赔。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;被子&quot;&gt;&lt;a href=&quot;#被子&quot; class=&quot;headerlink&quot; title=&quot;被子&quot;&gt;&lt;/a&gt;被子&lt;/h2&gt;&lt;h3 id=&quot;被子分类&quot;&gt;&lt;a href=&quot;#被子分类&quot; class=&quot;headerlink&quot; title=&quot;被子分类&quot;&gt;&lt;/a&gt;被子分类&lt;/h
      
    
    </summary>
    
      <category term="Life" scheme="https://michael728.github.io/categories/Life/"/>
    
    
      <category term="装修" scheme="https://michael728.github.io/tags/%E8%A3%85%E4%BF%AE/"/>
    
      <category term="购物" scheme="https://michael728.github.io/tags/%E8%B4%AD%E7%89%A9/"/>
    
      <category term="软装" scheme="https://michael728.github.io/tags/%E8%BD%AF%E8%A3%85/"/>
    
  </entry>
  
  <entry>
    <title>IT程序员的装修笔记——实木家具</title>
    <link href="https://michael728.github.io/2020/11/09/life-shopping-wood-furniture/"/>
    <id>https://michael728.github.io/2020/11/09/life-shopping-wood-furniture/</id>
    <published>2020-11-09T21:29:08.000Z</published>
    <updated>2021-02-12T13:27:05.289Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>家具选择上，个人主要喜欢木质家具，摸上去质感舒服。而且，木质家具也比较耐用，记得以前老家那张八仙桌，真是用了很多年，童年的回忆。本文主要就介绍家具的一些选购经验。</p><h2 id="床"><a href="#床" class="headerlink" title="床"></a>床</h2><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ul><li><a href="https://post.smzdm.com/p/ax08wle9/?send_by=3145139953" target="_blank" rel="noopener">什么值得买/大师谈实木家具选购 篇二：实木床的用料、选材、结构、工艺和功能</a></li></ul><h2 id="沙发"><a href="#沙发" class="headerlink" title="沙发"></a>沙发</h2><h2 id="茶几、电视柜"><a href="#茶几、电视柜" class="headerlink" title="茶几、电视柜"></a>茶几、电视柜</h2><h2 id="餐桌"><a href="#餐桌" class="headerlink" title="餐桌"></a>餐桌</h2>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;家具选择上，个人主要喜欢木质家具，摸上去质感舒服。而且，木质家具也比较耐用，记得以前老家那张八仙桌，真是用了很多年，童年的回忆。本文主要就介
      
    
    </summary>
    
      <category term="Life" scheme="https://michael728.github.io/categories/Life/"/>
    
    
      <category term="装修" scheme="https://michael728.github.io/tags/%E8%A3%85%E4%BF%AE/"/>
    
  </entry>
  
  <entry>
    <title>IT程序员的装修笔记——衣柜定制</title>
    <link href="https://michael728.github.io/2020/10/16/life-shoppinmg-closet/"/>
    <id>https://michael728.github.io/2020/10/16/life-shoppinmg-closet/</id>
    <published>2020-10-16T21:29:08.000Z</published>
    <updated>2021-02-12T13:27:05.289Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://gitee.com/michael_xiang/images/raw/master/uPic/pexels-visually-us-1648839.jpg" alt="us"></p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>最近在考虑家里衣柜定制的事情，发现这个行业真不像买电器那么容易……商家给板材门取的名字真是五花八门，比如生态板、无醛板、禾香板、康纯板、爱格板等等，听着一个比一个高大上！</p><p>经过查阅各种文档、帖子、视频，将了解到的内容做个笔记，方便更多的业主熟悉一下这行业的基本情况，避免踩坑。</p><a id="more"></a><h2 id="环保标准"><a href="#环保标准" class="headerlink" title="环保标准"></a>环保标准</h2><p>先来了解一下板材的环保标准：</p><ul><li>E0：目前国标只对强化复合地板有 E0 级的评定标准，其他木制品只有 E1 和 E2 两个标准</li><li>E1：国标用于室内的标准是 E1 级（0.124mg/m3）</li></ul><blockquote><p>商家宣传里的 E0 级一直是市场炒作并未写进国家标准的。2017年，中国发布《室内装饰装修材料人造板及其制品中甲醛释放限量》（GB18580——2017）中国家标准中无 E0 级标准。因此提个醒，如果最终签合同时，记得要明确是国标 E1。</p></blockquote><p>GB18580——2017 标准链接：<a href="http://www.jianbiaoku.com/webarbs/book/11724/3216471.shtml" target="_blank" rel="noopener">http://www.jianbiaoku.com/webarbs/book/11724/3216471.shtml</a></p><p><img src="https://gitee.com/michael_xiang/images/raw/master/uPic/1EUP6m.png" alt="要求截图"></p><p>补充：所谓 F4 星标准，其实就是日本的 <code>F☆☆☆☆</code> 认证标准。F4 星源于日本农林省的法律法规，是日本国土交通部颁发的证书，它是日本标准环保最高的健康等级，更被认为是国际上最健康的环保标准。如果按照平时的 E1、E0 级标准来看的话，那么 F3 星相当于国家 E0 级标准，建议限制使用面积，F4 星则远高于 F3 星，在使用面积上<strong>无限制</strong>。</p><p>参考：</p><ul><li>百度百科：<a href="https://baike.baidu.com/item/F4%E6%98%9F%E6%A0%87%E5%87%86" target="_blank" rel="noopener">https://baike.baidu.com/item/F4%E6%98%9F%E6%A0%87%E5%87%86</a></li></ul><h2 id="板材介绍"><a href="#板材介绍" class="headerlink" title="板材介绍"></a>板材介绍</h2><p>关于板材的讨论众说纷纭：</p><ul><li>有人对颗粒板一棒子打死，认为它肯定没有常见的多层板、杉木芯板环保……</li><li>有人就认为大品牌用的颗粒板（比如禾香板、康纯板）就一定比多层板更好……</li></ul><p>其实，个人觉得上面那些看法都太绝对！抛开<strong>基材品牌、封边工艺、贴面工艺</strong>直接就否定其他板材类型的做法，要么就是动机不纯、要么就是井底之蛙~</p><p>现实生活中最常见的是，在不靠谱的渠道，消费者花了 E1 板材的价格，实际拿到的是 E2 级别的产品。</p><p>经过阅贴无数，总结一句话：只要确保是可靠品牌的板子，商家可信，封边、贴面工艺先进，合同里明确符合国标 E1 标准，那么，质量都不会差到哪里去！</p><p>先说重点：</p><ul><li>家具的核心不仅仅不在板材，五金也非常重要！</li><li>封边和贴面的工艺水平也不能忽视！</li></ul><h3 id="术语"><a href="#术语" class="headerlink" title="术语"></a>术语</h3><p>介绍板材种类之前，先熟悉一下相关名词：</p><ul><li>素板/板芯：一般指从板材供应商直接拿到的基材，没有进行封边、贴面等处理</li><li>贴面：板式家具的贴面主要以贴纸皮、贴木皮、烤漆、水晶板、防火板、模压板为主<ul><li>三聚氰胺纸：色彩丰富，经过了三聚氰胺树脂浸泡，它使得家具板材不易变形、耐腐蚀。缺点是只有平面造型，做不了凹凸效果</li><li>实木贴面：将天然木皮粘在基材的饰面板上，看起来像是实木家具。缺点是不易清洗，过于潮湿易变质</li><li>烤漆饰面：光泽好、防水性好、抗污能力强，易于造型。缺点是怕磕磕碰碰</li><li>防火板饰面：表面色彩丰富、方便加工，保温隔热，缺点是门板为平板，做不了凹凸造型</li><li>水晶板饰面：现代感强烈，其实是 PVC 透明软板，表面贴了游记玻璃板（类似常说的亚克力），成型后的板表面高光、亮丽透明，缺点是不耐磨、容易留下划痕、热胀冷缩易变形</li><li>模压板饰面：模压板表面有一定造型，可加工成各种形状，有高光和哑光两种选择，缺点是价格较贵，以进口品牌为主</li></ul></li><li>封边：无起鼓无开裂。封边不好的有明显的交接线，不整齐。<strong>封边工艺是检验一个品牌做工好坏的细节点。</strong>激光封边是目前一种主流的高水准封边工艺</li></ul><p>参考：</p><ul><li>鲁班园/六大家具贴面材料：<a href="http://www.lubanyuan.cn/jishu/tmfm/3138.html" target="_blank" rel="noopener">http://www.lubanyuan.cn/jishu/tmfm/3138.html</a></li><li>一兜糖/超详细橱柜选购攻略：<a href="http://www.yidoutang.com/guide-83034.html" target="_blank" rel="noopener">http://www.yidoutang.com/guide-83034.html</a></li></ul><blockquote><p>接下来，是我从网上找到的一些关于各类板材的介绍。可能有些描述也不太精确，仅供参考。</p></blockquote><h3 id="密度板"><a href="#密度板" class="headerlink" title="密度板"></a>密度板</h3><p><img src="https://gitee.com/michael_xiang/images/raw/master/uPic/lYS3oZ.png" alt="密度板"></p><ul><li>材料：以木质纤维或其他植物纤维为原料、加热、加压压制</li><li>优点：<ul><li>结构均匀、性能稳定，易加工</li></ul></li><li>缺点：<ul><li><strong>密度太高，容易开裂，不适合做家具</strong></li><li>不防潮，见水容易发胀</li><li>握钉力差</li></ul></li><li>用途：一般密度板适合做室内装潢、墙板、隔板等</li></ul><h3 id="颗粒板-刨（bao）花板"><a href="#颗粒板-刨（bao）花板" class="headerlink" title="颗粒板/刨（bào）花板"></a>颗粒板/刨（bào）花板</h3><p><img src="https://gitee.com/michael_xiang/images/raw/master/uPic/9BMPWe.png" alt="颗粒板"></p><ul><li>材料：由木材或其他木质纤维材料制成的碎料+胶水粘剂+压力合成的人造板。</li><li>优点：<ul><li>没有虫眼</li><li>稳定性好、材质均匀</li><li>防潮性能高于生态板</li><li>握钉力强</li><li>质轻</li></ul></li><li>缺点：<ul><li>环保性能比不过多层板（比较的是旧工艺的颗粒板，不绝对）</li></ul></li></ul><p>颗粒板也叫做刨花板。刨花板交叉错落结构，各方向力基本相同，尺寸稳定，厚度大，升级后的 OSB 工艺，甲醛释放更低。现在较火的 OSB 欧松板就是改进后的刨花板。</p><blockquote><p>欧松板就是大片大片的刨花，所谓的定向刨花板，加的 MDI 胶也更加环保</p></blockquote><h3 id="爱格板"><a href="#爱格板" class="headerlink" title="爱格板"></a>爱格板</h3><p>爱格英文名叫 EGGER，是一家创建于 1961 年的奥地利企业。爱格板不是一种特殊的板材，它就是三聚氰胺刨花板！主要是因为它的环保性比较好，在国内才比较有名，称他们的板材为「爱格板」。</p><p>因为有名，所以模仿者众多！消费者花了爱格板的价格，不一定拿到的就是真的爱格板，需要仔细筛选、甄别！希望遇到的商家是一位有良心的商家，而不是只顾赚钱、不顾消费者家庭健康的无良商家。</p><p>W980 在爱格板里的存在更类似于柜体专用，<strong>是爱格板里唯一一个不是激光封边的色号</strong>，一般都会用来做柜体，非要做柜门也可以，但是可能效果没有那么好。W1000 就是很标准的门板，和 U702 等色号一样，大部分人用来做门板。</p><p>下面介绍一下如何查看爱格正规的授权商家：<br>1.登录爱格官网，查看哪些是授权经销商 <a href="https://www.egger.com/shop/zh_MO/about-us/sources-of-supply：" target="_blank" rel="noopener">https://www.egger.com/shop/zh_MO/about-us/sources-of-supply：</a></p><p><img src="https://gitee.com/michael_xiang/images/raw/master/uPic/3bKJz3.png" alt="经销商列表"></p><p>2.访问对应经销商的官网，查看授权客户 <a href="http://www.vigour.net.cn/index.php?c=article&amp;a=type&amp;tid=101：" target="_blank" rel="noopener">http://www.vigour.net.cn/index.php?c=article&amp;a=type&amp;tid=101：</a></p><p><img src="https://gitee.com/michael_xiang/images/raw/master/uPic/ExSpqz.png" alt="授权客户"></p><blockquote><p>看到群主联系的爱格板厂家的  LOGO 了，可以确认他就是一个正规的爱格板授权方。</p></blockquote><h3 id="胶合板"><a href="#胶合板" class="headerlink" title="胶合板"></a>胶合板</h3><p>胶合板是一个<strong>统称</strong>，它有如下常见的几种板材种类。</p><h4 id="大芯板-细木工板"><a href="#大芯板-细木工板" class="headerlink" title="大芯板/细木工板"></a>大芯板/细木工板</h4><p><img src="https://gitee.com/michael_xiang/images/raw/master/uPic/M0Z2Jk.png" alt="大芯板"></p><ul><li>材料：中间基材（板芯材）为拼接实木（如杉木、杨木等）组成，表面是三聚氰胺贴面</li><li>优点：<ul><li>环保较好，因为生产使用的是杉木等密度较低的实木，加工过程用到胶水较少</li><li>防潮、耐高温</li><li>性价比高</li></ul></li><li>缺点：<ul><li>握钉力不太好</li><li>变形系数大</li></ul></li></ul><h4 id="多层板"><a href="#多层板" class="headerlink" title="多层板"></a>多层板</h4><p><img src="https://gitee.com/michael_xiang/images/raw/master/uPic/9ZHgPN.png" alt="多层板"></p><ul><li>材料：多层实木加热、加压粘合，表面以实木贴皮等工序制作而成</li><li>优点：<ul><li>环保性能高于颗粒板，低于生态板</li><li>变形小、强度大、结构稳定性好</li><li>握钉力高于颗粒板和生态板</li></ul></li><li>缺点：<ul><li>价格比颗粒板贵</li></ul></li></ul><p>行业背景：</p><ul><li>胶合板九成以上用脲醛树脂，用酚醛树脂是安全，但是贵啊！</li></ul><h4 id="生态板-免漆板"><a href="#生态板-免漆板" class="headerlink" title="生态板/免漆板"></a>生态板/免漆板</h4><p>生态板其实就是饰面板，也叫免漆板，是将带有不同颜色或纹理的纸放入三聚氰胺树脂胶粘剂中浸泡，然后干燥到一定固化程度再贴在人造板材（细木工、刨花板、颗粒板）表面装饰的装饰面板。细木工板表层为树皮（装饰面板）。</p><blockquote><p>在毒奶粉事件中三聚氰胺出名了，但它在板材里其实是很成熟的工艺，不要被它吓退</p></blockquote><p>然而，我们去市场上去买的生态板大多是指大芯板贴三聚氰胺的板，其内芯是用杉木条平铺两面各贴一层薄板而成，板的质量好坏在于杉木条铺的是否密实，两面薄板的材质和厚度。</p><p>为什么市场上买的生态板主要是这种呢？因为只有这种板才适合家装现场木工使用，木工现场使用的大多是小圆盘锯，只有这种板才能锯的动，不会有锯齿痕，不会有大的崩边，像多层板是小锯很难锯动根本锯不直的，颗粒板又会崩边很厉害，密度板是不能用来做柜体的。</p><h3 id="实木指接板"><a href="#实木指接板" class="headerlink" title="实木指接板"></a>实木指接板</h3><p><img src="https://gitee.com/michael_xiang/images/raw/master/uPic/fdiTgR.png" alt="指接板"></p><h3 id="胶水"><a href="#胶水" class="headerlink" title="胶水"></a>胶水</h3><p>常见的如脲醛树脂、酚醛、三聚氰胺—甲醛胶粘剂等都是含有可游离的甲醛。还有一种胶黏剂原材料，叫异氰酸酯，英文名 MDI。它与前面说过的脲醛树脂相比，最大的优点就是没有游离甲醛，而且高温下也不会产生甲醛；缺点就是比较贵。</p><p>万华集团是中国唯一拥有 MDI 生产技术与能力的企业。他们官网是有提供合作品牌的列表的，可以访问查询：</p><p><img src="https://gitee.com/michael_xiang/images/raw/master/uPic/LlRaA7.png" alt="品牌客户"></p><ul><li>万华官网：<a href="https://www.whchem.com/" target="_blank" rel="noopener">https://www.whchem.com/</a></li><li>万华禾香板官网：<a href="http://www.whstby.cn/customer/?page=7" target="_blank" rel="noopener">http://www.whstby.cn/customer/?page=7</a></li></ul><h3 id="板材供应商"><a href="#板材供应商" class="headerlink" title="板材供应商"></a>板材供应商</h3><p><img src="https://gitee.com/michael_xiang/images/raw/master/uPic/ONwh92.png" alt="标准起草单位"></p><p>看了 <a href="http://www.jianbiaoku.com/webarbs/book/11724/3216471.shtml" target="_blank" rel="noopener">GB18580——2017 标准</a>的文件，发现了这个起草单位列表，我看觉得这应该都是行业龙头吧，应该都是比较可靠的品牌了！</p><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ul><li><a href="https://www.xiaohongshu.com/discovery/item/5f54b3ab0000000001003fdb?source=question" target="_blank" rel="noopener">小红书/为大家介绍一下衣柜通用的四种板材如下</a></li><li><a href="https://www.zhihu.com/question/50623779" target="_blank" rel="noopener">知乎/实木颗粒板与多层实木板做柜体如何选择？</a></li><li><a href="http://jiaju.leju.com/shiliu/6642613467230831993.shtml" target="_blank" rel="noopener">石榴家/实木板？颗粒板？生态板？眼花缭乱分不清？看完选家具有谱了</a></li></ul><h2 id="五金"><a href="#五金" class="headerlink" title="五金"></a>五金</h2><p>五金是个值得关注的地方，每天开合柜门等，如果阻尼有问题、生锈、变形等，都会影响使用体验！</p><h3 id="五金小件"><a href="#五金小件" class="headerlink" title="五金小件"></a>五金小件</h3><ul><li>滑轨</li><li>铰链 </li><li>轨道</li><li>拉手</li></ul><p><img src="https://gitee.com/michael_xiang/images/raw/master/uPic/T7NAwh.png" alt="铰链"></p><h3 id="五金品牌"><a href="#五金品牌" class="headerlink" title="五金品牌"></a>五金品牌</h3><ul><li>海蒂诗/Hettich：德国品牌，官网 <a href="https://web.hettich.com/zh-cn/%E4%B8%BB%E9%A1%B5.jsp" target="_blank" rel="noopener">https://web.hettich.com/zh-cn/%E4%B8%BB%E9%A1%B5.jsp</a></li><li>百隆/Blum：奥地利品牌，官网 <a href="https://www.blum.com/cn/zh/" target="_blank" rel="noopener">https://www.blum.com/cn/zh/</a></li><li>顶固：广东，<a href="https://www.dinggu.net/" target="_blank" rel="noopener">https://www.dinggu.net/</a></li><li>东泰 DTC</li><li>固特：广东</li><li>斯力高：广州</li></ul><blockquote><p>市面上很多百隆铰链用的都是山寨的阻尼器，需要谨防商家使用山寨货！！！</p></blockquote><h3 id="细节"><a href="#细节" class="headerlink" title="细节"></a>细节</h3><ul><li>国产铰链的固定位常见是 4 个螺丝位，而进口的则是 2 个（因为国外常见颗粒板，握钉力强，而国内常用多层板、大芯板等，因此要多用几个螺丝位）</li><li>重量也是评价铰链好坏的一个细节</li></ul><h3 id="参考-1"><a href="#参考-1" class="headerlink" title="参考"></a>参考</h3><ul><li>什么值得买/铰链都不懂，还瞎选啥家具：<a href="https://post.smzdm.com/p/a83dm9l0/" target="_blank" rel="noopener">https://post.smzdm.com/p/a83dm9l0/</a></li></ul><h2 id="合同签署注意事项"><a href="#合同签署注意事项" class="headerlink" title="合同签署注意事项"></a>合同签署注意事项</h2><ul><li>环保等级签署在合同里</li><li>板材用料、五金品牌，明确签署在合同里</li><li>比如明确注明「材料品牌、环保等级符合合同说明，假一赔十」</li></ul><h2 id="设计"><a href="#设计" class="headerlink" title="设计"></a>设计</h2><p>虽然各花入各眼，但是向优秀的设计学习是有效提升审美的途径。</p><h3 id="设计避免踩坑"><a href="#设计避免踩坑" class="headerlink" title="设计避免踩坑"></a>设计避免踩坑</h3><p>定制衣柜我们要避免如下的设计：</p><p>1.框门不同色</p><p><img src="https://gitee.com/michael_xiang/images/raw/master/uPic/YBCBjE.png" alt="框门不同色"></p><p>2.门板线条错缝</p><p><img src="https://gitee.com/michael_xiang/images/raw/master/uPic/GkkTmk.png" alt="错缝"></p><p>3.白色木纹：要么选纯白色、要么选原木色</p><p><img src="https://gitee.com/michael_xiang/images/raw/master/uPic/Sv0wlM.png" alt="白色木纹"></p><p>4.有花纹樱花、有腰线装饰带</p><p><img src="https://gitee.com/michael_xiang/images/raw/master/uPic/aw7v4n.png" alt="腰线"></p><p>建议：定制衣柜越低调越好，选择纯白色、纯平门板，百搭。柜子低调，家具高调~</p><p>参考：</p><ul><li><a href="https://mp.weixin.qq.com/s/Zd2KGKfikuTu3X-KidMfYQ" target="_blank" rel="noopener">住范儿/定制柜这6种设计，劝你千万不要做！</a></li></ul><h2 id="一言"><a href="#一言" class="headerlink" title="一言"></a>一言</h2><p>在做笔记的同时发现一些品牌的官网就很与时俱进，比如爱格、百隆、海蒂诗、顶固、兔宝宝，他们官网都启用了 HTTPS 协议，而大多数品牌的官网则还是老旧的 HTTP 协议，比如知名的千年舟……当然，并不是他官网没有与时俱进，就代表它产品就不好。只是想说，细节决定成败，用心维护官网，让我觉得更放心！</p><blockquote><p>最后采用了爱格的板材，一是他们官网确实很可靠，各级经销商都能查到，二是他们板材的口碑确实都挺好~</p></blockquote><p>衣柜定制篇就总结到这儿啦，祝愿小伙伴们都能装修不踩坑！Peace~</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://gitee.com/michael_xiang/images/raw/master/uPic/pexels-visually-us-1648839.jpg&quot; alt=&quot;us&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;最近在考虑家里衣柜定制的事情，发现这个行业真不像买电器那么容易……商家给板材门取的名字真是五花八门，比如生态板、无醛板、禾香板、康纯板、爱格板等等，听着一个比一个高大上！&lt;/p&gt;
&lt;p&gt;经过查阅各种文档、帖子、视频，将了解到的内容做个笔记，方便更多的业主熟悉一下这行业的基本情况，避免踩坑。&lt;/p&gt;
    
    </summary>
    
      <category term="Life" scheme="https://michael728.github.io/categories/Life/"/>
    
    
      <category term="装修" scheme="https://michael728.github.io/tags/%E8%A3%85%E4%BF%AE/"/>
    
  </entry>
  
  <entry>
    <title>【转】程序员如何把控自己的职业</title>
    <link href="https://michael728.github.io/2020/10/08/soft-skills-IT/"/>
    <id>https://michael728.github.io/2020/10/08/soft-skills-IT/</id>
    <published>2020-10-08T13:55:08.000Z</published>
    <updated>2021-02-12T13:27:05.293Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://gitee.com/michael_xiang/images/raw/master/uPic/指南针-方向.jpg" alt="方向"></p><blockquote><p>本文转载自 <a href="https://coolshell.cn/articles/20977.html" target="_blank" rel="noopener"> 酷 壳 – CoolShell </a>。</p></blockquote><p>这篇文章的主要内容主要是我今年3月份在腾讯做的直播，主要是想让一些技术人员对世界有一个大体的认识，并且在这个认识下能够有一个好的方法成就自己。而不是在一脸蒙圈的状态下随波逐流，而日益迷茫和焦虑。直播完后，腾讯方面把我的直播形成文字的形式发了出来，我觉得我可以再做一个精编版。所以，有了这篇文章，希望对大家有帮助。</p><a id="more"></a><p>对我来说，在我二十多年的工作经历来看，期间经历了很多技术的更新换代，整个技术模式、业务模式也是一直变来变去，我们这群老程序员成长中所经历的技术比今天的程序员玩的还更杂更多。我罗列一下我学过的，而且还被淘汰掉的技术，大家先感受一下。</p><ul><li>MIS应用开发：FoxPro，PowerBuilder，Delphi</li><li>OA：Lotus Notes，VBScripts</li><li>微软：ODBC/ADO，COM/DCOM，MFC/ATL，J++</li><li>服务器：AIX，HP-UX，SCO Unix</li><li>Web：CGI，ISAPI，SOAP</li><li>RPC：CICS，Tuxedo</li><li>J2EE：Websphere，Weblogic</li><li>DB：Sybase，Informix </li></ul><p>我想说的是，无论过去还是今天，我们这些前浪和你们后浪所面对的技术的挑战和对技术的焦虑感是相似的，我们那个时候不但玩996，还玩封闭开发（就是一周只能回家一天）。当然，唯一好的东西，就是比起今天的程序员来说，我们那个年代没有像微信、微博、知乎，抖音这些巨大消耗你人生的东西，所以，我们的工作、生活和成长都有很效率，不会被打断、喜欢看书、Google还没有被封……当然，那时代没有StackOverlow和Github这样的东西，所以，能完成的东西或质量都一般。</p><p>当然，这里并不是想做一个比较，只是想让大家了解一下两代程序员间的一些问题各有千秋，大同小异。在整个成长过程中，其实有很多东西是相通的，基本上来说，就是下面的三件事——</p><p>第一，如果想要把控技术，应对这个世界的一些变化，需要大致知道这个世界的一些规律和发展趋势，另外还得认识自己，自己到底适合做什么？在这个趋势和规律下属于自己的发挥领域到底是什么？这是我们每个人都需要了解的。</p><p>第二，打牢基础，以不变应万变，不管世界怎样变化，我都能很快适应它。基础的重要程度对于你能够飞多高是相当有影响的，懂原理的人比不懂原理的人能做出来的事情或是能解决的问题完全是两个层级的。</p><p>第三，提升成长的效率，因为现在社会的节奏实在太快了，比二十年前快得太多，技术层出不穷，所以我们的成长也要更有效率。效率并不单指的快，效率是怎么样更有效，是有用功除以总功（参看《加班与效率》），怎么学到更有效的东西，或者怎么更有效学习，是我们需要掌握的另一关键。</p><p>下面是我这多年来的一些认识，希望对你有帮助。</p><h2 id="世界发展趋势"><a href="#世界发展趋势" class="headerlink" title="世界发展趋势"></a>世界发展趋势</h2><p>我个人经历的信息化革命应该分成三个阶段：</p><ul><li>1990年代到2000年，这个时代MB时代，是雅虎、新浪、搜狐、网易门户网站的时代，这个时代就是ISP/ICP互联网提供商，把一些资讯数字化，然后发布到网络上。</li><li>2000年到2010年，这个时代叫GB时代，或是叫多媒体或UGC时代，上网开始变得普遍了，每个人手里的数码设备开始变得多了起来，可以上传照片，可以上传视频，甚至可以在网上做社交。</li><li>2010年到2020年，这个时代叫TB时代，这过去的十年是移动互联网时代，移动互联网只需要手机在线，不需要依靠电脑。因为手机随时在线，所以个人的各种各样的数据始终在被收集，只要用户上网就会产生数据，所以人的行为最终也被数字化了。</li></ul><p>所有的硬件和软件都是跟着需要处理的数据而演进的，我们需要更大的带宽，更大的硬盘，更多的处理器……大到一定时候就只能进入分布式化的技术架构了，再大，数据中心也顶不住了，就会要引入更为分布式的边缘计算了。</p><p>另一方面，从业务上来看，我们可以看到整个世界就在不断地进行数字化，因为，只要数字化了，就可以进行复制传播和计算，只要可以进行计算了，就可以进行数学建模，就可以自动化，只要可以自动化了就可以规模化，只要可能规模化了，就可以改变整个行业。人类的近代史的大趋势基本上都是在解决能源和自动化的事，源源不断的能源是让机器不知疲倦的前提条件，用机器代替牲口，代替人类进行工作是规模化的前提条件。</p><p>所以，技术的演进规律基本是自动化加规模化，从而降低成本，提升效率。这就是为什么世界变得越来越快，人类都快跟不上节奏的原因，主要是整个社会不断被机器、数据所驱动。</p><h2 id="人才需求"><a href="#人才需求" class="headerlink" title="人才需求"></a>人才需求</h2><p>在这个过程中，需要什么样的人？下面是我的一些认识——</p><ul><li>技工，在机器和自动化面前，肯定是需要能够操作机器的技术工人了，这类人是有技术的劳动力。在编程的圈子里俗称“码农”，他们并不是真正的工程师，他们只是电脑程序的操作员，所以，随着技术门槛的下降或是技术形式的变更他可能就会变得越来越不值钱，直到被淘汰掉。</li><li>特种工，这种人是必须了解原理和解决难题的一类人，他们是解决比较难的、特定的一些技术问题。当一种技术被淘汰，他并不容易被淘汰，因为他懂原理，原理就是解决问题的能力，是解决问题的套路和方法。</li><li>工程师，不但是使用技术，还可以把活儿做好，他们认为代码更多的时间是在维护，这些人使用各种各样的手段和各种技术，精益求精地持续不断地提高代码的易读性、扩展性、可维护性和重用性，这个过程似乎永无止境。对于这些有“洁癖”，有“工匠精神”，有“修养”的技术人员，我们称他们为工程师。这种人做事又稳又快，而且可以做出很多称手的工具和方法论。</li><li>再往上是设计师和架构人员，这些人主要是开发一些工具，框架，模式，提升软件开发和维护效率，同时也提升用户体验，和提升稳定性、性能、代码重用等，总的来说就是为了降本增效。这类人的工作降低了技术得到门槛，他们把技术门槛降低了以后，就可以把这个技术普及开来，就可以由广大劳工、技工、特殊工人使用了。</li><li>还有一类人是经理，经理主要是组织团队、完成项目、创造利润。这类人中，即有身先士卒的leader，也有高高在上的boss，但无论怎么样，这些人只不过是为了让一个公司或是一个团队更好组织在一起的“粘合剂”，这类人只有在大公司中才会变成更有价值。</li></ul><p>这就是我总结的世界需要哪些人才，我们了解这些东西以后大概就明白我们现在所处的位置有什么样的问题，我们应该去什么样的地方。</p><h2 id="Google评分卡"><a href="#Google评分卡" class="headerlink" title="Google评分卡"></a>Google评分卡</h2><p>接下来，我们再来看看Google的SRE的自我评分卡：</p><ol start="0"><li>对于相关的技术领域还不熟悉</li><li>可以读懂这个领域的基础知识</li><li>可以实现一些小的改动，清楚基本的原理，并能够在简单的指导下自己找到更多的细节。</li><li>基本精通这个技术领域，完全不需要别人的帮助</li><li>对这个技术领域非常的熟悉和舒适，可以应对和完成所有的日常工作。<ul><li>对于软件领域 – 有能力开发中等规模的程序，能够熟练和掌握并使用所有的语言特性，而不是需要翻书，并且能够找到所有的冷知识。</li><li>对于系统领域 – 掌握网络和系统管理的很多基础知识，并能够掌握一些内核知识以运维一个小型的网络系统，包括恢复、调试和能解决一些不常见的故障。</li></ul></li><li>对于该技术领域有非常底层的了解和深入的技能。</li><li>能够从零开发大规模的程序和系统，掌握底层和内在原理，能够设计和部署大规模的分布式系统架构</li><li>理解并能利用高级技术，以及相关的内在原理，并可以从根本上自动化大量的系统管理和运维工作。</li><li>对于一些边角和晦涩的技术、协议和系统工作原理有很深入的理解和经验。能够设计，部署并负责非常关键以及规模很大的基础设施，并能够构建相应的自动化设施</li><li>能够在该技术领域出一本经典的书。并和标准委员会的人一起工作制定相关的技术标准和方法。</li><li>在该领域写过一本书，被业内尊为专家，并是该技术的发明人。</li></ol><p>SRE需要自评如下这些技术或技能：</p><ul><li>TCP/IP Networking (OSI stack, DNS etc)</li><li>Unix/Linux internals</li><li>Unix/Linux Systems administration</li><li>Algorithms and Data Structures</li><li>C/C++</li><li>Python</li><li>Java</li><li>Perl</li><li>Go</li><li>Shell Scripting (sh, Bash, ksh, csh)</li><li>SQL and/or Database Admin</li><li>Scripting language of your choice (not already mentioned) <strong><strong><strong>_</strong></strong></strong></li><li>People Management</li><li>Project Management</li></ul><p>这个评分卡是面试 Google 前需要候选人对自己的各种技术进行自评，也算是一种技术人员的等级的度量尺，其把技术的能分成 11 个等级，我用颜色把其它成四大层级，希望这个评分卡能够给你一个能力提升的参考标准。</p><h2 id="认识自己"><a href="#认识自己" class="headerlink" title="认识自己"></a>认识自己</h2><p>认识了世界是怎么发展的，也知道技术人员的种类和层级，那么还要了解一下自己，因为如果不了解自己，那么你也无法找到自己的路和适合自己的地方。</p><p>我觉得，一个人要认识自己就需要认识自己的特长、兴趣、热情、擅长等，下面是一个认识自己的标准方法：</p><ul><li>特长。首先你要找得到自己特长。你要认识自己的特长，找到自己的天赋，找到你在DNA里比别人强的东西，就拿你的 DNA 跟别人竞争就好了。所以你要找到自己可以干成的事，找到别人找你请教的事，你身边人找你请教就是说明你有特长。这是找到自己特长非常非常重要，扬长避短。</li><li>兴趣。如果你没有找到自己特长，就找自己有兴趣有热情的东西。什么叫兴趣？兴趣是再难再累都不会放弃的事。如果你遇到困难就会放弃不叫兴趣，那叫叶公好龙。不怕困难，痴迷其中，就算你没有特长，有了这种特质，你也是头部的人才。</li><li>方法。如果你没有特长，没有兴趣和热情就要学方法。这种方法就是要有时间观念，要会做计划，要懂统筹、规划对于做过的事情，犯过的错误多总结，举一反三，喜欢自己找答案，自己探究因果关系，这是一些方法，自己总结一些套路。</li><li>勤奋。如果你没有特长，没有兴趣，也没有方法，你还能做的事就是勤奋，勤奋注定会让你成为一个比较劳累的人，也是很有可能被淘汰的人随着你的年纪越来越大，你的勤奋也会越来越不值钱。因为年轻人会比你更勤奋，比你更勤奋、比你斗志更强，比你能力更强，比你要钱更少的人会出现。勤奋最不值钱，但是只要你勤奋至少能够自食其力。</li></ul><p>以上就是为了应对未来技术变化，作为个人必须要从特长、兴趣、方法一层一层筛选挖掘，如果没有这些你就要努力和勤奋。就只能接受“福报”了。</p><p>从我个人而言，我不算是特别聪明的人，但自认为对技术还是比较感兴趣的，难的我不怕。有很多比较难啃的技术，聪明点的人啃一个月就懂了，我不行，我可能啃半年。但是没有关系，知识都是死的，只要不怕困难总有一天会懂的。最可怕是畏难，为自己找借口，这样就不太好了。</p><h2 id="打好基础"><a href="#打好基础" class="headerlink" title="打好基础"></a>打好基础</h2><p>最前面提到我学的各式各样的被淘汰的技术，会让你感觉很迷茫，或是迷失。但前面也提到了“谷歌评分卡”，在这个评分卡中，我们看到了许多基础原理方面的内容，其实要应对未来的变化，很重要的一点就是无招胜有招，以不变应万变。</p><p>变化都是表面的东西，内在的东西其实并没有太多的变化。理论层面上变得不多，反而形式上的东西今天一个花样，明天一个花样，所以如果要去应对这种变化，就一定要打牢自己的基础，提升内功修养。比如像编程的一些方式和套路，修饰模式原理本质，解耦，提升代码的重用度等。提升代码重用度必须解耦，要跟现实解耦，提升抽象，这些都是一些技术基础。无论用什么语言，都是这么做的。</p><p>打牢基础就可以突破瓶颈，不打牢基础没有办法突破瓶颈。在技术世界不要觉得量变会造成质变，这是不可能的。技术这个东西就像搞建筑砌砖头，砌砖头砌的再多也不可能让你能成为一个架构师的，因为你不懂原理，不懂科学方法，你就不可能成长上去的，就像学数学一样，当你掌握了微积分这种大杀器后，你解题的能力是无所披靡，而微积分这种方式绝对不是你能“量变”出来的。</p><p>所以你必须学习基础的理论知识，如果不学这些基础理论知识，还要学习解题思路和方法，如果你只学在表面，那么当这个技术的形式有变化，就会发现以前学的都没用了，要重头学一遍。掌握技术基础可以让自己找到答案和知识，基础是抽象和归纳，很容易形成进一步的推论。我们学的很多技术实现都逃不脱基础原理，不管是Java，还是其他语言，只要用TCP用的都是相同的原理，逃不出范围，只要抓住原理，举一反三，时间一长了，甚至还可以自己推导答案。对于技术的基础，我会把其它成四类：</p><ul><li>程序语言：语言的原理，类库的实现，编程技术（并发、异步等），编程范式，设计模式……</li><li>系统原理：计算机系统，操作系统，网络协议，数据库原理……</li><li>中间件：消息队列，缓存系统，网关代理，调度系统 ……</li><li>理论知识：算法和数据结构，数据库范式，网络七层模型，分布式系统……</li></ul><p>这些知识其实就是一个计算机科学专业的学生他所要学习的原理，但可惜的是，我们的一些学校教得也很糟糕，不但老师能力不足，而且放着世界上最优秀的教课书不用了，一定要自己写一本。讲也讲不全，还有各种错误，哎……总之，如果你学习用用到的教材不行，那么可以肯定的是你的学习效率一定是很糟糕的。这就是为什么我们大学上完了，还是跟个傻瓜一样，还要在工作中再重新自学。</p><p>不过，就算自学，这些基础技术大概需要四五年的时间堆叠。我工作二十年了，这二十年来基本还是这些原理没变，无论形式怎么变，但是核心永远还是这些，理论创新很难，这是以不变应万变。</p><h2 id="学习效率"><a href="#学习效率" class="headerlink" title="学习效率"></a>学习效率</h2><p><img src="https://gitee.com/michael_xiang/images/raw/master/uPic/styaeO.png" alt="学习金字塔"></p><p>谈到学习效率，就需要拿出这张学习金字塔的图来了。从图可以看到学习方法分布两层，一种是被动学习，也是浅度学习，听讲，阅读，视听，演示都是在被动学习，而与人讨论，自己动手实践，教授给别人是主动学习。主动学习我们称之为深度学习，如果你不能深度学习，你就不能真正学到东西。这也是你会经常有“学那么多干什么，不用就忘了”，这就是浅度学习的症状了。</p><p>下面，我给出一些我自己觉得不错的学习经验：</p><ol><li>挑选一手知识和信息源。对于学习方法：第一我们一定要到知识源去挑选知识，知识信息源非常关键，二手信息丢失太大了，谭浩强写的书就丢失太多信息了。目前计算机一手知识基本都是国外的，所以英文非常重要。我鼓励大家一定读第一手的资料。如果你英语有问题，至少要看翻译过来，最好是原汁原味翻译的，不要我理解了给你讲那种，那种也是被别人嚼一遍再讲给你你没有体会，是别人带着你，别人的体会会影响你，也许你的体会会比他更好，因为是你自己总结出来的东西，所以知识源很重要。</li><li>注意原理和基础第二要注重基础原理。虽然可以忘记这个技术，但是原理记在心里，我可以徒手实现出来，而且通过原理可以更快学习其他类似的技术。所以原理很重要！当你学会C、C++要学Java和GO都很快。</li><li>使用知识图谱一定要学会使用知识图，把知识结构化。从一个技术关键点开始不断地关联和细化下去，比如：关于TCP协议，首先第一个要记住状态图，怎么建立连接，怎么断连接，状态怎么变迁。TCP没有连接，是靠状态维护连接的。其次，要了解TCP怎么保证可靠性，就是丢包以后怎么重传，重传有哪些技术点。然后，重传会让你联想到拥塞控制，拥塞控制到滑动窗口……。这基本就是TCP的所有东西了，找到关键点，然后顺着这个脉络一点点往下想，通过知识图关联就可以进行顺藤摸瓜。我们不需要记所有知识，那些手册的知识不需要记，你知道在哪里能找到就可以了。你脑子里面要有地图，学一个东西就跟在城市生活一样，闭上眼睛就知道地图，A点到B点怎么去大概方向要知道。我在北京我去广州，广州在南边，我大概坐飞机还是火车要心里有数。。</li><li>学会举一反三。就是用不同方法学一个东西，比如说学TCP协议，看书是一种方法，编程是另外一种方法，还有用做Debug去看的，用不同方法学一个东西会让你更加熟悉，你学一个知识的同时把周边也学了。比如说学前端能不能把HTTP学一下，比如说长连接、短连接，包括hp1、hp2有一些不一样的东西。</li><li>总结和归纳。只有学会总结和归纳，才能形成自己的思维框架、自己的套路、自己的方法论，以后学这个东西应该怎么学。就像学一门新的语言，不管GO语言，还是Rust语言，第一件事情就是了解内存是怎么管理的，数据类型什么样，第二是泛型怎么搞，第三是并发怎么弄。还有一些抽象怎么弄，比如说怎么解耦，怎么实现多态？套路这种东西只有学的多了以后才能形成套路，如果你只学会一门语言不会有套路，你要每年学门语言，不用学多精，你思考这个语言有什么不一样，为什么这个这种有玩法，那个有那种玩法，这些东西思考多了套路方法论就出来了。比如说Windows和Linux有什么不同，Linux和Unix又有什么不同？只有总结自己的框架、套路和方法，这些才永远不会被淘汰。</li><li>实践和坚持。剩下就是多做多练，多坚持，只有实践才会有经验，只有锻炼了才能够把自己的脂肪变没，所以，要把知识变成技能必须练，就像小学生学会加减乘除，还是要演练，必须多做题，题目做得多了，自然掌握得好。要挑选好的知识源，注重原理技术，有一些原理的基础的书太枯燥，但是我告诉你学习这些基础太值得投入时间，搬砖赚几十元不值得，因为赚的是辛苦钱，老了就赚不了，必须要赚更有能力的钱，这是学习投资。</li></ol><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>好了，该到这篇文章收尾的时候了，小结一下，如果你想更好的把握时代，提升自己，你需要知道这个时代的趋势是什么，需要什么样的人，这些人需要什么样的能力，这些能力是怎么获得的，投入到基础知识的学习就像“基建”一样，如果基础不好，不能长高，学习能力也是需要适应这个快速时代的重要的基础能力，没有好的学习能力，很快就会掉队被淘汰。</p><p>这些东西，是我从业二十年来的总结和体会，希望对你有用。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://gitee.com/michael_xiang/images/raw/master/uPic/指南针-方向.jpg&quot; alt=&quot;方向&quot;&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;本文转载自 &lt;a href=&quot;https://coolshell.cn/articles/20977.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt; 酷 壳 – CoolShell &lt;/a&gt;。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;这篇文章的主要内容主要是我今年3月份在腾讯做的直播，主要是想让一些技术人员对世界有一个大体的认识，并且在这个认识下能够有一个好的方法成就自己。而不是在一脸蒙圈的状态下随波逐流，而日益迷茫和焦虑。直播完后，腾讯方面把我的直播形成文字的形式发了出来，我觉得我可以再做一个精编版。所以，有了这篇文章，希望对大家有帮助。&lt;/p&gt;
    
    </summary>
    
      <category term="思考" scheme="https://michael728.github.io/categories/%E6%80%9D%E8%80%83/"/>
    
    
      <category term="思考" scheme="https://michael728.github.io/tags/%E6%80%9D%E8%80%83/"/>
    
      <category term="软技能" scheme="https://michael728.github.io/tags/%E8%BD%AF%E6%8A%80%E8%83%BD/"/>
    
  </entry>
  
  <entry>
    <title>Mac 效率工具必备神器 —— Alfred</title>
    <link href="https://michael728.github.io/2020/09/23/tools-dev-mac-alfred/"/>
    <id>https://michael728.github.io/2020/09/23/tools-dev-mac-alfred/</id>
    <published>2020-09-23T23:05:50.000Z</published>
    <updated>2021-02-12T13:27:05.293Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://gitee.com/michael_xiang/images/raw/master/uPic/w3dQKD.png" alt="Alfred"></p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><a href="https://www.alfredapp.com/" target="_blank" rel="noopener">alfred</a> 这款软件称为「神器」真是当之无愧。今天专门总结一下，作为之前 <a href="https://michael728.github.io/2019/04/14/tools-dev-mac/">Mac 配置教程-开发篇</a> 的补充。</p><a id="more"></a><blockquote><p>需要说明的是，如果你发现我介绍的功能无法使用，则代表需要花钱购买它的 Powerpack。麦哥是从淘宝购买的正版永久激活码搞定的，百十块大洋~如果你囊中羞涩，也有一些网站提供了破解版本。关注公众号[Coder魔法院]，回复 Alfred，会提供对应的下载网站（注意：破解版软件往往会有安全风险）。</p></blockquote><h2 id="General-通用设置"><a href="#General-通用设置" class="headerlink" title="General 通用设置"></a>General 通用设置</h2><ul><li><code>Startup</code>：勾选上，这样就能在登录系统时自动启动 Alfred；</li><li><code>Alfred Hotkey</code>： 启动 Alfred 的快捷键，我设置的是双击 Command 键；</li></ul><p><img src="https://gitee.com/michael_xiang/images/raw/master/uPic/CzLoxh.png" alt="通用设置"></p><h2 id="Alfred-基本功能"><a href="#Alfred-基本功能" class="headerlink" title="Alfred 基本功能"></a>Alfred 基本功能</h2><ul><li><code>/</code>：输入 <code>/</code>，会跳转到系统根目录；</li><li><code>~</code>：输入 <code>~</code>，会进入当前用户的用户目录；</li><li>输入搜索内容后，<code>Enter</code> 按键是直接打开文件，<code>Command + Enter</code>表示打开文件所在文件夹；</li><li><code>Command + L</code> 居中放大显示结果；</li></ul><h3 id="搜索应用"><a href="#搜索应用" class="headerlink" title="搜索应用"></a>搜索应用</h3><p><img src="https://gitee.com/michael_xiang/images/raw/master/uPic/PD2BnJ.png" alt="搜索应用"></p><h3 id="文件搜索"><a href="#文件搜索" class="headerlink" title="文件搜索"></a>文件搜索</h3><ul><li><code>Find + 文件名</code>：搜索文件，Enter 确认之后，直接跳转到 Finder 中文件所在位置；</li><li><code>Open + 文件名</code>：搜索文件，Enter 确认之后，直接打开该文件；</li></ul><p><img src="https://gitee.com/michael_xiang/images/raw/master/uPic/FidDNA.png" alt="find"></p><h3 id="内容搜索"><a href="#内容搜索" class="headerlink" title="内容搜索"></a>内容搜索</h3><p>输入 <code>in</code> 命令加空格，以及待搜索的文本，列出磁盘中包含该文本的相关文件：</p><p><img src="https://gitee.com/michael_xiang/images/raw/master/uPic/74XFzg.png" alt="in"></p><h2 id="Features-特性功能"><a href="#Features-特性功能" class="headerlink" title="Features 特性功能"></a>Features 特性功能</h2><p>Features 功能很多，这里仅介绍目前个人发现的常用设置。</p><h3 id="Default-Results-默认结果"><a href="#Default-Results-默认结果" class="headerlink" title="Default Results 默认结果"></a>Default Results 默认结果</h3><p>这个菜单项主要是设置 Alfred 搜索结果时，默认从哪些目录搜索出结果。</p><ul><li><code>Essentials</code>：搜索系统偏好设置和联系人信息；</li><li><code>Extras</code>：指定搜索对象，比如文件夹、文档、图片等。如果格式不全，可以点击 <code>Advanced</code> 按钮自定义；</li><li><code>Search Scope</code>：指定搜索范围，哪些路径可以搜；</li></ul><p><img src="https://gitee.com/michael_xiang/images/raw/master/uPic/HbqAlq.png" alt="Default Results"></p><h3 id="Web-Search-文件搜索"><a href="#Web-Search-文件搜索" class="headerlink" title="Web Search 文件搜索"></a>Web Search 文件搜索</h3><p>该功能非常方便，快捷键启动 Alfred 之后，输入指定网站的关键字，然后输入要搜索的内容，按下 Enter 键之后自动跳转到浏览器对应网站的搜搜结果，一气呵成的搜索体验！</p><p><img src="https://i.loli.net/2020/09/26/9ZCbHyKspqD3OXk.gif" alt="alfred-web-search.gif"></p><p>只需要点击右下角的 <code>Add Custom Search</code> 按钮，即可添加你经常搜索的网站的快捷方式：</p><p><img src="https://gitee.com/michael_xiang/images/raw/master/uPic/ad01wm.png" alt="网站搜索"></p><p>日常网站：</p><ul><li>百度：<code>https://www.baidu.com/s?ie=utf-8&amp;f=8&amp;wd={query}</code></li><li>淘宝：<code>https://s.taobao.com/search?q={query}</code></li><li>豆瓣电影：<code>http://movie.douban.com/subject_search?search_text={query}&amp;cat=1002</code></li><li>B 站：<code>http://search.bilibili.com/all?keyword={query}</code></li><li>知乎：<code>https://www.zhihu.com/search?type=content&amp;q={query}</code></li><li>什么值得买：<code>https://search.smzdm.com/?s={query}&amp;v=b</code></li></ul><p>技术网站：</p><ul><li>DuckDuckGo：<code>https://duckduckgo.com/?q={query}</code></li><li>Stackoverflow：<code>http://www.stackoverflow.com/search?q={query}</code></li><li>Github Search：<code>https://github.com/search?utf8=%E2%9C%93&amp;q={query}</code></li><li>MDN：<code>https://developer.mozilla.org/zh-CN/search?q={query}</code></li></ul><h3 id="Web-Bookmarks"><a href="#Web-Bookmarks" class="headerlink" title="Web Bookmarks"></a>Web Bookmarks</h3><p>又是一个非常赞的功能！虽然我浏览器中已经安装了插键可以快速搜索我的书签，但是 Alfred 的作用就是，当浏览器没有打开、你正在做其他工作时想要快速打开你浏览器中的某个书签，这时候你只需要快速启动 Alfred-&gt;搜索书签的关键字-&gt;Enter 打开该书签。又是一气呵成的操作！</p><p><img src="https://i.loli.net/2020/09/26/rZecT87wD6Nm1Hq.gif" alt="alfred-bookmarks-search.gif"></p><p>我设置了一个关键字 <code>bm</code>，寓意 <code>bookmarks</code>，用来表示我目的是搜索书签：</p><p><img src="https://gitee.com/michael_xiang/images/raw/master/uPic/33s1ZC.png" alt="bm"></p><blockquote><p>如果遇到权限问题，需要在系统偏好设置中<code>安全性与隐私-&gt;隐私-&gt;完全磁盘访问权限，勾选 Alfred 4.app</code>。接着在 Alfred 中输入 <code>Reload Alfred Cache</code> 后回车，Alfred 重新加载缓存就可以搜索书签</p></blockquote><h3 id="Clipboard-History-剪贴板历史"><a href="#Clipboard-History-剪贴板历史" class="headerlink" title="Clipboard History 剪贴板历史"></a>Clipboard History 剪贴板历史</h3><p>这个功能其实是我掏钱购买它的主要原因之一！在 Windows 上有 Ditto，但是在 Mac 上没有体验足够好的剪贴板历史工具。之前也使用了几个开源免费的剪贴板工具，但是他们有一些细节功能缺失，比如没法搜索剪贴板的历史。</p><p>有了 Alfred 的剪贴板增强，两个场景最常用：</p><ul><li>当你需要大段编辑文字、敲代码时，不需要反复在两个页面复制、切换页面、粘贴……只需要在一个页面将想要复制的内容复制好，然后切换页面，刚刚你复制的历史片段都可以看到，大大提高了文本编辑的效率！</li><li>当你需要快速找到某一天你复制过的片段时，只需要输入关键字在剪贴板历史中搜索即可~</li></ul><p><img src="https://ftp.bmp.ovh/imgs/2020/10/6951139ef4b30949.gif" alt></p><p>这里我把它们都设置为存储 1 个月，同时把打开剪贴板的默认快捷键为 <code>Command + Shift + V</code>：</p><p><img src="https://gitee.com/michael_xiang/images/raw/master/uPic/dMbZQX.png" alt="剪贴板设置"></p><ul><li><code>Clear Now</code>：表示立即清空剪贴板的历史</li></ul><h3 id="Snippets-文本片段"><a href="#Snippets-文本片段" class="headerlink" title="Snippets 文本片段"></a>Snippets 文本片段</h3><p>有一些文本是需要反复输入的，比如你的邮箱、QQ号、地址、手机号码、某个网址等信息，亦或者聊天常用语句、表情等等，这些都可以通过 Alfred 来管理，节省输入时间。</p><p><img src="https://gitee.com/michael_xiang/images/raw/master/uPic/i0SKPx.png" alt="Snippets"></p><blockquote><p>这个功能很强大，不止描述的那么简单。</p></blockquote><p>Alfred 官网 <a href="https://www.alfredapp.com/extras/snippets/" target="_blank" rel="noopener">Snippets</a> 提供了集合片段集合，下载后双击文件即可导入到 Alfred 中。</p><ul><li>Emoji Pack</li><li>Mac Symbols</li></ul><p>例如，我们有时候编辑文本时经常需要输入 Mac 上的一些按键符号⌘：</p><p><img src="https://i.loli.net/2020/10/03/ndU6wJa5zlIojXB.gif" alt="alfred-snippsets.gif"></p><h3 id="Calculator-计算器"><a href="#Calculator-计算器" class="headerlink" title="Calculator 计算器"></a>Calculator 计算器</h3><p>直接在输入框中输入计算的表达式，例如 <code>15*3</code>，Alfred 会自动计算出结果：</p><p><img src="https://gitee.com/michael_xiang/images/raw/master/uPic/Kzzbmw.png" alt="计算结果"></p><p>Advanced 增强计算的功能，支持一些高级计算的表达式，使用时以 <code>=</code> 开头，然后输入表达式即可，例如：<code>=sqrt(9)+abs(-2)</code>。</p><p>支持这些函数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sin, cos, tan, log, log2, ln, exp, abs, sqrt, asin, acos, atan, sinh, cosh, tanh, asinh, acosh, atanh, ceil, floor, round, trunc, rint, near, dtor, rtod等</span><br></pre></td></tr></table></figure><h3 id="Dictionary-字典"><a href="#Dictionary-字典" class="headerlink" title="Dictionary 字典"></a>Dictionary 字典</h3><p>输入 <code>define</code> 开头，然后输入查询的单词；</p><p><img src="https://gitee.com/michael_xiang/images/raw/master/uPic/C2pSvb.png" alt="define"></p><ul><li><code>Define a word</code>：可以自定义一个关键词来标记你要查询单词了，例如 <code>df</code>。</li></ul><h3 id="System-系统"><a href="#System-系统" class="headerlink" title="System 系统"></a>System 系统</h3><p>这个设置也很实用，通过在 Alfred 中输入一些命令来实现系统的操作，比如输入 <code>Empty Trash</code> 就是清空垃圾箱。不用担心记不住命令，因为 Alfred 是支持联想的。</p><p><img src="https://gitee.com/michael_xiang/images/raw/master/uPic/yJ71ij.png" alt="系统命令"></p><p>常用的有：</p><ul><li><code>emptytrash</code>：清空垃圾箱</li><li><code>lock</code>：锁定屏幕</li><li><code>slppe</code>：休眠</li><li><code>restart</code>：重启</li><li><code>shutdown</code>：关机</li><li><code>eject</code>：快速推出一些外界设备，比如 U 盘、挂载的镜像</li></ul><h3 id="Terminal-终端"><a href="#Terminal-终端" class="headerlink" title="Terminal 终端"></a>Terminal 终端</h3><p>可以直接在 Alfred 中输入 <code>&gt;</code> 之后，指定 shell 命令在 Terminal 中执行。</p><p><img src="https://gitee.com/michael_xiang/images/raw/master/uPic/3vvwm7.png" alt="Terminal"></p><p>操作示例：</p><p><img src="https://ftp.bmp.ovh/imgs/2020/10/6855e3274cfd9d1f.gif" alt="example"></p><p>默认情况是在 Mac 自带的 Terminal 中执行命令，如果你想在 Alfred 中执行，则需要通过如下命令自定义：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">on alfred_script(q)</span><br><span class="line">    tell application "iTerm"</span><br><span class="line">        set _length to count window</span><br><span class="line">    if _length = 0 then</span><br><span class="line">        create window with default profile</span><br><span class="line">    end if</span><br><span class="line">    set aa to (get miniaturized of current window)</span><br><span class="line">    if aa then</span><br><span class="line">        set miniaturized of current window to false</span><br><span class="line">    end if</span><br><span class="line">    set bb to (get visible of current window)</span><br><span class="line">    if bb is false then</span><br><span class="line">        set visible of current window to true</span><br><span class="line">    end if</span><br><span class="line">    set cc to frontmost</span><br><span class="line">    if cc is false then</span><br><span class="line">        activate</span><br><span class="line">    end if</span><br><span class="line">        (*if _length = 0 then*)</span><br><span class="line">            set theResult to current tab of current window</span><br><span class="line">        (*else</span><br><span class="line">            set theResult to (create tab with default profile) of current window</span><br><span class="line">        end if*)</span><br><span class="line">        write session of theResult text q</span><br><span class="line">end tell</span><br><span class="line">end alfred_script</span><br></pre></td></tr></table></figure><h3 id="Previews-预览"><a href="#Previews-预览" class="headerlink" title="Previews 预览"></a>Previews 预览</h3><p>Mac 预览功能也叫 <code>Quick Look</code>。当我们在 Finder 中选中一些文件之后，按住 <code>Space/空格键</code> 键，可以预览文件内容。Alfred 中这个预览功能叫 <code>Preview</code>。当我们在 Alfred 搜到一些文件之后，按一下 <code>Shift</code> 按键，就可以预览对应文件内容。同时，在 Finder 中，也可以通过 Alfred 提供的预览功能预览文件，对应快捷键是 <code>Command+y</code>。</p><p><img src="https://gitee.com/michael_xiang/images/raw/master/uPic/wvkfkB.png" alt="预览"></p><h2 id="workflow"><a href="#workflow" class="headerlink" title="workflow"></a>workflow</h2><h3 id="workflow-是什么"><a href="#workflow-是什么" class="headerlink" title="workflow 是什么"></a>workflow 是什么</h3><p><img src="https://gitee.com/michael_xiang/images/raw/master/uPic/TYaQGU.png" alt="workflow"></p><p>上面截图是 Alfred 官网对 Workflow 的一个描述，简单描述就是，workflow 是一个类似工作流的功能，它可以根据你预设的流程进行一系列的操作来帮你实现一个功能。</p><h3 id="日用推荐"><a href="#日用推荐" class="headerlink" title="日用推荐"></a>日用推荐</h3><p><a href="http://www.packal.org/workflow/numtocny" target="_blank" rel="noopener">NumToCNY</a>：转换数字为人民币金额，<code>cny</code> 然后输入数字即可</p><p><img src="https://gitee.com/michael_xiang/images/raw/master/uPic/72kvgD.png" alt="数字转人民币"></p><p><a href="https://github.com/whyliam/whyliam.workflows.youdao" target="_blank" rel="noopener">YoudaoDict</a> 有道翻译</p><p><img src="https://gitee.com/michael_xiang/images/raw/master/uPic/irarxg.png" alt="有道翻译"></p><p><a href="https://github.com/mpco/AlfredWorkflow-Recent-Documents/blob/master/README_CN.md" target="_blank" rel="noopener">mpco/AlfredWorkflow-Recent-Documents</a> 快速打开最近访问的文档、文件夹、应用</p><ul><li>输入 rr，列出当前激活应用的最近文档</li><li>输入 rf，列出最近访问的文件夹</li><li>输入 rd，列出最近打开的各种文件</li><li>输入 ra，列出最近打开的应用</li></ul><h3 id="开发推荐"><a href="#开发推荐" class="headerlink" title="开发推荐"></a>开发推荐</h3><p><a href="https://github.com/zenorocha/alfred-workflows/blob/master/ip-address/ip-address.alfredworkflow" target="_blank" rel="noopener">ip address</a>：查看本机 IP</p><p><img src="https://gitee.com/michael_xiang/images/raw/master/uPic/ptmUFi.png" alt="IP"></p><p><a href="https://github.com/ilstar/http_status_code" target="_blank" rel="noopener">http_status_code</a>：显示 HTTP 状态码含义</p><ul><li>输入 <code>httpcode + 状态码</code>，按下 Enter 键会跳到对应网站</li></ul><p><img src="https://gitee.com/michael_xiang/images/raw/master/uPic/a7jRch.png" alt="httpcode"></p><p><a href="https://githb.com/willfarrell/alfred-encode-decode-workflow" target="_blank" rel="noopener">encode</a> 字符编码（encode）、解码（decode），例如有时候一些密码、URL 中有特殊字符则可以使用它</p><p><img src="https://gitee.com/michael_xiang/images/raw/master/uPic/eXkrrY.png" alt="encode"></p><h3 id="下载源"><a href="#下载源" class="headerlink" title="下载源"></a>下载源</h3><ul><li>Alfred官宣/workflows：<a href="https://www.alfredapp.com/workflows/" target="_blank" rel="noopener">https://www.alfredapp.com/workflows/</a></li><li>alfredworkflow：<a href="http://www.alfredworkflow.com/" target="_blank" rel="noopener">http://www.alfredworkflow.com/</a></li><li>packal/workflow-list：<a href="http://www.packal.org/workflow-list" target="_blank" rel="noopener">http://www.packal.org/workflow-list</a></li><li>zenorocha/alfred-workflows：<a href="https://github.com/zenorocha/alfred-workflows" target="_blank" rel="noopener">https://github.com/zenorocha/alfred-workflows</a></li><li>github/awesome-alfred-workflows：<a href="https://github.com/alfred-workflows/awesome-alfred-workflows" target="_blank" rel="noopener">https://github.com/alfred-workflows/awesome-alfred-workflows</a></li></ul><blockquote><p>由于网络原因，workflow 可能下载比较慢，麦哥已经将本文提到的一些 workflow 文件打包好了，公众号后台回复 「Alfred」即可获取相关的安装文件。</p></blockquote><p><img src="https://gitee.com/michael_xiang/images/raw/master/uPic/公众号-二维码-截图.png" alt="公众号"></p><h2 id="Usage-使用统计"><a href="#Usage-使用统计" class="headerlink" title="Usage 使用统计"></a>Usage 使用统计</h2><p><img src="https://gitee.com/michael_xiang/images/raw/master/uPic/LYoIRO.png" alt="Usage"></p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://sspai.com/post/43973" target="_blank" rel="noopener">总是在 Mac 「装机必备」看到的搜索利器 Alfred，究竟是怎么用的？| 新手问号</a></li><li><a href="https://hufangyun.com/2018/alfred-workflow-recommend/" target="_blank" rel="noopener">效率神器 Alfred workflow 插件推荐</a></li><li><a href="http://louiszhai.github.io/2018/05/31/alfred/#%E5%A6%82%E4%BD%95%E5%AE%89%E8%A3%85alfred" target="_blank" rel="noopener">Alfred神器使用手册</a></li><li><a href="https://juejin.im/post/5b0e99436fb9a009e405dbb6" target="_blank" rel="noopener">掘金-Mac 提升开发效率的小工具</a></li><li><a href="https://ihtcboy.com/2020/02/09/2020-02-09_%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84macOS%E7%B3%BB%E5%88%97%EF%BC%9A%E9%AB%98%E6%95%88Alfred%E8%BF%9B%E9%98%B6/" target="_blank" rel="noopener">iHTCboy/程序员的macOS系列：高效Alfred进阶</a> 博主总结很详细，推荐</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://gitee.com/michael_xiang/images/raw/master/uPic/w3dQKD.png&quot; alt=&quot;Alfred&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://www.alfredapp.com/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;alfred&lt;/a&gt; 这款软件称为「神器」真是当之无愧。今天专门总结一下，作为之前 &lt;a href=&quot;https://michael728.github.io/2019/04/14/tools-dev-mac/&quot;&gt;Mac 配置教程-开发篇&lt;/a&gt; 的补充。&lt;/p&gt;
    
    </summary>
    
      <category term="ToolsDev" scheme="https://michael728.github.io/categories/ToolsDev/"/>
    
    
      <category term="Tools" scheme="https://michael728.github.io/tags/Tools/"/>
    
      <category term="Mac" scheme="https://michael728.github.io/tags/Mac/"/>
    
  </entry>
  
  <entry>
    <title>Elasticsearch 集群中节点角色的介绍</title>
    <link href="https://michael728.github.io/2020/09/20/elk-es-node-cluster/"/>
    <id>https://michael728.github.io/2020/09/20/elk-es-node-cluster/</id>
    <published>2020-09-20T15:10:57.000Z</published>
    <updated>2021-02-12T13:27:05.285Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Node"><a href="#Node" class="headerlink" title="Node"></a>Node</h2><p><strong>默认情况</strong>，一个节点 <a href="https://www.elastic.co/guide/en/elasticsearch/reference/7.3/modules-node.html#voting-only-node" target="_blank" rel="noopener">Node</a> 包含下面所有的角色：<code>master-eligible, data, ingest, and machine learning (if available)</code>。</p><table><thead><tr><th>节点类型</th><th>配置参数</th><th>默认值</th></tr></thead><tbody><tr><td>master eligible</td><td>node.master</td><td>true</td></tr><tr><td>data</td><td>node.data</td><td>true</td></tr><tr><td>ingest</td><td>node.ingest</td><td>true</td></tr><tr><td>coodrinating only</td><td>无</td><td>设置上面三个参数全部为 false</td></tr><tr><td>machine learning</td><td>node.ml</td><td>true (需要 enable x-pack)</td></tr></tbody></table><div class="note info">            <p>随着群集的增长，尤其是如果您有大量机器学习工作，需要考虑将具有主机资格（<code>master-eligible</code>）的节点专用，将它与专用数据的节点（<code>data nodes</code>）和专用机器学习的节点（<code>machine learning nodes</code>）分开。</p><p>我理解，这里的专用（<code>dedicated</code>）一词就是表示，将一个节点的角色不要设置那么多，主节点资格的节点就是用于当主节点，而不是同时设置数据节点的角色！</p>          </div><p>本文 ES 是 7.3.0 版本，查看官方文档，发现 ES 7.9.0 的配置和它是有点区别的。</p><h2 id="master-eligible-node"><a href="#master-eligible-node" class="headerlink" title="master-eligible node"></a>master-eligible node</h2><p><code>master-eligible node</code>：默认值就是 <code>true</code>。具有该角色的节点表示它有资格被选举为 <code>mater node</code>。备注：<code>eligible</code> 一词表示符合条件的含义。</p><p>主节点负责维护集群的状态，集群范围内的轻量级操作，例如：</p><ul><li>创建或删除索引，</li><li>跟踪哪些节点是集群的一部分</li><li>确定将哪些分片分配给哪些节点。</li></ul><p><strong>拥有稳定的主节点对于群集健康非常重要。</strong></p><p>在<a href="https://www.elastic.co/guide/en/elasticsearch/reference/7.3/modules-discovery.html" target="_blank" rel="noopener">主节点选举过程中</a>，任何一个非 <code>voting-only</code> 的 <code>master-eligible</code> 节点都可能被选为主节点。</p><blockquote><p>很好理解，如果已经是「仅是选举」用途的节点，它怎么能称为主节点呢？</p></blockquote><p>索引和搜索数据是占用大量CPU，内存和 I/O 的工作，这可能给节点的资源带来压力。为了确保主节点稳定且不受压力，在较大的群集中，最好将符合角色的专用主节点和专用数据节点分开。</p><p>尽管主节点还可以充当协调节点（<code>coordinating nodes</code>），将搜索和索引请求从客户端路由到数据节点，但最好不要为此目的使用专用的主节点。对于符合主节点要求的节点，其工作量应尽可能少，这对于群集的稳定性很重要。</p><div class="note warning">            <p>概括来讲就是，主节点的机器不要身兼数职，不要给主节点配置其他节点角色，以免影响主节点的稳定性！</p>          </div><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 可选为主节点（默认是 true）</span></span><br><span class="line"><span class="string">node.master:</span> <span class="literal">true</span></span><br><span class="line"><span class="comment"># voting_only 角色不启用（默认也是 false） </span></span><br><span class="line"><span class="string">node.voting_only:</span> <span class="literal">false</span></span><br><span class="line"><span class="comment"># data 角色不启用 （默认是 true） </span></span><br><span class="line"><span class="string">node.data:</span> <span class="literal">false</span> </span><br><span class="line"><span class="comment"># inges 角色不启用（默认是 true）</span></span><br><span class="line"><span class="string">node.ingest:</span> <span class="literal">false</span> </span><br><span class="line"><span class="comment"># ml 角色不启用（默认是 true）</span></span><br><span class="line"><span class="string">node.ml:</span> <span class="literal">false</span> </span><br><span class="line"><span class="comment"># xpack.ml.enabled 默认是启用的</span></span><br><span class="line"><span class="string">xpack.ml.enabled:</span> <span class="literal">true</span> </span><br><span class="line"><span class="comment"># 默认是 true</span></span><br><span class="line"><span class="string">cluster.remote.connect:</span> <span class="literal">false</span></span><br></pre></td></tr></table></figure><blockquote><p>xpack 功能时付费功能，因此，一般情况下，可以忽略 xpack 的设置。</p></blockquote><h2 id="Voting-only-master-eligible-node"><a href="#Voting-only-master-eligible-node" class="headerlink" title="Voting-only master-eligible node"></a>Voting-only master-eligible node</h2><p>一个具有 <code>voting-only</code> <code>master-eligible</code> 两种角色的节点，它是参与主节点的选举但不会充当主节点的节点。特别指出，<code>voting-only</code> 可以在选举中为决胜局服务。</p><p>要配置一个具有主机资格的节点为 <code>voting-only</code> 节点，需要如下配置</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 默认是 false</span></span><br><span class="line"><span class="string">node.voting_only:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure><div class="note warning">            <p>注意：OSS-only 分布式版本不支持 voting-only 角色。<strong>只有 master-eligible 的节点才能标记为 voting-only 角色！这里虽然有点难理解，但是由于历史原因造成的。</strong></p>          </div><p><strong>一个高可用的集群（HA —— High Avaliablity clusters）至少需要 3 个 <code>master-eligible</code> 角色的节点、至少 2 个不是 <code>voting-only</code> 节点。这样的集群将能够在一个主节点故障时选出一个主节点。</strong></p><p>一个具有 <code>voting-only</code> <code>master-eligible</code> 两种角色的节点同样也可以赋予其他的角色。例如，一个节点可以同时赋予 <code>voting-only</code> <code>master-eligible</code> <code>data</code> 3 种角色。专用于 <code>voting-only</code> <code>master-eligible</code> 的节点配置如下：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">node.master:</span> <span class="literal">true</span></span><br><span class="line"><span class="comment"># 默认不启用，需要设置为 false </span></span><br><span class="line"><span class="string">node.voting_only:</span> <span class="literal">true</span> </span><br><span class="line"><span class="string">node.data:</span> <span class="literal">false</span> </span><br><span class="line"><span class="string">node.ingest:</span> <span class="literal">false</span> </span><br><span class="line"><span class="string">node.ml:</span> <span class="literal">false</span> </span><br><span class="line"><span class="string">xpack.ml.enabled:</span> <span class="literal">true</span> </span><br><span class="line"><span class="string">cluster.remote.connect:</span> <span class="literal">false</span></span><br></pre></td></tr></table></figure><h2 id="Data-Node"><a href="#Data-Node" class="headerlink" title="Data Node"></a>Data Node</h2><p>数据节点包含包含您已建立索引的文档的分片。数据节点处理与数据相关的操作，例如：</p><ul><li>CRUD，</li><li>搜索和聚合。</li></ul><p>这些操作是 I/O，内存和 CPU 密集型的。<strong>监视这些资源并在过载时添加更多数据节点非常重要。</strong></p><p>具有专用数据节点的主要好处是将主节点角色和数据节点角色分开。 参考如下配置：<br><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 默认是 true</span></span><br><span class="line"><span class="string">node.master:</span> <span class="literal">false</span> </span><br><span class="line"><span class="comment"># 默认是 false</span></span><br><span class="line"><span class="string">node.voting_only:</span> <span class="literal">false</span> </span><br><span class="line"><span class="comment"># 默认是 true</span></span><br><span class="line"><span class="string">node.data:</span> <span class="literal">true</span> </span><br><span class="line"><span class="comment"># 默认是 true</span></span><br><span class="line"><span class="string">node.ingest:</span> <span class="literal">false</span> </span><br><span class="line"><span class="comment"># 默认是 true</span></span><br><span class="line"><span class="string">node.ml:</span> <span class="literal">false</span> </span><br><span class="line"><span class="comment"># 默认是 true</span></span><br><span class="line"><span class="string">cluster.remote.connect:</span> <span class="literal">false</span></span><br></pre></td></tr></table></figure></p><h2 id="Ingest-Node"><a href="#Ingest-Node" class="headerlink" title="Ingest Node"></a>Ingest Node</h2><p>接收节点（<code>Ingest nodes</code>）可以执行由一个或多个接收处理器组成的预处理管道。根据摄取处理器执行的操作类型和所需的资源，拥有专用的摄取节点可能会很有意义，这些节点仅会执行此特定任务。</p><blockquote><p>Ingest 节点也称为预处理节点。</p></blockquote><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">node.master:</span> <span class="literal">false</span> </span><br><span class="line"><span class="string">node.voting_only:</span> <span class="literal">false</span> </span><br><span class="line"><span class="string">node.data:</span> <span class="literal">false</span> </span><br><span class="line"><span class="string">node.ingest:</span> <span class="literal">true</span> </span><br><span class="line"><span class="string">node.ml:</span> <span class="literal">false</span> </span><br><span class="line"><span class="string">cluster.remote.connect:</span> <span class="literal">false</span></span><br></pre></td></tr></table></figure><h2 id="Coordinating-only-nodes"><a href="#Coordinating-only-nodes" class="headerlink" title="Coordinating only nodes"></a>Coordinating only nodes</h2><p>如果您不具备处理主节点职责、保存数据和预处理文档的能力，那么你就剩下一个仅可路由请求的协调节点角色（<code>coordinating only nodes</code>），处理搜索缩减阶段、分配批量索引的。本质上，coordinating only nodes 可充当智能负载平衡器。</p><blockquote><p>仅协调节点也称为负载均衡节点或 Client 节点</p></blockquote><div class="note warning">            <p>在集群中添加过多的仅协调节点可能会增加整个集群的负担，因为选择的主节点必须等待每个节点的集群状态更新确认！仅协调节点的好处不应被夸大 —— 数据节点可以很好地达到相同的目的。</p>          </div><p>为了创建一个仅协调节点（coordinating only node），可以如下配置：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">node.master:</span> <span class="literal">false</span> </span><br><span class="line"><span class="string">node.voting_only:</span> <span class="literal">false</span> </span><br><span class="line"><span class="string">node.data:</span> <span class="literal">false</span> </span><br><span class="line"><span class="string">node.ingest:</span> <span class="literal">false</span> </span><br><span class="line"><span class="string">node.ml:</span> <span class="literal">false</span> </span><br><span class="line"><span class="string">cluster.remote.connect:</span> <span class="literal">false</span></span><br></pre></td></tr></table></figure><h2 id="单一职责节点"><a href="#单一职责节点" class="headerlink" title="单一职责节点"></a>单一职责节点</h2><p>一个节点只承担一个角色，总结图：</p><p><img src="https://gitee.com/michael_xiang/images/raw/master/uPic/dt7Hon.png" alt="单一职责"></p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://www.elastic.co/guide/en/elasticsearch/reference/7.3/modules-node.html#coordinating-node" target="_blank" rel="noopener">官宣-Elasticsearch Reference [7.3] » Modules » Node</a></li><li><a href="https://learnku.com/articles/40718" target="_blank" rel="noopener">learnku-笔记五十二：集常见的集群部署方式</a></li><li><a href="https://elasticsearch.cn/question/8487" target="_blank" rel="noopener">Elasticsearch集群规划求助</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Node&quot;&gt;&lt;a href=&quot;#Node&quot; class=&quot;headerlink&quot; title=&quot;Node&quot;&gt;&lt;/a&gt;Node&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;默认情况&lt;/strong&gt;，一个节点 &lt;a href=&quot;https://www.elastic.co/gui
      
    
    </summary>
    
      <category term="ELK" scheme="https://michael728.github.io/categories/ELK/"/>
    
    
      <category term="ELK" scheme="https://michael728.github.io/tags/ELK/"/>
    
      <category term="ES" scheme="https://michael728.github.io/tags/ES/"/>
    
  </entry>
  
  <entry>
    <title>Java 定时任务框架 Quartz 入门篇</title>
    <link href="https://michael728.github.io/2020/09/06/java-middleware-quartz-basic/"/>
    <id>https://michael728.github.io/2020/09/06/java-middleware-quartz-basic/</id>
    <published>2020-09-06T12:49:10.000Z</published>
    <updated>2021-02-12T13:27:05.289Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Quartz-概念"><a href="#Quartz-概念" class="headerlink" title="Quartz 概念"></a>Quartz 概念</h2><p>Quartz 是任务调度的开源项目。Quartz 就是基于 Java 实现的任务调度框架。</p><ul><li>Quartz 官网地址：<a href="http://www.quartz-scheduler.org" target="_blank" rel="noopener">http://www.quartz-scheduler.org</a></li><li>Quartz 官网 - Examples：<a href="http://www.quartz-scheduler.org/documentation/quartz-2.3.0/tutorials/" target="_blank" rel="noopener">http://www.quartz-scheduler.org/documentation/quartz-2.3.0/tutorials/</a></li></ul><h2 id="Quartz-运行环境"><a href="#Quartz-运行环境" class="headerlink" title="Quartz 运行环境"></a>Quartz 运行环境</h2><ul><li>Quartz 可以运行嵌入在两一个独立式应用程序</li><li>Quartz 可以在应用程序服务器（或 Sevelet 容器） 内被实例化，并参与事务</li><li>Quartz 可以作为独立的程序运行（其自己的 Java 虚拟机内），可以通过 RMI 使用</li><li>Quartz 可以被实例化，作为独立的项目集群（负载平衡和故障转移功能），用于作业的执行</li></ul><h2 id="Quartz-设计模式"><a href="#Quartz-设计模式" class="headerlink" title="Quartz 设计模式"></a>Quartz 设计模式</h2><ul><li>Buider 模式</li><li>Factory 模式</li><li>组件模式</li><li>链式编程</li></ul><blockquote><p>这里说的设计模式，其实主要是针对 Quartz 使用过程中涉及的一些有用法。比如，通过 Factory 模式，生成调度器。比如，使用 Quartz 涉及了调度器、Job、触发器等组件。比如可通过 Build 方法创建出组件。</p></blockquote><h2 id="Quartz-核心概念"><a href="#Quartz-核心概念" class="headerlink" title="Quartz 核心概念"></a>Quartz 核心概念</h2><h3 id="任务-Job-和-JobDetail"><a href="#任务-Job-和-JobDetail" class="headerlink" title="任务 Job 和 JobDetail"></a>任务 Job 和 JobDetail</h3><p>Job 指的是你想要执行的任务类，每一个 Job 必须实现 <code>org.quartz.job</code> 接口，且只需要实现接口定义的 <code>execute()</code> 方法。在 <code>execute</code> 方法内编写任务的业务逻辑。</p><p>Job 实例在 Quartz 中的生命周期：每次调度器执行 Job 时，它在调用 <code>execute</code> 方法前会创建一个新的 Job 实例，当调用完成之后，关联的 Job 对象实例会被释放，释放的实例会被垃圾回收机制回收。</p><p>JobDetail: JobDetail 为 Job 实例提供许多设置属性，以及 jobDataMap 成员变量属性，它用来存储特定 Job 实例的状态信息，调度器需要借助 JobDetail 对象来添加 Job 实例。</p><h3 id="触发器-Trigger"><a href="#触发器-Trigger" class="headerlink" title="触发器 Trigger"></a>触发器 Trigger</h3><p>Trigger 为你执行任务的触发器，比如你想每天定时 3 点发送一份统计邮件，Trigger 将会设置 3 点进行执行该任务。</p><p>Trigger 主要包含两种：</p><ul><li><code>SimpleTrigger</code></li><li><code>CronTrigger</code></li></ul><h3 id="调度器-Scheduler"><a href="#调度器-Scheduler" class="headerlink" title="调度器 Scheduler"></a>调度器 Scheduler</h3><p>Scheduler 为任务的调度器，它将任务 Job 及 触发器 Trigger 整合起来，负责基于 Trigger 设定的时间来执行 Job。</p><h2 id="Quartz-的体系结构"><a href="#Quartz-的体系结构" class="headerlink" title="Quartz 的体系结构"></a>Quartz 的体系结构</h2><p><img src="https://gitee.com/michael_xiang/images/raw/master/uPic/cpbdMt.png" alt="cpbdMt"></p><h2 id="Quartz-几个常用-API"><a href="#Quartz-几个常用-API" class="headerlink" title="Quartz 几个常用 API"></a>Quartz 几个常用 API</h2><p>以下是 Quartz 编程 API 几个重要接口，也是 Quartz 的重要组件。</p><ul><li>Scheduler 用于与调度程序交互的主程序接口</li></ul><p>Scheduler 调度程序-任务执行计划表，只有安排进执行计划的任务 Job（通过 schduler.scheduleJob 方法安排进执行计划），当它预先定义的执行时间到了（任务触发器 trigger），该任务才会执行。</p><ul><li>Job 我们预先定义的希望在未来时间能够被调度程序执行的任务类，我们可以自定义。</li><li>JobDetail 使用 jobDetail 来定义定时任务的实例，jobDetail 实例是通过 JobBuilder 类创建的。</li><li>JobDataMap 可以包含不限量的（序列化）的数据对象，在 job 实例执行的时候，可以使用其中的数据。JobDataMap 是 Java Map 接口的一个实现，额外增加了一些便于存取基本类型的数据方法。</li><li>Trigger 触发器，Trigger 对象是用来触发执行 Job 的。当调度一个 Job 时，我们实例触发器然后调整它的属性来满足 Job 执行的条件。表明任务在什么时候会执行。定义了一个已经被安排的任务将会在什么时候执行的时间条件，比如每 2 秒执行一次。</li><li>JobBuilder 用于声明一个任务实例，也可以定义关于该任务的详情，比如任务名、组名等。这个声明的实例将会作为一个实际执行的任务。</li><li>TriggerBuilder 触发器创造器，用于创建触发器 trigger 实例。</li><li>JobListener、TriggerListener、SchedulerListener 监听器，用于对组件的监听。</li></ul><blockquote><p>注意 Job 和 JobDetail 的区分，Job 是指我们具体的「任务类」。JobDetail 指通过 JobBuilder 类创建出的一个实例，它和 Job 类进行了绑定。</p></blockquote><p>贴一个官网示例片段：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// define the job and tie it to our HelloJob class</span></span><br><span class="line">JobDetail job = newJob(HelloJob.class)</span><br><span class="line">    .withIdentity(<span class="string">"job1"</span>, <span class="string">"group1"</span>)</span><br><span class="line">    .build();</span><br><span class="line"></span><br><span class="line"><span class="comment">// Trigger the job to run now, and then repeat every 40 seconds</span></span><br><span class="line">Trigger trigger = newTrigger()</span><br><span class="line">    .withIdentity(<span class="string">"trigger1"</span>, <span class="string">"group1"</span>)</span><br><span class="line">    .startNow()</span><br><span class="line">          .withSchedule(simpleSchedule()</span><br><span class="line">            .withIntervalInSeconds(<span class="number">40</span>)</span><br><span class="line">            .repeatForever())</span><br><span class="line">    .build();</span><br><span class="line"></span><br><span class="line"><span class="comment">// Tell quartz to schedule the job using our trigger</span></span><br><span class="line">scheduler.scheduleJob(job, trigger);</span><br></pre></td></tr></table></figure><h2 id="入门案例"><a href="#入门案例" class="headerlink" title="入门案例"></a>入门案例</h2><h3 id="引入-Maven-依赖"><a href="#引入-Maven-依赖" class="headerlink" title="引入 Maven 依赖"></a>引入 Maven 依赖</h3><p>在 <a href="https://mvnrepository.com" target="_blank" rel="noopener">https://mvnrepository.com</a> 官网搜索 quartz，选择了最新版本 <a href="https://mvnrepository.com/artifact/org.quartz-scheduler/quartz/2.3.2" target="_blank" rel="noopener">2.3.2</a></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 核心包 --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- https://mvnrepository.com/artifact/org.quartz-scheduler/quartz --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.quartz-scheduler<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>quartz<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.3.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 工具包 --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- https://mvnrepository.com/artifact/org.quartz-scheduler/quartz-jobs --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.quartz-scheduler<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>quartz-jobs<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.3.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure><p>说明：核心依赖是 <code>quartz</code>，而 <code>quartz-jobs</code> 是一个可选依赖，它主要放置了一些 quartz 的工具代码、一些预定义的 job。</p><h3 id="任务类"><a href="#任务类" class="headerlink" title="任务类"></a>任务类</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">QuartzHelloJob</span> <span class="keyword">implements</span> <span class="title">Job</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(JobExecutionContext jobExecutionContext)</span> <span class="keyword">throws</span> JobExecutionException </span>&#123;</span><br><span class="line">        <span class="comment">// 当前时间</span></span><br><span class="line">        Date date = <span class="keyword">new</span> Date();</span><br><span class="line">        DateFormat dateFormat = <span class="keyword">new</span> SimpleDateFormat(<span class="string">"yyyy-MM-dd:HH:mm:ss"</span>);</span><br><span class="line">        String dateStr = dateFormat.format(date);</span><br><span class="line">        <span class="comment">// 工作内容</span></span><br><span class="line">        System.out.println(<span class="string">"正在进行数据备份任务的定时执行，执行时间："</span> + dateStr);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="主类"><a href="#主类" class="headerlink" title="主类"></a>主类</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">QuartzHelloScheduler</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 1. 调度器 Schduler，从工厂中获取调度器实例</span></span><br><span class="line">        Scheduler stdScheduler = StdSchedulerFactory.getDefaultScheduler();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. 任务实例 JobDetail</span></span><br><span class="line">        <span class="comment">// 参数 1：任务的名称；参数 2：任务组的名称</span></span><br><span class="line">        JobDetail jobDetail = JobBuilder.newJob(QuartzHelloJob.class)</span><br><span class="line">                .withIdentity(<span class="string">"job1"</span>, <span class="string">"jobGroup1"</span>)</span><br><span class="line">                .build();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3. 触发器 Trigger</span></span><br><span class="line">        <span class="comment">// 参数 1：触发器的名称；参数 2：触发器组的名称</span></span><br><span class="line">        Trigger trigger = TriggerBuilder.newTrigger()</span><br><span class="line">                .withIdentity(<span class="string">"trigger1"</span>, <span class="string">"triggerGroup1"</span>)</span><br><span class="line">                .withSchedule(SimpleScheduleBuilder.simpleSchedule().repeatSecondlyForever(<span class="number">5</span>))</span><br><span class="line">                .startNow()</span><br><span class="line">                .build();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4. 通过调度器将触发器与任务实例关联，保证按照触发器定义的条件执行任务</span></span><br><span class="line">        stdScheduler.scheduleJob(jobDetail, trigger);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 5. 启动</span></span><br><span class="line">        stdScheduler.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行主类，结果如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">正在进行数据备份任务的定时执行，执行时间：2020-09-06:17:45:56</span><br><span class="line">正在进行数据备份任务的定时执行，执行时间：2020-09-06:17:46:01</span><br><span class="line">正在进行数据备份任务的定时执行，执行时间：2020-09-06:17:46:06</span><br><span class="line">正在进行数据备份任务的定时执行，执行时间：2020-09-06:17:46:11</span><br></pre></td></tr></table></figure><p>可以看到控制台果然每隔 5 秒就会有输出内容。</p><h2 id="概念扩展"><a href="#概念扩展" class="headerlink" title="概念扩展"></a>概念扩展</h2><p>上面介绍过一些核心概念，还有一些概念也比较重要。</p><h3 id="JobExecutionContext-介绍"><a href="#JobExecutionContext-介绍" class="headerlink" title="JobExecutionContext 介绍"></a>JobExecutionContext 介绍</h3><p>当 Scheduler 调用一个 Job 时，会将 <code>JobExecutionContext</code> 传递给 Job 的 <code>execute()</code> 方法。<strong>Job 能通过 <code>JobExecutionContext</code> 对象访问到 Quartz 运行时的环境以及 Job 本身的详细数据。</strong></p><h3 id="JobDataMap-介绍"><a href="#JobDataMap-介绍" class="headerlink" title="JobDataMap 介绍"></a>JobDataMap 介绍</h3><ul><li>在进行任务调度时，JobDataMap 存储在 JobExecutionContext 中，非常方便获取；</li><li>JobDataMap 可以用来装载任何可序列化的数据对象，当 Job 实例对象执行时，这些参数对象会传递给它；</li><li>JobDataMap 实现了 JDK 的 Map 接口，并且添加了非常方便的方法用来存取基本数据类型；</li></ul><p>主类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 2. 任务实例 JobDetail</span></span><br><span class="line"><span class="comment">// 参数 1：任务的名称；参数 2：任务组的名称</span></span><br><span class="line">JobDetail jobDetail = JobBuilder.newJob(QuartzHelloJob.class)</span><br><span class="line">        .withIdentity(<span class="string">"job1"</span>, <span class="string">"jobGroup1"</span>)</span><br><span class="line">        .usingJobData(<span class="string">"message"</span>, <span class="string">"job message"</span>) <span class="comment">// 传参</span></span><br><span class="line">        .build();</span><br></pre></td></tr></table></figure><p>Job 实现类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// JobDataMap 传值</span></span><br><span class="line">JobDataMap jobDataMap1 = jobExecutionContext.getJobDetail().getJobDataMap();</span><br><span class="line">System.out.println(<span class="string">"任务数据的参数值："</span> + jobDataMap1.get(<span class="string">"message"</span>));</span><br></pre></td></tr></table></figure><p>还有一个用法，在 Job 实现类中添加 <code>setter</code> 方法对应 JobDataMap 的键，Quartz 框架默认的 jobFactory 实现类在初始化 Job 实例对象时会自动地调用这些 <code>setter</code> 方法。这样的好处是，你可以在 Job 实现类中方便地使用成员变量，而不用像上面那种方式去取值。</p><div class="note warning no-icon">            <p>注意点：如果遇到同名的 key，Trigger 中的 key 对应的值会覆盖 JobDetail 中的值。</p>          </div><h3 id="有状态-Job-和无状态的-Job"><a href="#有状态-Job-和无状态的-Job" class="headerlink" title="有状态 Job 和无状态的 Job"></a>有状态 Job 和无状态的 Job</h3><ul><li>有状态 Job 可以理解为，多次 Job 调用期间可以持有一些状态信息，这些状态信息存储在 JobDataMap 中。</li><li>默认的无状态的 Job 每次调用时都会创建一个新的 JobDataMap。</li></ul><p><code>@PersisJobDataAfterExecution</code> 注解的使用在 Job 任务类上，多次 Job 实例被调用期间，可以持有一些状态信息，比如可以实现 count 的累加。</p><h2 id="Trigger-介绍"><a href="#Trigger-介绍" class="headerlink" title="Trigger 介绍"></a>Trigger 介绍</h2><p>Quartz 有一些不同的触发器类型，使用最多的是 <code>SimpleTrigger</code> 和 <code>CronTrigger</code></p><ul><li>jobKey：表示 job 实例的标识，触发器被触发时，该指定的 job 实例被执行（也就是说，除了通过 JobDetail 获取到 job 实例的内容，Trigger 对象也提供了方法获取）；</li><li>startTime：表示触发器的时间表，第一次开始被触发的时间，数据类型是 <code>java.util.Date</code>；</li><li>endTime：表示触发器终止被触发的时间，数据类型也是 <code>java.util.Date</code>；</li></ul><h3 id="SimpleTrigger-触发器"><a href="#SimpleTrigger-触发器" class="headerlink" title="SimpleTrigger 触发器"></a>SimpleTrigger 触发器</h3><p>5 秒重复执行，只执行 3 次，设置结束时间：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Trigger trigger = TriggerBuilder.newTrigger()</span><br><span class="line">        .withIdentity(<span class="string">"trigger1"</span>, <span class="string">"triggerGroup1"</span>)</span><br><span class="line">        .withSchedule(SimpleScheduleBuilder.simpleSchedule()</span><br><span class="line">                .repeatSecondlyForever(<span class="number">5</span>)</span><br><span class="line">                .withRepeatCount(<span class="number">2</span>))</span><br><span class="line">        .usingJobData(<span class="string">"message"</span>, <span class="string">"simple 触发器"</span>)</span><br><span class="line">        .startNow()</span><br><span class="line">        .endAt(endDate)</span><br><span class="line">        .build();</span><br></pre></td></tr></table></figure></p><ul><li>SimpleTrigger 属性有开始时间、结束时间、重复次数和重复时间间隔等</li><li>重复次数的属性值从 0 开始计数</li><li>重复时间间隔属性值必须是长整型的正整数</li><li>如果指定了结束时间属性值，那么，结束时间属性权重优于重复次数属性</li></ul><h3 id="CronTrigger-触发器"><a href="#CronTrigger-触发器" class="headerlink" title="CronTrigger 触发器"></a>CronTrigger 触发器</h3><p>CronTriggers 通常比 SimpleTrigger 更有用，因为它是基于日历的作业触发器。使用 CronTrigger，你可以指定诸如“每周五中午”或者“每个工作日的 9:30”这样的日程来触发 Job 执行。像 SimpleTrigger 一样，CronTrigger 也有一个 startTime 以指定日程从什么时候开始，也有一个（可选） endTime 以指定何时日程不再继续。</p><h4 id="Cron-Expressions-——-Cron-表达式"><a href="#Cron-Expressions-——-Cron-表达式" class="headerlink" title="Cron Expressions —— Cron 表达式"></a>Cron Expressions —— Cron 表达式</h4><p>Cron 表达式被用来配置 <code>CronTrigger</code> 实例。Cron 表达式是一个由 7 个表达式组成的字符串。每个子表达式描述一个单独的日程细节。这些表达式用空格分隔：</p><ol><li>Seconds 秒</li><li>Minutes 分</li><li>Hours 小时</li><li>Day-Of-Month 月中的天，日</li><li>Month 月</li><li>Day-Of-Week 周中的天，周几</li><li>Year 年（可选）</li></ol><table><thead><tr><th>字段</th><th>是否必填</th><th>允许值</th><th>可以出现的运算符</th></tr></thead><tbody><tr><td>秒</td><td>必填</td><td>0 - 59</td><td>/    *    ,   -</td></tr><tr><td>分</td><td>必填</td><td>0 - 59</td><td>/    *    ,   -</td></tr><tr><td>时</td><td>必填</td><td>0 - 23</td><td>/    *    ,   -</td></tr><tr><td>月中的天</td><td>必填</td><td>1 - 31</td><td>/    *    ,   -    ?  L    W    C</td></tr><tr><td>月</td><td>必填</td><td>1 - 12， 也可以用JAN这些缩写</td><td>/    *    ,   -</td></tr><tr><td>星期中的天</td><td>必填</td><td>1 - 7 或者 SUN-SAT，7是星期六， 可以用 WED 这些缩写</td><td>/    *    ,   -     ?  L    C    #</td></tr><tr><td>年份</td><td>非必填</td><td>1970   -   2099</td><td>/    *    ,   -</td></tr></tbody></table><blockquote><p>1 表示周日</p></blockquote><p>运算符的含义：</p><table><thead><tr><th>运算符</th><th>含义</th></tr></thead><tbody><tr><td>*</td><td>表示这个字段的每一个值， 可以出现在所有字段中。 如”<em> </em> <em> </em> <em> ？</em>”表示每一秒钟。</td></tr><tr><td>/</td><td>表示值的增量，从一个值开始，<strong>每间隔</strong>多少时间后再次执行，可以出现在所有的字段。如在分钟字段上， 0/15表示从0分开始， 间隔15分钟执行一次， 相当于0,15,30,45</td></tr><tr><td>,</td><td>表示多个值， 可以出现在所有的字段。 如周一周三周五可表示为MON,WED,FRI。</td></tr><tr><td>-</td><td>表示一个区间。如周一到周三可表示为MON-WED。</td></tr><tr><td>?</td><td>表示放弃这个字段设置， 可以出现在月中的天和周中的天这两个字段。如”<em> </em> <em> </em> <em> ？</em>”表示每一秒钟。</td></tr><tr><td>L</td><td>L是 Last 的缩写， 可以出现在月中的天和周中的天这两个字段, 当时含义不一样。 在月中的天这个字段中， L表示这个月的最后一天。 而在周中的天中， 如果L单独出现， 那么就表示7或者SAT即星期六， 如果出现在一个数字的后面， 那么就表示这个月的周几， 如“6L”, 表示这个月的最后一个周五</td></tr><tr><td>W</td><td>W是 week 的缩写， 可以出现在月中的天这个字段， 可以用来指定距离这个时间最近的周几， 周的天在Day of Week字段中指定。</td></tr><tr><td>#</td><td>表示这个月的第几个星期，可以出现在周中的天这个字段。 如 <code>1#3</code> 或 <code>SUN#3</code>， 表示这个月的第 3 个星期日。</td></tr></tbody></table><blockquote><p>月中的天和周中的天<strong>互斥</strong>，只能出现一个问号，例如，不能保证每周二都是 1 号！</p></blockquote><div class="note success no-icon">            <ul><li><code>/</code> 这个符号还是挺常用的，比如在秒的位置，如果你直接 5，那么，就表示第 5 秒执行，但是如果是 <code>0/5</code> 则表示从 0 秒开始，每隔 5 秒！注意不要搞错！</li><li><code>L</code>  和 <code>W</code> 可以一起使用，比如每隔月最后一个周五结算工资</li><li>周字段的英文字母缩写不区分大小写，例如 <code>MON</code> 等价于 <code>mon</code></li><li>在线 Cron 表达式生成器：<a href="https://www.matools.com/cron" target="_blank" rel="noopener">https://www.matools.com/cron</a></li></ul>          </div><p>Cron 表达式示例：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">"0 0 10,14,16  * * ?" 每天 10 点、14 点、16 点执行</span><br><span class="line">"0 0/30 9-17 * * ?" 每天 9-17 点，每隔 30 分钟执行一次</span><br><span class="line">"0 0 12 ? * WED" 每周三的 12 点执行</span><br><span class="line">"0 15 10 L * ?" 每月的最后一天的 10 点 15 分执行</span><br><span class="line">"0 15 10 ? * 6#3" 每月的第三个周五 10 点 15 分执行</span><br></pre></td></tr></table></figure></p><h4 id="CronTrigger-示例"><a href="#CronTrigger-示例" class="headerlink" title="CronTrigger 示例"></a>CronTrigger 示例</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">JobDetail jobDetail = JobBuilder.newJob(QuartzHelloJob.class)</span><br><span class="line">        .withIdentity(<span class="string">"job1"</span>, <span class="string">"jobGroup1"</span>)</span><br><span class="line">        .usingJobData(<span class="string">"message"</span>, <span class="string">"job message"</span>)</span><br><span class="line">        .usingJobData(<span class="string">"param"</span>, <span class="string">"setter 传参"</span>)</span><br><span class="line">        .usingJobData(<span class="string">"count"</span>, <span class="number">1</span>)</span><br><span class="line">        .build();</span><br></pre></td></tr></table></figure><h2 id="SchedulerFactory"><a href="#SchedulerFactory" class="headerlink" title="SchedulerFactory"></a>SchedulerFactory</h2><ul><li>对于 Job 来说，Trigger 就类似于驱动器，没有触发器来定时驱动作业 Job，Job 就无法运行；</li><li>对于 Job 而言，一个 Job 可以对应多个 Trigger；</li><li>对于 Trigger 而言，一个 Trigger 只能对应一个 Job；</li></ul><blockquote><p>Trigger 和 Job 因此就是「多对一」的关系</p></blockquote><p>Scheduler 的创建方式：<br>（1） StdSchdulerFactory：Quartz 默认的 SchdulerFactory</p><ul><li>使用一组参数（<code>java.util.Properties</code>）来创建和初始化 Quartz 调度器；</li><li>配置参数一般存储在 <code>quartz.properties</code> 文件中；</li><li>调用 <code>getScheduler</code> 方法就能创建和初始化调度器；</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">StdSchedulerFactory stdSchedulerFactory = <span class="keyword">new</span> StdSchedulerFactory();</span><br><span class="line">Scheduler stdScheduler = stdSchedulerFactory.getScheduler();</span><br><span class="line"><span class="comment">// 等价于</span></span><br><span class="line">Scheduler stdScheduler = StdSchedulerFactory.getDefaultScheduler();</span><br></pre></td></tr></table></figure><h3 id="将任务和触发器关联"><a href="#将任务和触发器关联" class="headerlink" title="将任务和触发器关联"></a>将任务和触发器关联</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">stdScheduler.scheduleJob(jobDetail, trigger);</span><br></pre></td></tr></table></figure><h3 id="其他用法"><a href="#其他用法" class="headerlink" title="其他用法"></a>其他用法</h3><ul><li>启动任务调度 <code>stdScheduler.start();</code></li><li>调度挂起，即暂停（暂停后，需要再次调用 <code>start()</code> 方法才能启动）: <code>stdSchduler.standby();</code></li><li>调度关闭（关闭之后，重新启动也不行）：<code>stdSchduler.shutdown();</code></li></ul><blockquote><p>shutdown() 方法可以传入一个布尔值，<code>boolean waitForJobsToComplete</code>，用于表示是否等待 Job 执行完毕再结束！ture 表示等待所有正在执行的 Job 执行完毕之后，再关闭 Scheduler。false 表示直接关闭 Scheduler。</p></blockquote><h2 id="quartz-properties-配置"><a href="#quartz-properties-配置" class="headerlink" title="quartz.properties 配置"></a>quartz.properties 配置</h2><p>在项目中搜索该文件，可以在依赖的 Quartz 包下看到默认的配置文件：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"># Default Properties file for use by StdSchedulerFactory</span><br><span class="line"># to create a Quartz Scheduler Instance, if a different</span><br><span class="line"># properties file is not explicitly specified.</span><br><span class="line">#</span><br><span class="line"># 调度器属性</span><br><span class="line">## instanceName 用来区分特定调度器实例，可以按照功能用途来给调度器起名</span><br><span class="line">org.quartz.scheduler.instanceName: DefaultQuartzScheduler</span><br><span class="line">org.quartz.scheduler.rmi.export: false</span><br><span class="line">org.quartz.scheduler.rmi.proxy: false</span><br><span class="line">org.quartz.scheduler.wrapJobExecutionInUserTransaction: false</span><br><span class="line"></span><br><span class="line"># 线程池属性</span><br><span class="line">org.quartz.threadPool.class: org.quartz.simpl.SimpleThreadPool</span><br><span class="line">## 处理 Job 的线程数，至少为 1，并不是越大越好</span><br><span class="line">org.quartz.threadPool.threadCount: 10</span><br><span class="line">## 线程的优先级，优先级别高的线程比级别低的线程优先得到执行。最小为 1，最大为 10，默认 5</span><br><span class="line">org.quartz.threadPool.threadPriority: 5</span><br><span class="line">org.quartz.threadPool.threadsInheritContextClassLoaderOfInitializingThread: true</span><br><span class="line"></span><br><span class="line"># 作业存储设置</span><br><span class="line">org.quartz.jobStore.misfireThreshold: 60000</span><br><span class="line"></span><br><span class="line">org.quartz.jobStore.class: org.quartz.simpl.RAMJobStore</span><br></pre></td></tr></table></figure></p><p>扩充：</p><ul><li><code>org.quartz.scheduler.instanceId: AUTO</code>  这个值必须所有调度器实例中唯一，作为集群的唯一 key。</li><li><code>org.quartz.spi.ThreadPool.class</code> 一个实现了 <code>org.quartz.spi.ThreadPool</code> 接口的类，Quartz 自带的线程池实现类是 <code>org.quartz.smpl.SimpleThreadPool</code></li></ul><p>如果想自定义配置，那么只需要拷贝上面内容放在项目的 <code>resources</code> 目录下即可。也可以通过编写程序代码操作 <code>quartz.properties</code> 文件的内容：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// 通过代码方式配置 quartz</span><br><span class="line">Properties properties = new Properties();</span><br><span class="line">// 可以用工厂类中的常量</span><br><span class="line">properties.put(StdSchedulerFactory.PROP_THREAD_POOL_CLASS, &quot;org.quartz.simpl.SimpleThreadPool&quot;);</span><br><span class="line">properties.put(&quot;org.quartz.threadPool.threadCount&quot;, &quot;10&quot;);</span><br><span class="line"></span><br><span class="line">// 1. 调度器 Schduler，从工厂中获取调度器实例</span><br><span class="line">StdSchedulerFactory stdSchedulerFactory = new StdSchedulerFactory();</span><br><span class="line">stdSchedulerFactory.initialize(properties);</span><br><span class="line">Scheduler stdScheduler = stdSchedulerFactory.getScheduler();</span><br></pre></td></tr></table></figure><blockquote><p>通过 Properties 设置工厂属性的缺点在用硬编码，例如需要修改线程数量，将不得不修改代码，然后又重新编译。因此，不推荐使用。还是使用 <code>quartz.properties</code> 的配置方式方便。</p></blockquote><h2 id="Quartz-监听器"><a href="#Quartz-监听器" class="headerlink" title="Quartz 监听器"></a>Quartz 监听器</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>Quartz 监听器用于当任务调度你所关注的事件发生时，能够及时获取这一事件的通知。</p><p>Quartz 监听器主要有 <code>JobListener</code>、<code>TriggerListener</code>、<code>SchedulerListener</code> 三种。先明确两个概念：全局监听器与非全局监听器。二者区别在于：</p><ul><li>全局监听器能够接收到所有的 Job/Trigger 的事件通知</li><li>非全局监听器只能接收到在其上注册的 Job 或 Trigger 事件，不在其上注册的 Job 或 Trigger 则不会进行监听。 </li></ul><p>监听器的用法步骤大致如下：</p><ul><li>新建一个类，实现监听器接口 <code>xxxListener</code>；</li><li>通过监听管理器创建并注册监听器</li></ul><h3 id="JobListener"><a href="#JobListener" class="headerlink" title="JobListener"></a>JobListener</h3><p>任务调度过程中，与任务 Job 相关事件包括：</p><ul><li>Job 开始要执行的提示；</li><li>Job 执行完成的提示；</li></ul><p>JobListener 接口包含几个重要的方法声明：</p><ul><li><code>getName</code>：用于获取 JobListener 的名称；</li><li><code>jobToBeExecuted</code> 方法：Scheduler 在 JobDetail 将要被执行时调用该方法；</li><li><code>jobExecutedVetoed</code> 方法：Scheduler 在 JobDetail 即将被执行，但又被 TriggerListener 否决时调用该方法；</li><li><code>jobWasExecuted</code> 方法：Scheduler 在 JobDetail 被执行之后调用该方法；</li></ul><h3 id="TriggerListener"><a href="#TriggerListener" class="headerlink" title="TriggerListener"></a>TriggerListener</h3><p>TriggerListener 包含几个方法：</p><ul><li><code>getName</code>：获取触发器的名称</li><li><code>triggerFired</code> 方法：当与监听器相关联的 Trigger 被触发，Job 上的 <code>execute()</code> 方法将被执行时，Scheduler 就调用该方法；</li><li><code>vetoJobExecution</code> 方法：在 Trigger 触发后，Job 将要被执行时由 Scheduler 调用这个方法。TriggerListener 给了一个选择去否决 Job 的执行。假如这个方法返回 true，这个 Job 将不会被此次 Trigger 触发而得到执行；</li><li><code>triggerMisfired</code> 方法：Scheduler 调用这个方法是在 Trigger 错过触发时。</li><li><code>triggerComplete</code> 方法：Trigger 被触发并且完成了 Job 的执行时，Scheduler 调用这个方法；</li></ul><h3 id="SchedulerListener"><a href="#SchedulerListener" class="headerlink" title="SchedulerListener"></a>SchedulerListener</h3><p>SchedulerListener 会在 Scheduler 的生命周期中关键事件发生时被调用。与 Scheduler 有关的时间包括：</p><ul><li>增加一个 Job/Trigger</li><li>删除一个 Job/Trigger</li><li>Scheduler 发生错误</li><li>关闭 Scheduler 等</li></ul><h2 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h2><p>完整示例代码：<a href="https://github.com/Michael728/java-middleware-demos/tree/master/quartz-demos" target="_blank" rel="noopener">https://github.com/Michael728/java-middleware-demos/tree/master/quartz-demos</a></p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://www.bilibili.com/video/BV1St411g72Z?p=5" target="_blank" rel="noopener">B 站/任务调度 Quartz 视频教程全集（21P）| 3 小时从入门到精通</a></li><li><a href="https://www.cnblogs.com/zhanghaoliang/p/7886110.html" target="_blank" rel="noopener">博客园/Quartz的基本使用之入门（2.3.0版本）</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Quartz-概念&quot;&gt;&lt;a href=&quot;#Quartz-概念&quot; class=&quot;headerlink&quot; title=&quot;Quartz 概念&quot;&gt;&lt;/a&gt;Quartz 概念&lt;/h2&gt;&lt;p&gt;Quartz 是任务调度的开源项目。Quartz 就是基于 Java 实现的任务调度
      
    
    </summary>
    
      <category term="Java" scheme="https://michael728.github.io/categories/Java/"/>
    
    
      <category term="Java" scheme="https://michael728.github.io/tags/Java/"/>
    
      <category term="定时任务" scheme="https://michael728.github.io/tags/%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1/"/>
    
      <category term="Quartz" scheme="https://michael728.github.io/tags/Quartz/"/>
    
  </entry>
  
  <entry>
    <title>IT程序员的装修笔记——家电选购之冰箱篇</title>
    <link href="https://michael728.github.io/2020/08/21/life-shopping-applicances-fridge/"/>
    <id>https://michael728.github.io/2020/08/21/life-shopping-applicances-fridge/</id>
    <published>2020-08-21T21:29:08.000Z</published>
    <updated>2021-02-12T13:27:05.289Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://gitee.com/michael_xiang/images/raw/master/uPic/frog-1729802_640.jpg" alt="frog-ice-fridge"></p><h2 id="冰箱"><a href="#冰箱" class="headerlink" title="冰箱"></a>冰箱</h2><p>冰箱可谓是现代家庭必不可少的一件电器，最近花时间了解了一下现在冰箱的常见卖点功能。这里总结分享出来，方便其他有需要的同学作参考。重点不是推荐具体型号的冰箱，而是方便大家选购适合自己需求的产品~</p><blockquote><p>不了解不知道，一了解吓一跳。小时候电视剧里出现的高大上的对开门大冰箱，如今二三千也可以入手！</p></blockquote><a id="more"></a><h2 id="箱门形式"><a href="#箱门形式" class="headerlink" title="箱门形式"></a>箱门形式</h2><p>按照冰箱门类型设计进行划分：</p><ul><li><p>双门冰箱：一般上冷藏，下冷冻，通常无变温室<br><img src="https://gitee.com/michael_xiang/images/raw/master/uPic/cF8LH7.png" alt="双门-图源自网络"></p></li><li><p>三门冰箱：比双门冰箱多了一个中间的变温室，可以调节不同温度使用<br><img src="https://gitee.com/michael_xiang/images/raw/master/uPic/TGy1lp.png" alt="双门-图源自网络"></p></li><li><p>对开门冰箱：体积大、性价比高，缺少变温室<br><img src="https://gitee.com/michael_xiang/images/raw/master/uPic/AeGl35.png" alt="双门-图源自网络"></p></li><li><p>十字对开门冰箱：对开门冰箱的进阶版，分区更为合理，一般也有独立变温室<br><img src="https://gitee.com/michael_xiang/images/raw/master/uPic/msG1fr.png" alt="双门-图源自网络"></p></li><li><p>多门冰箱：有时也称法式多门，一般 4 门起<br><img src="https://gitee.com/michael_xiang/images/raw/master/uPic/5MgKIb.png" alt="双门-图源自网络"></p></li></ul><blockquote><p>假设倾向大容量冰箱，食材管理比较精细化的可以选择多门和十字对开门，粗放式的同学可以选择对开门</p></blockquote><p>变温空间就是指有一块空间，你可以独立指定它的温度模式，适配存储鲜肉、冰镇啤酒、干燥坚果。</p><h2 id="容量"><a href="#容量" class="headerlink" title="容量"></a>容量</h2><p>在空间允许的前提下，建议参考 <code>100~150L/人</code> 的标准，结合家庭食材购买频率，确定容积需求。</p><blockquote><p>正常家庭 250~500L 即可, 500L 以上适合多口之家。毕竟食物还是新鲜的好，没必要囤积太多食品。</p></blockquote><h2 id="放置"><a href="#放置" class="headerlink" title="放置"></a>放置</h2><p>冰箱会要求上、左、右都要留有一定的间隙用于散热，在保证箱门正常开启的前提下，两侧各预留 5cm 左右即可。</p><h2 id="制冷模式"><a href="#制冷模式" class="headerlink" title="制冷模式"></a>制冷模式</h2><ul><li>直冷：通过蒸发器直接直冷，对于蔬果保鲜有利，但是易结冰</li><li>风冷：蒸发器增加风机，有自动除霜效果，现在主流技术，也就是常看见的「风冷无霜」宣传语</li><li>混冷：冷藏直冷（防止蔬果风干）、冷冻风冷（无霜）。高端冰箱会采用，因为其结构稍复杂、成本较高</li></ul><h2 id="压缩机"><a href="#压缩机" class="headerlink" title="压缩机"></a>压缩机</h2><p>美芝、加西贝拉、恩布拉科、扎努西、华意等品牌</p><p>当我在京东咨询客服试图了解一款冰箱的具体压缩机型号时，下面是客服给我的答复：</p><blockquote><p>因根据产品批次不同，选配的压缩机不同，多品牌更利于确保供货，所以具体品牌查询不到哦~</p></blockquote><p>看京东经常也会有核心部件、质保十年的赠品，因此压缩机这块应该不用太在意。</p><p><img src="https://gitee.com/michael_xiang/images/raw/master/uPic/a2SKg6.png" alt="质保"></p><h2 id="循环模式"><a href="#循环模式" class="headerlink" title="循环模式"></a>循环模式</h2><ul><li>单循环，就是一个蒸发器，冷风在冰箱里冷藏变温冷冻转一圈再回去。</li><li>双循环，则是两个蒸发器，冷藏和冷冻分别冷风循环，制冷更快，也缓解了串味问题。常常带有「双系统制冷」描述字眼。</li><li>多循环：常见于三开门或多门冰箱，除了冷藏和冷冻各有蒸发器之外，零度区可能也也有单独调节温度。</li></ul><blockquote><p>确认是不是双系统，得向客服咨询！！！因为从描述很难判断，双循环≠双系统！小心被坑~</p></blockquote><p>单循环只有一套制冷系统，即一个蒸发器，制冷剂的流向<code>压缩机-冷凝器-过滤器-毛细管-蒸发器-压机</code>。冷藏室与冷冻室不可单独控制，任何一个间室的制冷都会让另一个间室被迫制冷。</p><p>双系统制冷的优点：</p><ul><li>食材不串味</li><li>控温更精确，不同于单循环的“牵一发而动全身”</li></ul><h2 id="品牌"><a href="#品牌" class="headerlink" title="品牌"></a>品牌</h2><ul><li>欧美：博士、西门子</li><li>日系：松下、东芝</li><li>国产：海尔、美的、海信、容声、美菱</li></ul><blockquote><p>海信、容声目前是一家了，博士西门子合称博西，因为西门子家用电器业务据说被博士收购了</p></blockquote><h2 id="价格记录"><a href="#价格记录" class="headerlink" title="价格记录"></a>价格记录</h2><blockquote><p>此处不是推荐！仅是做一个价格记录的快照，方便日后对比！</p></blockquote><table><thead><tr><th>品牌</th><th>型号</th><th>容量</th><th>长宽高/mm</th><th>上市时间</th><th>价格</th><th>好评度</th><th>质保</th><th>能效（度/天）</th><th>款式</th><th>特点</th></tr></thead><tbody><tr><td>海尔</td><td><a href="https://item.jd.com/100012645766.html" target="_blank" rel="noopener">BCD-545WFPB</a> 单系统</td><td>545L</td><td><code>648*908*1905</code></td><td>2020-4</td><td>4499（20200816）</td><td>99%</td><td>赠品赠送 10 年核心部件质保</td><td>1 级（0.93）</td><td>十字对开门</td><td>变温箱（母婴模式、零度模式、珍品模式）、90°悬停门</td></tr><tr><td>美的</td><td><a href="https://item.jd.com/100012751424.html" target="_blank" rel="noopener">BCD-503WSPZM(E)</a> 双系统</td><td>503L</td><td><code>648*833*1898</code></td><td>202006</td><td>5749（20200816）</td><td>99%</td><td>赠品赠送 10 年核心部件质保</td><td>1 级（0.89）</td><td>十字对开门</td><td>母婴保鲜智能、不容易留指纹、果润保鲜</td></tr></tbody></table><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文的目的不是推荐冰箱，而是梳理选购冰箱时涉及到的一些基本概念，有助于帮助大家选择到合适的产品！有些功能不是必选，而是可选。抛开预算、推荐产品就是耍流氓，根据自己的需要、选择适合自己的才是理智的行为！</p><h2 id="一言"><a href="#一言" class="headerlink" title="一言"></a>一言</h2><p>在和京东客服咨询时，发现国产品牌的客服都很热心，周末都提供在线咨询服务到深夜！国产家电的质量和国外品牌的差距并没那么大，有时候没必要盲从，同样的功能，因为品牌溢价，你可能就要多付很多智商税~</p><p>2020 魔幻的一年，国外的月亮不一定就更圆，国货加油！</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://mp.weixin.qq.com/s/o6QqwYP-BnrRGWDq1c4Txg" target="_blank" rel="noopener">一兜糖家居APP/拜托，挑冰箱真没那么难！</a></li><li><a href="https://post.smzdm.com/p/a078pm9r/p2/#comments" target="_blank" rel="noopener">什么值得买/装修系列专题｜2020年冰箱选购推荐（6.29更新）</a></li><li><a href="https://zhuanlan.zhihu.com/p/28035403" target="_blank" rel="noopener">知乎/出木衫同学/家电选购终极指南——冰箱篇</a></li><li><a href="https://www.haier.com/guang/guide/20181219_126271.shtml" target="_blank" rel="noopener">海尔官网/冰箱双循环制冷，食材新鲜不串味</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://gitee.com/michael_xiang/images/raw/master/uPic/frog-1729802_640.jpg&quot; alt=&quot;frog-ice-fridge&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;冰箱&quot;&gt;&lt;a href=&quot;#冰箱&quot; class=&quot;headerlink&quot; title=&quot;冰箱&quot;&gt;&lt;/a&gt;冰箱&lt;/h2&gt;&lt;p&gt;冰箱可谓是现代家庭必不可少的一件电器，最近花时间了解了一下现在冰箱的常见卖点功能。这里总结分享出来，方便其他有需要的同学作参考。重点不是推荐具体型号的冰箱，而是方便大家选购适合自己需求的产品~&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;不了解不知道，一了解吓一跳。小时候电视剧里出现的高大上的对开门大冰箱，如今二三千也可以入手！&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="Life" scheme="https://michael728.github.io/categories/Life/"/>
    
    
      <category term="装修" scheme="https://michael728.github.io/tags/%E8%A3%85%E4%BF%AE/"/>
    
      <category term="购物" scheme="https://michael728.github.io/tags/%E8%B4%AD%E7%89%A9/"/>
    
      <category term="家电" scheme="https://michael728.github.io/tags/%E5%AE%B6%E7%94%B5/"/>
    
  </entry>
  
  <entry>
    <title>IT程序员的装修笔记——家电选购之冰箱篇</title>
    <link href="https://michael728.github.io/2020/08/21/life-shopping-network/"/>
    <id>https://michael728.github.io/2020/08/21/life-shopping-network/</id>
    <published>2020-08-21T21:29:08.000Z</published>
    <updated>2021-02-12T13:27:05.289Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><h3 id="5G-amp-2-4G"><a href="#5G-amp-2-4G" class="headerlink" title="5G &amp; 2.4G"></a>5G &amp; 2.4G</h3><p>wifi 路由器目前主要分为 2.4G 和 5G 两种频率的型号。5G 信号频率高、波长短，而 2.4G 信号频率低、波长长，所以 5G 信号穿过障碍物时衰减更大，穿墙能力比 2.4G 信号弱。那么5G信号有什么优点呢？5G 信号频宽较宽，无线环境比较干净，干扰少，网速稳定，且 5G 可以支持更高的无线速率。</p><blockquote><p>电磁波的物理特性：频率低，则波长越长，衰减越少，也更容易绕过障碍物继续传播。</p></blockquote><p>因此，如果能够配置全屋 WiFi，则理想情况是多覆盖 5G 信号。</p><h3 id="带宽与下载速率"><a href="#带宽与下载速率" class="headerlink" title="带宽与下载速率"></a>带宽与下载速率</h3><p>运营商通常给出的套餐中，经常会听到百兆宽带，但是我们实际使用时的下载速率却到不到百兆，这是为为什么呢？因为二者的单位不一致。</p><p>运营商的单位是 <code>Mbps</code>，下载速率的单位通常是 <code>MBps</code>。 1 Byte = 8 bit，即 1 字节 = 8 位。因此，100兆宽带大约最大的下载速率在 12.5兆/秒左右。</p><h3 id="网线"><a href="#网线" class="headerlink" title="网线"></a>网线</h3><ul><li>五类线（<code>Cat5</code>）的速度最高能达到 100Mb/s，频率能达到100Mhz，所以说五类线可以支持百兆以下的网</li><li>超五类线（<code>Cat5e</code>）的速度最高能达到 1Gb/s（1000Mb/s），频率也是 100Mhz，超五类线可以支持千兆以下的网。在一般的家庭中，传输距离有限，因此，超五类网线也够用了。</li><li>六类线（<code>Cat6</code>）的速度最高能达到 10Gb/s，频率是 250Mhz，六类线可以支持万兆网，主要用于万兆局域网等</li></ul><blockquote><p>需要注意网线水晶头接了几根芯，详情阅读 <a href="https://jingyan.baidu.com/article/cb5d6105aa8e40005d2fe04f.html" target="_blank" rel="noopener">网线的四芯接法以及八芯接法</a></p></blockquote><h3 id="POE"><a href="#POE" class="headerlink" title="POE"></a>POE</h3><p>POE(Power Over Ethernet)也被称为基于局域网的供电系统(POL, Power over LAN )或有源以太网( Active Ethernet)，有时也被简称为以太网供电，这是利用现存标准以太网传输电缆的同时传送数据和电功率的最新标准规范</p><blockquote><p>不需要为每个AP专门再拉一条电线供电，直接通过网线就可以实现供电，但是这边还有个注意点就是每个AP都是有额定功率的，所以在后期POE供电功率要大于等于所有AP的功率之和。</p></blockquote><h3 id="AC"><a href="#AC" class="headerlink" title="AC"></a>AC</h3><p>接入控制器（Access Controller或Wireless Access Point Controller），即无线控制器，是一种网络设备，负责管理某个区域内无线网络中的 AP</p><h3 id="AP"><a href="#AP" class="headerlink" title="AP"></a>AP</h3><p>无线访问接入点(WirelessAccessPoint)，即无线接入点，它用于无线网络的无线交换机，也是无线网络的核心。无线AP是移动计算机用户进入有线网络的接入点，主要用于宽带家庭、大楼内部以及园区内部，可以覆盖几十米至上百米。无线AP（又称会话点或存取桥接器）是一个包含很广的名称，它不仅包含单纯性无线接入点（无线AP），同样也是无线路由器（含无线网关、无线网桥）等类设备的统称。</p><h3 id="无线协议"><a href="#无线协议" class="headerlink" title="无线协议"></a>无线协议</h3><p>第一代的 <code>802.11</code> 演变到了 <code>802.11ax</code>。目前主流的 <code>802.11ac</code> 已经重新被命名为 <code>WiFi 5</code>，最新的 <code>802.11ax</code> 为<code>WiFi 6</code></p><h2 id="路由器"><a href="#路由器" class="headerlink" title="路由器"></a>路由器</h2><ol><li>路由器不能取代AC，要不就无法控制下面的AP,最重要的是没有POE的功能了，需要加POE的设备，多余；</li><li>如果是需要路由器的使用功能，如DDNS,挂硬盘，去广告等，建议把 AC 挂在路由器下面，路由器作为核心来拨号，AC 控制其他的WIFI,路由器的WIFI关闭（原因是路由器的WIFI在面积很大的基础上没有AP的范围广）</li><li>如果是需要路由器的网络信号，就直接找个合适的位置挂在 AC 下面即可，建议放客厅，但是部分功能就用不了了，因为这样配置路由器就相当于家里的一个AP面板。</li></ol><ul><li><a href="https://www.acwifi.net/category/mesh" target="_blank" rel="noopener">https://www.acwifi.net/category/mesh</a></li></ul><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://www.zhihu.com/question/342250054/answer/800691648" target="_blank" rel="noopener">知乎/家庭组网AP+AC，是否需要一个强力路由器？</a></li><li><a href="https://zhuanlan.zhihu.com/p/172097775" target="_blank" rel="noopener">知乎/小怪的装修笔记-设计篇五（无线网络方案 全屋wifi ap+ac）</a></li><li><a href="https://www.zhihu.com/question/20305170/answer/1132367453" target="_blank" rel="noopener">「五类网线」 和 「六类网线」 有什么区别?</a></li><li><a href="https://zhuanlan.zhihu.com/p/38911036" target="_blank" rel="noopener">四芯网线与八芯网线的区别</a></li><li><a href="https://jingyan.baidu.com/article/636f38bb4cb7f8d6b8461082.html" target="_blank" rel="noopener">四芯双绞线怎么接,四芯网线接法,4根网线如何接</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;概念&quot;&gt;&lt;a href=&quot;#概念&quot; class=&quot;headerlink&quot; title=&quot;概念&quot;&gt;&lt;/a&gt;概念&lt;/h2&gt;&lt;h3 id=&quot;5G-amp-2-4G&quot;&gt;&lt;a href=&quot;#5G-amp-2-4G&quot; class=&quot;headerlink&quot; title=&quot;5G 
      
    
    </summary>
    
      <category term="Life" scheme="https://michael728.github.io/categories/Life/"/>
    
    
      <category term="装修" scheme="https://michael728.github.io/tags/%E8%A3%85%E4%BF%AE/"/>
    
      <category term="购物" scheme="https://michael728.github.io/tags/%E8%B4%AD%E7%89%A9/"/>
    
      <category term="家电" scheme="https://michael728.github.io/tags/%E5%AE%B6%E7%94%B5/"/>
    
  </entry>
  
  <entry>
    <title>IT程序员的装修笔记——家电选购之电视机篇</title>
    <link href="https://michael728.github.io/2020/08/16/life-shopping-appliances-TV/"/>
    <id>https://michael728.github.io/2020/08/16/life-shopping-appliances-TV/</id>
    <published>2020-08-16T16:29:08.000Z</published>
    <updated>2021-02-12T13:27:05.289Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://gitee.com/michael_xiang/images/raw/master/uPic/wild-865296_640.jpg" alt="选自Pixabay"></p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>2018 年五月购买的房子，等了 2 年多多了，预计今年年底就要交付了。今天在家看看家电有关的内容，做好笔记。</p><a id="more"></a><h2 id="电视机"><a href="#电视机" class="headerlink" title="电视机"></a>电视机</h2><p>电视机的诉求就是画质好、用的久、接口齐全、与相关的设备兼容性好，比如和游戏主机的互联等。</p><h2 id="分辨率"><a href="#分辨率" class="headerlink" title="分辨率"></a>分辨率</h2><p>市面上很多假 4K，要注意分辨率要达到 <code>3840*2160</code> 或 <code>4096*2160</code></p><p>真 4K 是 RGB 三色面板，则为，假 4K 是 RGBW 四色面板。</p><h2 id="面板"><a href="#面板" class="headerlink" title="面板"></a>面板</h2><ul><li>VA 面板：对比度更好，适合观看影片电视剧</li><li>IPS 面板：可视度更好，看比赛、玩游戏</li></ul><h2 id="HDR"><a href="#HDR" class="headerlink" title="HDR"></a>HDR</h2><p>光影对比更加真实。一个画面中，亮的的地方可以亮，同时，暗的地方可以依然保持暗。</p><p>要明确是支持 HDR 解码还是支持 <strong>HDR 显示</strong>效果。</p><p>HDR电视标准：</p><ul><li>液晶电视屏幕峰值亮度 1000 Nit以上；</li><li>广色域，大于等于 90%DCI-P3色域；</li><li>支持动态区域背光控制；</li><li>杜比视界/HDR10/HLG至少支持一种；</li></ul><blockquote><p>市售低于5K的电视机支持的HDR自然只是HDR解码，并无太多实际意义</p></blockquote><h2 id="画质芯片"><a href="#画质芯片" class="headerlink" title="画质芯片"></a>画质芯片</h2><ul><li>索尼 X1</li><li>三星 8K 的 AI 芯片</li><li>LG 的 α9、α7</li><li>海信的 Hi-View Pro</li></ul><h2 id="色域"><a href="#色域" class="headerlink" title="色域"></a>色域</h2><p>色域又叫色彩空间，是衡量电视画质的重要标准之一。一般来说色域越广越好，广色域包含更多的色彩表现，能够更好的呈现视频的画质。</p><p>色域标准众多，常用的主要包括 NTSC、sRGB、BT.709、BT.2020 和 DCI-P3，不同标准覆盖的色域范围不同。考虑到NTSC标准相对通用，习惯性会将其他色域标准转化成 NTSC（考虑到不同色域之间并不能完全互相覆盖，这里的转换只是近似）。</p><ul><li>100% sRGB≈72% NTSC；</li><li>100% BT.709≈72% NTSC；</li><li>100% BT.2020≈150% NTSC；</li><li>100% DCI-P3≈96% NTSC。</li></ul><blockquote><p>关注厂商广告中色域标准采用的是哪个。100%色域。可能是采用的 <code>BT.709</code> 标准，它只是近似为72% NTSC标准的色域表现</p></blockquote><p>关键其实是色彩管理系统！这才是厂家核心技术的护城河~</p><h2 id="背光方式"><a href="#背光方式" class="headerlink" title="背光方式"></a>背光方式</h2><ul><li>直下式</li></ul><h2 id="运动补偿"><a href="#运动补偿" class="headerlink" title="运动补偿"></a>运动补偿</h2><p>运动补偿功能（多数厂家叫MEMC，SONY的叫Motion Flow）</p><h2 id="屏幕刷新率"><a href="#屏幕刷新率" class="headerlink" title="屏幕刷新率"></a>屏幕刷新率</h2><p>屏幕刷新率表示电视在一秒钟能刷新的图片数量。刷新率越高刷新的照片越多，电视画面就越流畅。目前大多数电视屏幕刷新率都是 60Hz，高端电视屏幕刷新率可以达到 120Hz。高刷新率配合 MEMC 技术，可以带来更加流畅的画面体验。</p><h2 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h2><ul><li>HDMI 1.4 = 10.2 Gbps</li><li>HDMI 2.0 = 18 Gbps</li></ul><p>如果没有上面这种接口，大概率无法播放 4K 片源</p><h2 id="蓝牙"><a href="#蓝牙" class="headerlink" title="蓝牙"></a>蓝牙</h2><p>智能电视蓝牙功能有用，搭配游戏手柄、蓝牙音箱使用十分方便，同时看电视无法外放声音的时候可以使用蓝牙耳机。</p><h2 id="视频格式"><a href="#视频格式" class="headerlink" title="视频格式"></a>视频格式</h2><ul><li>H.265+ 视频格式，为 4K 而生的编码格式</li></ul><h2 id="选购"><a href="#选购" class="headerlink" title="选购"></a>选购</h2><h3 id="索尼"><a href="#索尼" class="headerlink" title="索尼"></a>索尼</h3><p>索尼：</p><ul><li>OLED 有 A9、A8 两个系列；</li><li>液晶电视 9000 系列高端、8000 系列中端、7000 系列入门级；</li></ul><p>每个系列后面有字幕代表年份，比如 Z9G，G 代表 2019 年；F 表示去年机型;</p><p>关注型号：</p><ul><li>X9000H 65 寸，8000，202005 上市，安卓 9.0，二级能效，蓝牙耳机、4K HDR、4G16G、4 核、x1 芯片、2 个 USB 接口 2.0/3.0，HDMI 2.1 接口、耳机接口、可屏幕发声、特丽魅彩技术、精锐光控、杜比音效、线上线下同款，整机一年，主要部件三年，好评率 99%，<a href="https://www.sonystyle.com.cn/products/bravia/x9000h/kd_65x9000h.html" target="_blank" rel="noopener">官网参数</a></li></ul><blockquote><p>8000H 入门级 4K，刷新率 60HZ 的面板，扬声器也有区别；9500H 芯片是 X1 加强版，精锐光控增加强版、支持远程语音，9500 G 是 2019 年旗舰机型；</p></blockquote><h3 id="三星"><a href="#三星" class="headerlink" title="三星"></a>三星</h3><p>三星主打 QLED 量子点技术，色域很广</p><p>芯片：</p><ul><li>UA 系列，7 系以上，三星自研芯片；</li><li>5-7 系，芯片主频比较低</li><li>5 系以下，使用太长新芯片</li></ul><h3 id="海信"><a href="#海信" class="headerlink" title="海信"></a>海信</h3><ul><li>E 系列是线上型号，线下没有；</li><li>A 系列，线下款；</li><li>U 系列是 ULED 电视；</li><li>带 E 的型号，带远场语音；</li></ul><blockquote><p>选择海信电视，关注是否有 AI 画境芯片或者 ULED 量子点技术或者「信芯」芯片</p></blockquote><p>关注型号：</p><ul><li>E8D 5669 ULED/140%色域/3+ 32G/CPU A73✖️2核+A53✖️2核数/刷新率 60HZ/支持蓝牙耳机</li></ul><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://www.bilibili.com/video/BV1ub411M7Ni/?spm_id_from=333.788.videocard.3" target="_blank" rel="noopener">B站/知电晓春哥/液晶电视选择的坑你踩了几个？屏好不等于电视好，液晶电视选购必看</a> 提到了关注芯片、接口、视频格式等关键因素</li><li><a href="https://www.youtube.com/watch?v=SozJZIWcO5c" target="_blank" rel="noopener">科技狗/油管/【選購指南】2020年4K 電視怎麼選？</a> 更专业的评测，提供很多专业讲解</li><li><a href="https://post.smzdm.com/p/akm7rdw8/" target="_blank" rel="noopener">什么值得买/从参数到推荐：2020年电视机选购指南</a></li><li><a href="https://www.bilibili.com/video/av243373433/" target="_blank" rel="noopener">B站/索尼电视2020新品又挤牙膏？快去抢X9500G！SONY 85寸9500G评测 上集</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://gitee.com/michael_xiang/images/raw/master/uPic/wild-865296_640.jpg&quot; alt=&quot;选自Pixabay&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;2018 年五月购买的房子，等了 2 年多多了，预计今年年底就要交付了。今天在家看看家电有关的内容，做好笔记。&lt;/p&gt;
    
    </summary>
    
      <category term="Life" scheme="https://michael728.github.io/categories/Life/"/>
    
    
      <category term="装修" scheme="https://michael728.github.io/tags/%E8%A3%85%E4%BF%AE/"/>
    
      <category term="购物" scheme="https://michael728.github.io/tags/%E8%B4%AD%E7%89%A9/"/>
    
      <category term="家电" scheme="https://michael728.github.io/tags/%E5%AE%B6%E7%94%B5/"/>
    
  </entry>
  
  <entry>
    <title>Java 基础 —— 反射</title>
    <link href="https://michael728.github.io/2020/08/09/java-basic-class-reflect/"/>
    <id>https://michael728.github.io/2020/08/09/java-basic-class-reflect/</id>
    <published>2020-08-09T17:49:10.000Z</published>
    <updated>2021-02-12T13:27:05.289Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://gitee.com/michael_xiang/images/raw/master/uPic/looking-glass-918878_640.jpg" alt="远方"></p><h2 id="通过反射查看类信息"><a href="#通过反射查看类信息" class="headerlink" title="通过反射查看类信息"></a>通过反射查看类信息</h2><p>Java 程序中的许多对象在运行时会出现两种类型：编译时类型和运行时类型。例如：<code>Person p = new Student();</code>，代码会生成一个 p 变量，编译时类型是 Person，运行时类型为 Student。除此之外，有时程序在运行时接收到外部传入的一个编译类型为 Object，但程序又需要调用该对象运行时类型的方法。</p><a id="more"></a><p>未解决这些问题，程序需要运行时发现对象和类的真实信息。有下面两种做法：</p><ol><li>先试用 <code>instanceOf</code> 运算符进行判断，再利用强制类型转换将其转换成运行时类型的变量；</li><li>程序只依靠运行时信息来发现该对象和类的真实信息，这就必须使用「反射」；</li></ol><p>本文就主要是来介绍反射知识点的。</p><h3 id="获得-Class-对象"><a href="#获得-Class-对象" class="headerlink" title="获得 Class 对象"></a>获得 Class 对象</h3><p>之前<a href="https://michael728.github.io/2020/08/07/java-basic-class-load/">文章</a>已经介绍过类加载了，每个类被加载之后，系统会为该类生成一个对应的 Class 对象，通过该 Class 对象就可以访问 JVM 中的这个类。Java 程序中获得 Class 对象有如下三种方式：</p><ol><li>使用 Class 类的 <code>forName(String clazzName)</code> 静态方法。该方法需要传入字符串参数，该字符串参数的值是某个类的「全限定名」（必须是完成包名）。</li><li>调用某个类的 class 属性来获取该类对应的 Class 对象。例如 <code>Person.class</code> 将会返回 Person 类对应的 Class 对象。</li><li>调用某个实例对象的 <code>getClass()</code> 方法。该方法是 <code>java.lang.Object</code> 类中的方法，因此所有 Java 对象都可以调用该方法。</li></ol><p>方式 1 和方式 2 都是直接根据类来获得该类的 Class 对象。大部分时候，应该使用方式 2 来获取指定类的 Class 对象。因为方式 2 有如下优势：</p><ul><li>代码更安全。编译阶段就可以检查需要访问的 Class 对象是否存在；</li><li>程序性能更好。</li></ul><p>获取了 Class 对象之后可以进行的操作就多了，程序可以调用 Class 对象的方法来获得该对对象和对应类的真实信息了。</p><h3 id="从-Class-中获取信息"><a href="#从-Class-中获取信息" class="headerlink" title="从 Class 中获取信息"></a>从 Class 中获取信息</h3><p>Class 类提供了大量的<strong>实例方法</strong>来获取该 Class 对象所对应类的相关信息。下面的方法都可能提供了多个<strong>重载</strong>的版本。</p><h4 id="获取-Class-对象的对应类的构造器"><a href="#获取-Class-对象的对应类的构造器" class="headerlink" title="获取 Class 对象的对应类的构造器"></a>获取 Class 对象的对应类的构造器</h4><ul><li><code>Constructor&lt;T&gt; getConstructor(Class&lt;?&gt; ... parameterTypes)</code>：返回此 Class 对象对应类的、<strong>带指定形参列表</strong> 的 public 构造器；</li><li><code>Constructor&lt;T&gt;[] getConstructors()</code>：返回此 Class 对象对应类的<strong>所有 public</strong> 构造器；</li><li><code>Constructor&lt;T&gt; getDeclaredConstructor(Class&lt;?&gt; ... parameterTypes)</code>：返回此 Class 对象对应类的、<strong>带指定形参列表</strong> 的构造器，与构造器的访问权限无关！</li><li><code>Constructor&lt;T&gt;[] getDeclaredConstructors()</code>：返回此 Class 对象对应类的所有构造器，与构造器的访问权限无关！</li></ul><h4 id="获取-Class-对象的对应类所包含的方法"><a href="#获取-Class-对象的对应类所包含的方法" class="headerlink" title="获取 Class 对象的对应类所包含的方法"></a>获取 Class 对象的对应类所包含的方法</h4><ul><li><code>Method getMethod(String name, Class&lt;?&gt; ... parameterTypes)</code>：返回此 Class 对象对应类的、带指定形参列表的<strong> public 方法</strong></li><li><code>Method[] getMethods()</code>：返回此 Class 对象对应类的<strong>所有 public 方法</strong>；</li><li><code>Method getDeclaredMethod(String name, Class&lt;?&gt; ... parameterTypes)</code>：返回 Class 对象对应类的、带指定形参列表的方法，与方法的访问权限无关！</li><li><code>Method[] getDeclaredMethods()</code>：返回 Class 对象对应类的<strong>全部方法</strong>，与方法的访问权限无关！</li></ul><h4 id="获取-Class-对象的对应类所包含的成员变量"><a href="#获取-Class-对象的对应类所包含的成员变量" class="headerlink" title="获取 Class 对象的对应类所包含的成员变量"></a>获取 Class 对象的对应类所包含的成员变量</h4><ul><li><code>Field getField(String name)</code>：返回此 Class 对象对应类的、指定名称的<strong>public 成员变量</strong>；</li><li><code>Fields[] getFileds()</code>：返回此 Class 对象对应类的<strong>所有 public 成员变量</strong>；</li><li><code>Field getDeclaredField(String name)</code>：返回此 Class 对象对应类的、指定名称的成员变量，与成员变量的访问权限无关！</li><li><code>Fields[] getDeclaredFields()</code>：返回此 Class 对象对应类的全部成员变量，与成员变量的访问权限无关！</li></ul><p>还有很多其他的功能呢：</p><ul><li>访问 Class 对象对应类上所包含的 Annotation；</li><li>访问 Class 对象对应类包含的内部类（<code>Class&lt;?&gt;[] getDeclaredClasses()</code>）；</li><li>访问 Class 对象对应类的所在的外部类（<code>Class&lt;?&gt; getDeclaringClass()</code>）；</li><li>获取 Class 对象对应类的修饰符、所在包、类名等基本信息</li></ul><p>方法就不一一介绍了，详细可阅读 <a href="https://docs.oracle.com/javase/8/docs/api/java/lang/Class.html" target="_blank" rel="noopener">Java Class API</a>。</p><div class="note info no-icon">            <p>观察上面方法的描述，其实大体可以总结出来，带 <code>Declared</code> 字眼的方法呢，返回的内容就不受访问权限的控制！</p>          </div><h4 id="方法理解"><a href="#方法理解" class="headerlink" title="方法理解"></a>方法理解</h4><p>上面介绍了一群方法，怎么调用呢？传参是怎样的呢？看个栗子就明白了！</p><p>假设某个类包含如下三个 <code>info</code> 方法签名：</p><ul><li><code>public void info()</code></li><li><code>public void info(String str)</code></li><li><code>public void info(String str, Integer num)</code></li></ul><p>这三个同名方法属于重载，参数列表不同。假如想要指定第 2 个 <code>info</code> 方法，那么形参列表为 <code>String.class</code>，因此程序中获取该方法应该使用如下代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// clazz 是 Class 对象，第一个参数是方法名，后面的个数可变的 Class 参数形参类型列表</span></span><br><span class="line">clazz.getMethod(<span class="string">"info"</span>, String.class);</span><br></pre></td></tr></table></figure><p>看了上面的例子，应该可以看懂 <code>Method getMethod(String name, Class&lt;?&gt; ... parameterTypes)</code> 这个方法如何使用了吧。这里仅是概览一下方法，下文会有更详细的示例。</p><h2 id="使用反射生成并操作对象"><a href="#使用反射生成并操作对象" class="headerlink" title="使用反射生成并操作对象"></a>使用反射生成并操作对象</h2><p>Class 对象通过上面介绍的方法，可以获得该类里的方法（由 <code>Method</code> 对象表示）、构造器（由 <code>Constructor</code> 对象表示）、成员变量（由 <code>Field</code> 对象表示），这三个类都位于 <code>java.lang.reflect</code> 包下，并实现了 <code>java.lang.reflect.Member</code> 接口。</p><p>程序可以通过 <code>Method</code> 对象来执行对应的方法，通过 <code>Constructor</code> 对象来调用对应的构造器创建实例，能通过 <code>Field</code> 对象直接访问并修改对象的成员变量值。</p><h3 id="创建对象"><a href="#创建对象" class="headerlink" title="创建对象"></a>创建对象</h3><p>先使用 Class 对象获取指定的 Constructor 对象，再调用 Constructor 对象的 <code>newInstance()</code> 方法来创建该 Class 对象对应类的实例！</p><p>看个栗子：</p><p>Student.java:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span></span>&#123;</span><br><span class="line">    String name;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Student</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"My name is: "</span> + name);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">hello</span><span class="params">(String content)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"name: "</span> + name + <span class="string">" say :"</span> + content);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>CreateObjectTest.java:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CreateObjectTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> Object <span class="title">createObject</span><span class="params">(String clazzName)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 根据全限定的类名获取对应的 Class 对象</span></span><br><span class="line">        Class&lt;?&gt; clazz = Class.forName(clazzName);</span><br><span class="line">        <span class="comment">// 使用 clazz 对应类的无参构造器创建实例</span></span><br><span class="line">        <span class="keyword">return</span> clazz.getConstructor().newInstance();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Object s = createObject(<span class="string">"reflect.Student"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其实，如果想调用有参的构造器创建对象，只要用上面介绍过的方法去获取有参的 <code>Contructor</code> 对象即可。然后调用 <code>newInstance</code> 方法时，传入对应的实参就行。</p><blockquote><p>Spring 框架就采用读取配置文件的内容，然后通过反射来创建对象。</p></blockquote><div class="note warning no-icon">            <p>通常没有必要使用反射来创建对象，因为反射创建对象时性能要稍低。实际上，只有当程序需要动态创建某个类的对象时才会考虑使用反射。通常在开发通用性比较广的框架、基础平台时可能会大量使用反射。</p>          </div><h3 id="调用方法"><a href="#调用方法" class="headerlink" title="调用方法"></a>调用方法</h3><p>通过反射调用方法其实和上面的步骤差不多：获得某个类的 Class 对象，通过该对象的 <code>getMethods()</code> 方法或者 <code>getMethod()</code> 方法获取全部方法或指定方法。具体语法在上面介绍过。方法返回值是 <code>Method</code> 数组或者 <code>Method</code> 对象。</p><p>每个 <code>Method</code> 对象对应一个方法，程序通过该 <code>Method</code> 调用它对应的方法。<code>Method</code> 包含一个 <code>invoke()</code> 方法，方法签名如下：</p><ul><li><code>Object invoke(Object obj,Object ... args)</code>：<code>obj</code> 是执行该方法的主调，<code>args</code> 是执行该方法时传入的实参。</li></ul><p>接上面的示例继续完善，CreateObjectTest.java：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CreateObjectTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> Object <span class="title">createObject</span><span class="params">(String clazzName)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Class&lt;?&gt; clazz = Class.forName(clazzName);</span><br><span class="line">        <span class="keyword">return</span> clazz.getConstructor().newInstance();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">methodTest</span><span class="params">(Object target)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 通过实例的 `getClass` 方法获取 Class 对象</span></span><br><span class="line">        Class&lt;?&gt; clazz = target.getClass();</span><br><span class="line">        <span class="comment">// 通过 Class 对象获取对应类的 Method 对象</span></span><br><span class="line">        Method mtd = clazz.getMethod(<span class="string">"hello"</span>, String.class);</span><br><span class="line">        <span class="comment">// 调用 Method 对象的 invoke 方法，传入方法实参</span></span><br><span class="line">        mtd.invoke(target, <span class="string">"测试"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Object s = createObject(<span class="string">"reflect.Student"</span>);</span><br><span class="line">        methodTest(s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">name: null say :测试</span><br></pre></td></tr></table></figure></p><p>这里因为调用的是 Student 无参构造器，因此 name 为空。</p><p>Method 的 <code>invoke()</code> 方法来调用对应方法时，Java 会要求程序具有调用该方法的权限。默认情况，<code>private</code> 方法是无权调用的。可以通过先调用 Method 对象的 <code>setAccessible(boolean flag)</code> 方法取消 Java 语言的访问权限检查（设为 <code>false</code> 时，不检查）。</p><blockquote><p>Spring 框架将成员变量的值以及依赖对象等都放在配置文件中，然后采用上面方式进行创建对象、赋值成员变量的。这也是 Spring 框架 IoC 的秘密。</p></blockquote><div class="note info no-icon">            <p>上面这个是《疯狂 Java 讲义》中的提示，从这提示里可以看到，反射的重点意义其实不在于它能够创建对象、赋值变量，因为这通过构造器等也能做，我觉得它存在的主要意义在于能够在<strong>运行时</strong>动态地执行创建对象、赋值变量等操作。</p>          </div><h3 id="访问成员变量值"><a href="#访问成员变量值" class="headerlink" title="访问成员变量值"></a>访问成员变量值</h3><p>通过 Class 对象的 <code>getFields()</code> 或 <code>getField()</code> 方法可以获取该类所包括的全部成员变量或指定成员变量。Field 提供了下面两组方法来读取或设置成员变量值。</p><ul><li><code>getXxx(Object obj)</code> 获取 <code>obj</code> 对象的该成员的变量值。此处 Xxx 对应 8 中基本类型，如果该成员变量类型是引用类型，则取消 get 后面的 Xxx</li><li><code>setXxx(Object obj, Xxx val)</code> 将 <code>obj</code> 对象的该成员变量设置成 val 值。如果该成员变量类型是引用类型，则取消 set 后面的 Xxx</li></ul><p>栗子：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> Integer age;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String name, Integer age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Person&#123;"</span> +</span><br><span class="line">                <span class="string">"name='"</span> + name + <span class="string">'\''</span> +</span><br><span class="line">                <span class="string">", age="</span> + age +</span><br><span class="line">                <span class="string">'&#125;'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FieldTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 创建一个 Person 对象</span></span><br><span class="line">        Person p = <span class="keyword">new</span> Person();</span><br><span class="line">        <span class="comment">// 获取 Class 对象</span></span><br><span class="line">        Class&lt;Person&gt; personClazz = Person.class;</span><br><span class="line">        <span class="comment">// 使用 getDeclaredField() 方法获取 private 类型的成员变量</span></span><br><span class="line">        Field nameFiled = personClazz.getDeclaredField(<span class="string">"name"</span>);</span><br><span class="line">        <span class="comment">// 能够获取到并不代表能够访问成员变量，需要设置可访问才行，否则会报错：</span></span><br><span class="line">        <span class="comment">// Class reflect.FieldTest can not access a member of class reflect.Person with modifiers "private"</span></span><br><span class="line">        nameFiled.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        nameFiled.set(p, <span class="string">"Michael"</span>);</span><br><span class="line">        Field ageFiled = personClazz.getDeclaredField(<span class="string">"age"</span>);</span><br><span class="line">        ageFiled.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        <span class="comment">// 调用 setInt() 方法为 p 对象的 age 成员变量设置值</span></span><br><span class="line">        <span class="comment">// ageFiled.setInt(p, 30);</span></span><br><span class="line">        ageFiled.set(p, <span class="number">30</span>);</span><br><span class="line">        System.out.println(p);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>上面代码中，如果使用 <code>ageFiled.setInt(p,30)</code> 则会报如下错误：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Exception in thread&quot;main&quot;java.lang.IllegalArgumentException:Can not set java.lang.Integer field reflect.Person.age to(int)30</span><br><span class="line">at sun.reflect.UnsafeFieldAccessorImpl.throwSetIllegalArgumentException(UnsafeFieldAccessorImpl.java:167)</span><br><span class="line">at sun.reflect.UnsafeFieldAccessorImpl.throwSetIllegalArgumentException(UnsafeFieldAccessorImpl.java:191)</span><br><span class="line">at sun.reflect.UnsafeObjectFieldAccessorImpl.setInt(UnsafeObjectFieldAccessorImpl.java:114)</span><br><span class="line">at java.lang.reflect.Field.setInt(Field.java:949)</span><br><span class="line">at reflect.FieldTest.main(FieldTest.java:50)</span><br></pre></td></tr></table></figure></p><p>因为 <code>age</code> 不是基本类型，要用上面那种写法才会 OK。</p><h3 id="操作数组"><a href="#操作数组" class="headerlink" title="操作数组"></a>操作数组</h3><p>在 <code>java.lang.reflect</code> 包下提供了一个 Array 类，Array 对象可以代表所有的数组。可以通过 Array 动态地创建数组、操作数组元素。</p><ul><li><code>static Object newInstance(Class&lt;?&gt; componentType,int ... length)</code>：创建一个具有指定的元素类型、指定维度的新数组</li><li><code>static xxx getXxx(Object  array, int index)</code>：返回 array 数组中第 index 个元素。其中，xxx 是各种基本数据类型，如果数据元素时引用类型，则方法为 <code>get(Object array, int index)</code></li><li><code>static setXxx(Object array, int index, xxx value)</code>：设置 array 数组中第 index 个元素值为 value。xxx 表示基本类型，如果是引用引用类型，则方法为 <code>set(Object array, int index, Object value)</code>。</li></ul><p>具体的用法，可以阅读 <a href="https://docs.oracle.com/javase/8/docs/api/java/lang/reflect/Array.html" target="_blank" rel="noopener">java.lang.reflect.Array</a></p><p>栗子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Object arr = Array.newInstance(String.class, <span class="number">10</span>);</span><br><span class="line">            Array.set(arr, <span class="number">5</span>, <span class="string">"反射测试"</span>);</span><br><span class="line">            Array.set(arr, <span class="number">6</span>, <span class="string">"数组学习"</span>);</span><br><span class="line">            Object c1 = Array.get(arr, <span class="number">5</span>);</span><br><span class="line">            Object c2 = Array.get(arr, <span class="number">6</span>);</span><br><span class="line">            System.out.println(c1);</span><br><span class="line">            System.out.println(c2);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            System.out.println(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><ul><li><code>java.lang.reflect</code> 包下还有 Proxy 类和一个 <code>InvocationHandler</code> 接口，通过他们可以生成 JDK 动态代理或动态代理对象。代理对象具有原本对象的执行方法之外，还增加了可以增加以下额外的行为（AOP 里方法在执行目标前、之后插入一些通用处理的效果）。</li></ul><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://cloud.tencent.com/developer/article/1015078" target="_blank" rel="noopener">腾讯云社区/深入理解 Java 反射：Field （成员变量）</a></li><li>《疯狂 Java 讲义》第四版，18 章</li></ul><hr><blockquote><p>生命不息，折腾不止！关注 「Coder 魔法院」，祝你 Niubilitiy ！🐂🍺</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://gitee.com/michael_xiang/images/raw/master/uPic/looking-glass-918878_640.jpg&quot; alt=&quot;远方&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;通过反射查看类信息&quot;&gt;&lt;a href=&quot;#通过反射查看类信息&quot; class=&quot;headerlink&quot; title=&quot;通过反射查看类信息&quot;&gt;&lt;/a&gt;通过反射查看类信息&lt;/h2&gt;&lt;p&gt;Java 程序中的许多对象在运行时会出现两种类型：编译时类型和运行时类型。例如：&lt;code&gt;Person p = new Student();&lt;/code&gt;，代码会生成一个 p 变量，编译时类型是 Person，运行时类型为 Student。除此之外，有时程序在运行时接收到外部传入的一个编译类型为 Object，但程序又需要调用该对象运行时类型的方法。&lt;/p&gt;
    
    </summary>
    
      <category term="Java" scheme="https://michael728.github.io/categories/Java/"/>
    
    
      <category term="Java" scheme="https://michael728.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Java 基础 —— 类加载</title>
    <link href="https://michael728.github.io/2020/08/07/java-basic-class-load/"/>
    <id>https://michael728.github.io/2020/08/07/java-basic-class-load/</id>
    <published>2020-08-07T22:25:50.000Z</published>
    <updated>2021-02-12T13:27:05.289Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://gitee.com/michael_xiang/images/raw/master/uPic/pexels-maria-varshavskaya-4931004.jpg" alt="pexels-maria-varshavskaya"></p><h2 id="JVM-和类"><a href="#JVM-和类" class="headerlink" title="JVM 和类"></a>JVM 和类</h2><p>当使用 java 命令运行 Java 程序时，会启动一个 Java 虚拟机进程。同一个 JVM 的所有线程、所有变量都处于同一个进程里，他们都使用该 JVM 进程的内存区。当系统出现如下情况时，JVM 进程将被终止。</p><ul><li>程序运行到最后正常结束</li><li>程序使用了 <code>System.exit()</code> 或 <code>Runtime.getRuntime().exit()</code></li><li>程序遇到未捕获的异常或错误</li><li>程序所在平台强制结束了 JVM 进程</li></ul><blockquote><p>两个运行的 Java 程序处于两个不同的 JVM 进程中，两个 JVM 之间并不会共享数据。</p></blockquote><a id="more"></a><h2 id="类的加载"><a href="#类的加载" class="headerlink" title="类的加载"></a>类的加载</h2><p>当程序主动使用某个类时，如果该类还未被加载到内存中，则系统会通过加载、连接、初始化三个步骤来进行该类的初始化。这三个步骤统称为「类加载」或「类初始化」。</p><p>「类加载」指的是将类的 class 文件读入内存，并为之创建一个 <code>java.lang.Class</code> 对象。换言之，程序中使用任何类时，系统都会为之建立一个 <code>java.lang.Class</code> 对象。</p><blockquote><p>系统中所有的类实际上也是实例，它们都是 <code>java.lang.Class</code> 的实例。</p></blockquote><p>类的加载由类加载器完成，类加载器由 JVM 提供。除此之外，开发者可以通过集成 ClassLoader 基类来自定义类加载。**类加载器通常无须等到”首次使用“该类时才加载它，Java 虚拟机规范允许系统预先加载某些类。</p><h2 id="类的连接"><a href="#类的连接" class="headerlink" title="类的连接"></a>类的连接</h2><p>类被加载后，系统会为之生成对应的 Class 对象，接着就会进入连接阶段。连接阶段负责把类的二进制数据合并到 JRE 中。类接连分为如下三个阶段：</p><ol><li>验证：验证阶段用于检验被加载的类是否有正确的内部结构</li><li>准备：类准备阶段则负责为类的<strong>类变量</strong>分配内存，并设置默认初始值</li><li>解析：将类的二进制数据中的符号引用替换成直接引用</li></ol><h2 id="类的初始化"><a href="#类的初始化" class="headerlink" title="类的初始化"></a>类的初始化</h2><p>类初始化阶段主要就是虚拟机堆类变量进行初始化。在 Java 类中堆类变量指定初始值有两种方法：</p><ol><li>声明类变量时指定初始值</li><li>使用静态初始化块为类变量指定初始值</li></ol><blockquote><p>如果类变量没有指定初始值，则采用默认初始值</p></blockquote><div class="note success no-icon">            <ul><li>静态初始化块只会被执行一次（第一次加载该类时），静态初始化块先于构造器执行。</li><li>类初始化块和类变量所指定的初始值都是该类的初始化代码，它们的执行顺序与源程序中的排列顺序相同。</li></ul>          </div><p>JVM 初始化一个类包含如下几个步骤：</p><ol><li>加入该类未被加载和连接，则程序先加载并连接该类</li><li>假如该类的直接父类还没有被初始化，则先初始化其直接父类</li><li>假如类中有初始化语句，则系统依次执行这些初始化语句</li></ol><blockquote><p>第 2 个步骤中，如果直接父类又有父类，会再次重复这三个步骤</p></blockquote><p>实例初始化块负责对象执行初始化，而类初始化块是类相关的，系统在类初始化阶段执行，而不是在创建对象时才执行。因此，类初始化块总是比实例初始化块先执行。只有当类初始化完成之后，才可以在系统中使用这个类，包括访问类的类方法、类变量或者用这个类来创建实例。</p><p>栗子</p><p>Root.java:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Root</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">int</span> root = <span class="number">1</span>;</span><br><span class="line">        System.out.println(<span class="string">"Root 的类初始化块"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">"Root 的实例初始化块"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Root</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Root 的无参构造器"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Mid.java:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Mid</span> <span class="keyword">extends</span> <span class="title">Root</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = <span class="number">2</span>;</span><br><span class="line">        System.out.println(<span class="string">"Mid 的类初始化块"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">"Mid 的实例初始化块"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Mid</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Mid 的无参构造器"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Mid</span><span class="params">(String msg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>();</span><br><span class="line">        System.out.println(<span class="string">"Mid 的有参构造器，其参数值："</span> + msg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Leaf.java:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Leaf</span> <span class="keyword">extends</span> <span class="title">Mid</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">int</span> leaf = <span class="number">3</span>;</span><br><span class="line">        System.out.println(<span class="string">"Leaf 的类初始化块"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">"Leaf 的实例初始化块"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Leaf</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(<span class="string">"初始化测试"</span>);</span><br><span class="line">        System.out.println(<span class="string">"执行Leaf的构造器"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Test.java:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Leaf();</span><br><span class="line">        <span class="keyword">new</span> Leaf();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果会是怎样的呢？停下来想一想。</p><p>输出结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Root 的类初始化块</span><br><span class="line">Mid 的类初始化块</span><br><span class="line">Leaf 的类初始化块</span><br><span class="line">Root 的实例初始化块</span><br><span class="line">Root 的无参构造器</span><br><span class="line">Mid 的实例初始化块</span><br><span class="line">Mid 的有参构造器，其参数值：初始化测试</span><br><span class="line">Leaf 的实例初始化块</span><br><span class="line">执行Leaf的构造器</span><br><span class="line">Root 的实例初始化块</span><br><span class="line">Root 的无参构造器</span><br><span class="line">Mid 的实例初始化块</span><br><span class="line">Mid 的有参构造器，其参数值：初始化测试</span><br><span class="line">Leaf 的实例初始化块</span><br><span class="line">执行Leaf的构造器</span><br></pre></td></tr></table></figure></p><p>说明：</p><ul><li>优先进行类初始化块（类静态块）的初始化，如果有父类，那么就先进行父类的的类初始化块运行；</li><li>类初始化块执行完成之后，会进行实例初始化块和构造器，如果有父类，则也需要先进行父类的实例初始化块、构造器执行；</li></ul><blockquote><p>实例初始化块就是指没有 static 修饰的初始化块。当创建该类的 Java 对象时，系统总是先调用该类定义的实例初始化块（当然，类初始化要已经先完成）。实例初始化是在创建 Java 对象时隐式执行的，而且，<strong>在构造器执行之前自动执行</strong>。</p></blockquote><p>实例初始化栗子</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InstanceTest</span> </span>&#123;</span><br><span class="line">    &#123;</span><br><span class="line">        a = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 输出 2</span></span><br><span class="line">        System.out.println(<span class="keyword">new</span> InstanceTest().a);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果上面例子，将实例初始化块和实例变量声明顺序调换，输出就会变为 1。</p><p>创建 Java 对象时，系统先为该对象的所有实例变量分配内存（前提是该类已被加载过），接着程序对这些实例变量进行初始化：先执行实例初始化块或声明实例变量时指定的初始值（按照它们在源码中的先后顺序赋值），然后再执行构造器里指定的初始值。</p><div class="note success no-icon">            <p>实际上实例初始化块是一个假象，使用 <code>javac</code> 命令编译 Java 类后，该 Java 类中的实例初始化块会消失—实例初始化块中代码会被“还原”到每个构造器中，且位于构造器所有代码的前面。</p>          </div><h2 id="类初始化的时机"><a href="#类初始化的时机" class="headerlink" title="类初始化的时机"></a>类初始化的时机</h2><p>Java 程序首次通过下面 6 种方式使用某个类或接口时，系统就会初始化该类或接口：</p><ol><li>创建类的实例。包括使用 new 操作符来创建实例、通过反射创建实例、通过反序列化创建实例</li><li>调用某个类的类方法（静态方法）</li><li>调用某个类的类变量，或为该类变量赋值</li><li>使用反射方式来强制创建某个类或接口对应的 <code>java.lang.Class</code> 对象。例如 <code>Class.forName(&quot;Person&quot;)</code></li><li>初始化某个类的子类。（就是前面介绍过的，该子类的所有父类都会被初始化）</li><li>直接使用 <code>java.exe</code> 命令运行某个主类</li></ol><div class="note warning no-icon">            <p>对于 <code>final</code> 型的类变量，<strong>如果该类变量的值在编译时就确定了</strong>，那么，这个类变量相当于「宏变量」。Java 编译器会在编译时直接将该类变量出现的地方替换为它实际的值。因此，程序使用这种静态变量不会导致该类的初始化。</p>          </div><p>栗子：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyTest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">"静态初始化块"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> String compileConstant = <span class="string">"类初始化 demo"</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ComileConstantTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(MyTest.compileConstant);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>输出：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">类初始化 demo</span><br></pre></td></tr></table></figure></p><p>由此可见，的确没有初始化 MyTest 类。</p><blockquote><p>当类变量使用了 <code>final</code> 修饰，并且，它的值在编译时就能确定，那么它的值在编译时就确定了，程序中使用它的地方相当于使用了常量。</p></blockquote><p>如果上面栗子中代码改为如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> String compileConstant = System.currentTimeMillis() + <span class="string">""</span>;</span><br></pre></td></tr></table></figure></p><p>这时候输出就是：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">静态初始化块</span><br><span class="line">1596804413248</span><br></pre></td></tr></table></figure></p><p>因为上面 <code>compileConstant</code> 修改之后，它的值必须在运行时才能确定，因此，触发了 MyTestg 类的初始化。</p><p>此外，<code>ClassLoader</code> 类的 <code>loadClass()</code> 方法来加载某个类时，该方法只是加载类，并不会执行类的初始化。使用 <code>Class.forName()</code> 静态方法再回强制初始化类。</p><p>栗子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> class_load;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * description:</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Michael</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2020/8/7</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@time</span> 8:54 下午</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Tester</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">"Tester 类的静态初始化块"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassLoadTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ClassNotFoundException </span>&#123;</span><br><span class="line">        ClassLoader cl = ClassLoader.getSystemClassLoader();</span><br><span class="line">        cl.loadClass(<span class="string">"class_load.Tester"</span>);</span><br><span class="line">        System.out.println(<span class="string">"系统加载 Tester 类"</span>);</span><br><span class="line">        Class.forName(<span class="string">"class_load.Tester"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">系统加载 Tester 类</span><br><span class="line">Tester 类的静态初始化块</span><br></pre></td></tr></table></figure></p><p>经测试可以发现，<code>loadClass</code> 方法确实没有触发类的初始化，而 <code>Class.forName</code> 则会初始化 <code>Tester</code> 类。</p><h2 id="类加载器"><a href="#类加载器" class="headerlink" title="类加载器"></a>类加载器</h2><p>类加载器负责将 <code>.class</code> 文件（可能在磁盘上，也可能在网络上）加载到内存中，并为之生成 <code>java.lang.Class</code> 对象。</p><h3 id="类加载机制"><a href="#类加载机制" class="headerlink" title="类加载机制"></a>类加载机制</h3><p>类加载器负责加载所有的类，系统为所有被载入内存中的类生成一个 <code>java.lang.Class</code> 对象/实例。一旦一个类被载入 JVM 中，同一个类就不会再次被载入。正是因为有这样的缓存机制存在，所以 Class 修改之后，必须重启 JVM 修改才会生效。</p><p>类加载器加载 <code>Class</code> 大致经过如下步骤：</p><p><img src="https://gitee.com/michael_xiang/images/raw/master/uPic/类加载机制.jpg" alt="类加载机制"></p><blockquote><p>开发者也可以通过继承 <code>ClassLoader</code> 来自定义类加载器。因为暂时未涉及这块，本文暂且略过。</p></blockquote><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文重点是了解了类初始化的流程，同时，也结合栗子比较了与实例初始化的区别。类初始化块、实例初始化块、构造器的执行顺序也是面试题常考的内容。最后补充了类加载机制的内容，暂时仅是了解。</p><p>绘图采用的 <a href="https://www.processon.com/i/55ddb6bae4b04fe84c504c5f" target="_blank" rel="noopener">ProcessOn</a> 在线绘制，安利~</p><hr><blockquote><p>生命不息，折腾不止！关注 「Coder 魔法院」，祝你 Niubilitiy ！🐂🍺</p></blockquote><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li>《疯狂 Java 讲义》第四版，18 章</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://gitee.com/michael_xiang/images/raw/master/uPic/pexels-maria-varshavskaya-4931004.jpg&quot; alt=&quot;pexels-maria-varshavskaya&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;JVM-和类&quot;&gt;&lt;a href=&quot;#JVM-和类&quot; class=&quot;headerlink&quot; title=&quot;JVM 和类&quot;&gt;&lt;/a&gt;JVM 和类&lt;/h2&gt;&lt;p&gt;当使用 java 命令运行 Java 程序时，会启动一个 Java 虚拟机进程。同一个 JVM 的所有线程、所有变量都处于同一个进程里，他们都使用该 JVM 进程的内存区。当系统出现如下情况时，JVM 进程将被终止。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;程序运行到最后正常结束&lt;/li&gt;
&lt;li&gt;程序使用了 &lt;code&gt;System.exit()&lt;/code&gt; 或 &lt;code&gt;Runtime.getRuntime().exit()&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;程序遇到未捕获的异常或错误&lt;/li&gt;
&lt;li&gt;程序所在平台强制结束了 JVM 进程&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;两个运行的 Java 程序处于两个不同的 JVM 进程中，两个 JVM 之间并不会共享数据。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="Java" scheme="https://michael728.github.io/categories/Java/"/>
    
    
      <category term="Java" scheme="https://michael728.github.io/tags/Java/"/>
    
      <category term="类" scheme="https://michael728.github.io/tags/%E7%B1%BB/"/>
    
  </entry>
  
  <entry>
    <title>Ubuntu 开发环境备忘</title>
    <link href="https://michael728.github.io/2020/08/01/tools-linux-ubuntu/"/>
    <id>https://michael728.github.io/2020/08/01/tools-linux-ubuntu/</id>
    <published>2020-08-01T12:25:50.000Z</published>
    <updated>2021-02-12T13:27:05.293Z</updated>
    
    <content type="html"><![CDATA[<h2 id="常用开发环境安装"><a href="#常用开发环境安装" class="headerlink" title="常用开发环境安装"></a>常用开发环境安装</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># npm</span><br><span class="line">sudo apt install npm</span><br><span class="line"># gitbook</span><br><span class="line">sudo npm install gitbook-cli -g</span><br><span class="line"># jdk</span><br><span class="line">sudo apt install openjdk-8-jdk</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;常用开发环境安装&quot;&gt;&lt;a href=&quot;#常用开发环境安装&quot; class=&quot;headerlink&quot; title=&quot;常用开发环境安装&quot;&gt;&lt;/a&gt;常用开发环境安装&lt;/h2&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td cl
      
    
    </summary>
    
      <category term="Linux" scheme="https://michael728.github.io/categories/Linux/"/>
    
    
      <category term="Linux" scheme="https://michael728.github.io/tags/Linux/"/>
    
      <category term="ENV" scheme="https://michael728.github.io/tags/ENV/"/>
    
  </entry>
  
  <entry>
    <title>中国婴幼儿身高体重参照表</title>
    <link href="https://michael728.github.io/2020/07/31/baby-weight-height/"/>
    <id>https://michael728.github.io/2020/07/31/baby-weight-height/</id>
    <published>2020-07-31T23:25:50.000Z</published>
    <updated>2021-02-12T13:27:05.285Z</updated>
    
    <content type="html"><![CDATA[<p>今天在一位技术博主的网站看到了他整理的这个表格，我也存过来备用一下吧。</p><a id="more"></a><h2 id="男孩体重标准表"><a href="#男孩体重标准表" class="headerlink" title="男孩体重标准表"></a>男孩体重标准表</h2><table><thead><tr><th style="text-align:center">月龄</th><th style="text-align:center">-3SD（轻）</th><th style="text-align:center">-2SD（偏轻）</th><th style="text-align:center">-1SD（正常）</th><th style="text-align:center">中位数（正常）</th><th style="text-align:center">+1SD（正常）</th><th style="text-align:center">+2SD（偏重）</th><th style="text-align:center">+3SD（重）</th></tr></thead><tbody><tr><td style="text-align:center">0</td><td style="text-align:center">2.26</td><td style="text-align:center">2.58</td><td style="text-align:center">2.93</td><td style="text-align:center">3.32</td><td style="text-align:center">3.73</td><td style="text-align:center">4.18</td><td style="text-align:center">4.66</td></tr><tr><td style="text-align:center">1</td><td style="text-align:center">3.09</td><td style="text-align:center">3.52</td><td style="text-align:center">3.99</td><td style="text-align:center">4.51</td><td style="text-align:center">5.07</td><td style="text-align:center">5.67</td><td style="text-align:center">6.33</td></tr><tr><td style="text-align:center">2</td><td style="text-align:center">3.94</td><td style="text-align:center">4.47</td><td style="text-align:center">5.05</td><td style="text-align:center">5.68</td><td style="text-align:center">6.38</td><td style="text-align:center">7.14</td><td style="text-align:center">7.97</td></tr><tr><td style="text-align:center">3</td><td style="text-align:center">4.69</td><td style="text-align:center">5.29</td><td style="text-align:center">5.97</td><td style="text-align:center">6.7</td><td style="text-align:center">7.51</td><td style="text-align:center">8.4</td><td style="text-align:center">9.37</td></tr><tr><td style="text-align:center">4</td><td style="text-align:center">5.25</td><td style="text-align:center">5.91</td><td style="text-align:center">6.64</td><td style="text-align:center">7.45</td><td style="text-align:center">8.34</td><td style="text-align:center">9.32</td><td style="text-align:center">10.39</td></tr><tr><td style="text-align:center">5</td><td style="text-align:center">5.66</td><td style="text-align:center">6.36</td><td style="text-align:center">7.14</td><td style="text-align:center">8</td><td style="text-align:center">8.95</td><td style="text-align:center">9.99</td><td style="text-align:center">11.15</td></tr><tr><td style="text-align:center">6</td><td style="text-align:center">5.97</td><td style="text-align:center">6.7</td><td style="text-align:center">7.51</td><td style="text-align:center">8.41</td><td style="text-align:center">9.41</td><td style="text-align:center">10.5</td><td style="text-align:center">11.72</td></tr><tr><td style="text-align:center">7</td><td style="text-align:center">6.24</td><td style="text-align:center">6.99</td><td style="text-align:center">7.83</td><td style="text-align:center">8.76</td><td style="text-align:center">9.79</td><td style="text-align:center">10.93</td><td style="text-align:center">12.2</td></tr><tr><td style="text-align:center">8</td><td style="text-align:center">6.46</td><td style="text-align:center">7.23</td><td style="text-align:center">8.09</td><td style="text-align:center">9.05</td><td style="text-align:center">10.11</td><td style="text-align:center">11.29</td><td style="text-align:center">12.6</td></tr><tr><td style="text-align:center">9</td><td style="text-align:center">6.67</td><td style="text-align:center">7.46</td><td style="text-align:center">8.35</td><td style="text-align:center">9.33</td><td style="text-align:center">10.42</td><td style="text-align:center">11.64</td><td style="text-align:center">12.99</td></tr><tr><td style="text-align:center">10</td><td style="text-align:center">6.86</td><td style="text-align:center">7.67</td><td style="text-align:center">8.53</td><td style="text-align:center">9.53</td><td style="text-align:center">10.71</td><td style="text-align:center">11.95</td><td style="text-align:center">13.34</td></tr><tr><td style="text-align:center">11</td><td style="text-align:center">7.04</td><td style="text-align:center">7.87</td><td style="text-align:center">8.8</td><td style="text-align:center">9.83</td><td style="text-align:center">10.98</td><td style="text-align:center">12.26</td><td style="text-align:center">13.68</td></tr><tr><td style="text-align:center">12</td><td style="text-align:center">7.21</td><td style="text-align:center">8.06</td><td style="text-align:center">9</td><td style="text-align:center">10.05</td><td style="text-align:center">11.23</td><td style="text-align:center">12.54</td><td style="text-align:center">14</td></tr><tr><td style="text-align:center">15</td><td style="text-align:center">7.63</td><td style="text-align:center">8.57</td><td style="text-align:center">9.57</td><td style="text-align:center">10.68</td><td style="text-align:center">11.93</td><td style="text-align:center">13.32</td><td style="text-align:center">14.88</td></tr><tr><td style="text-align:center">18</td><td style="text-align:center">8.13</td><td style="text-align:center">9.07</td><td style="text-align:center">10.12</td><td style="text-align:center">11.29</td><td style="text-align:center">12.61</td><td style="text-align:center">14.09</td><td style="text-align:center">15.75</td></tr><tr><td style="text-align:center">21</td><td style="text-align:center">8.61</td><td style="text-align:center">9.59</td><td style="text-align:center">10.69</td><td style="text-align:center">11.93</td><td style="text-align:center">13.33</td><td style="text-align:center">14.9</td><td style="text-align:center">16.66</td></tr><tr><td style="text-align:center">24</td><td style="text-align:center">9.06</td><td style="text-align:center">10.09</td><td style="text-align:center">11.24</td><td style="text-align:center">12.54</td><td style="text-align:center">14.01</td><td style="text-align:center">15.67</td><td style="text-align:center">17.54</td></tr><tr><td style="text-align:center">27</td><td style="text-align:center">9.47</td><td style="text-align:center">10.54</td><td style="text-align:center">11.75</td><td style="text-align:center">13.11</td><td style="text-align:center">14.64</td><td style="text-align:center">16.38</td><td style="text-align:center">18.36</td></tr><tr><td style="text-align:center">30</td><td style="text-align:center">9.86</td><td style="text-align:center">10.97</td><td style="text-align:center">12.22</td><td style="text-align:center">13.64</td><td style="text-align:center">15.24</td><td style="text-align:center">17.06</td><td style="text-align:center">19.13</td></tr><tr><td style="text-align:center">33</td><td style="text-align:center">10.24</td><td style="text-align:center">11.39</td><td style="text-align:center">12.68</td><td style="text-align:center">14.15</td><td style="text-align:center">15.32</td><td style="text-align:center">17.72</td><td style="text-align:center">19.39</td></tr><tr><td style="text-align:center">36</td><td style="text-align:center">10.61</td><td style="text-align:center">11.79</td><td style="text-align:center">13.13</td><td style="text-align:center">14.65</td><td style="text-align:center">16.39</td><td style="text-align:center">18.37</td><td style="text-align:center">20.64</td></tr><tr><td style="text-align:center">39</td><td style="text-align:center">10.97</td><td style="text-align:center">12.19</td><td style="text-align:center">13.57</td><td style="text-align:center">15.15</td><td style="text-align:center">16.95</td><td style="text-align:center">19.02</td><td style="text-align:center">21.39</td></tr><tr><td style="text-align:center">42</td><td style="text-align:center">11.31</td><td style="text-align:center">12.57</td><td style="text-align:center">14</td><td style="text-align:center">15.63</td><td style="text-align:center">17.5</td><td style="text-align:center">19.65</td><td style="text-align:center">22.13</td></tr><tr><td style="text-align:center">45</td><td style="text-align:center">11.66</td><td style="text-align:center">12.96</td><td style="text-align:center">14.44</td><td style="text-align:center">16.13</td><td style="text-align:center">18.07</td><td style="text-align:center">20.32</td><td style="text-align:center">22.91</td></tr><tr><td style="text-align:center">48</td><td style="text-align:center">12.01</td><td style="text-align:center">13.35</td><td style="text-align:center">14.88</td><td style="text-align:center">16.64</td><td style="text-align:center">18.67</td><td style="text-align:center">21.01</td><td style="text-align:center">23.73</td></tr><tr><td style="text-align:center">51</td><td style="text-align:center">12.37</td><td style="text-align:center">13.76</td><td style="text-align:center">15.35</td><td style="text-align:center">17.18</td><td style="text-align:center">19.3</td><td style="text-align:center">21.76</td><td style="text-align:center">24.63</td></tr><tr><td style="text-align:center">54</td><td style="text-align:center">12.74</td><td style="text-align:center">14.18</td><td style="text-align:center">15.84</td><td style="text-align:center">17.75</td><td style="text-align:center">19.98</td><td style="text-align:center">22.57</td><td style="text-align:center">25.61</td></tr><tr><td style="text-align:center">57</td><td style="text-align:center">13.12</td><td style="text-align:center">14.61</td><td style="text-align:center">16.34</td><td style="text-align:center">13.35</td><td style="text-align:center">20.69</td><td style="text-align:center">23.43</td><td style="text-align:center">26.68</td></tr><tr><td style="text-align:center">60</td><td style="text-align:center">13.5</td><td style="text-align:center">15.06</td><td style="text-align:center">16.87</td><td style="text-align:center">18.98</td><td style="text-align:center">21.46</td><td style="text-align:center">24.38</td><td style="text-align:center">27.85</td></tr><tr><td style="text-align:center">63</td><td style="text-align:center">13.36</td><td style="text-align:center">15.48</td><td style="text-align:center">17.33</td><td style="text-align:center">19.6</td><td style="text-align:center">22.21</td><td style="text-align:center">25.32</td><td style="text-align:center">29.04</td></tr><tr><td style="text-align:center">66</td><td style="text-align:center">14.18</td><td style="text-align:center">15.87</td><td style="text-align:center">17.85</td><td style="text-align:center">20.13</td><td style="text-align:center">22.94</td><td style="text-align:center">26.24</td><td style="text-align:center">30.22</td></tr><tr><td style="text-align:center">69</td><td style="text-align:center">14.43</td><td style="text-align:center">16.24</td><td style="text-align:center">18.31</td><td style="text-align:center">20.75</td><td style="text-align:center">23.66</td><td style="text-align:center">27.17</td><td style="text-align:center">31.43</td></tr><tr><td style="text-align:center">72</td><td style="text-align:center">14.74</td><td style="text-align:center">16.56</td><td style="text-align:center">18.71</td><td style="text-align:center">21.26</td><td style="text-align:center">24.32</td><td style="text-align:center">28.03</td><td style="text-align:center">32.57</td></tr><tr><td style="text-align:center">75</td><td style="text-align:center">15.01</td><td style="text-align:center">16.9</td><td style="text-align:center">19.14</td><td style="text-align:center">21.32</td><td style="text-align:center">25.06</td><td style="text-align:center">29.01</td><td style="text-align:center">33.39</td></tr><tr><td style="text-align:center">78</td><td style="text-align:center">15.3</td><td style="text-align:center">17.27</td><td style="text-align:center">19.62</td><td style="text-align:center">22.45</td><td style="text-align:center">25.89</td><td style="text-align:center">30.13</td><td style="text-align:center">35.41</td></tr><tr><td style="text-align:center">81</td><td style="text-align:center">15.66</td><td style="text-align:center">17.73</td><td style="text-align:center">20.22</td><td style="text-align:center">23.24</td><td style="text-align:center">26.95</td><td style="text-align:center">31.56</td><td style="text-align:center">37.39</td></tr></tbody></table><h2 id="男孩身高标准表"><a href="#男孩身高标准表" class="headerlink" title="男孩身高标准表"></a>男孩身高标准表</h2><table><thead><tr><th style="text-align:center">月龄</th><th style="text-align:center">-3SD（矮）</th><th style="text-align:center">-2SD（偏矮）</th><th style="text-align:center">-1SD（正常）</th><th style="text-align:center">中位数（正常）</th><th style="text-align:center">+1SD（正常）</th><th style="text-align:center">+2SD（偏高）</th><th style="text-align:center">+3SD（高）</th></tr></thead><tbody><tr><td style="text-align:center">0</td><td style="text-align:center">45.2</td><td style="text-align:center">46.9</td><td style="text-align:center">48.6</td><td style="text-align:center">50.4</td><td style="text-align:center">52.2</td><td style="text-align:center">54</td><td style="text-align:center">55.3</td></tr><tr><td style="text-align:center">1</td><td style="text-align:center">43.7</td><td style="text-align:center">50.7</td><td style="text-align:center">52.7</td><td style="text-align:center">54.8</td><td style="text-align:center">56.9</td><td style="text-align:center">59</td><td style="text-align:center">61.2</td></tr><tr><td style="text-align:center">2</td><td style="text-align:center">52.2</td><td style="text-align:center">54.3</td><td style="text-align:center">56.5</td><td style="text-align:center">58.7</td><td style="text-align:center">61</td><td style="text-align:center">63.3</td><td style="text-align:center">65.7</td></tr><tr><td style="text-align:center">3</td><td style="text-align:center">55.3</td><td style="text-align:center">57.5</td><td style="text-align:center">59.7</td><td style="text-align:center">62</td><td style="text-align:center">64.3</td><td style="text-align:center">66.6</td><td style="text-align:center">69</td></tr><tr><td style="text-align:center">4</td><td style="text-align:center">57.9</td><td style="text-align:center">60.1</td><td style="text-align:center">62.3</td><td style="text-align:center">64.6</td><td style="text-align:center">66.9</td><td style="text-align:center">69.3</td><td style="text-align:center">71.7</td></tr><tr><td style="text-align:center">5</td><td style="text-align:center">59.9</td><td style="text-align:center">62.1</td><td style="text-align:center">64.4</td><td style="text-align:center">66.7</td><td style="text-align:center">69.1</td><td style="text-align:center">71.5</td><td style="text-align:center">73.9</td></tr><tr><td style="text-align:center">6</td><td style="text-align:center">61.4</td><td style="text-align:center">63.7</td><td style="text-align:center">66</td><td style="text-align:center">68.4</td><td style="text-align:center">70.8</td><td style="text-align:center">73.3</td><td style="text-align:center">75.8</td></tr><tr><td style="text-align:center">7</td><td style="text-align:center">62.7</td><td style="text-align:center">65</td><td style="text-align:center">67.4</td><td style="text-align:center">69.3</td><td style="text-align:center">72.3</td><td style="text-align:center">74.8</td><td style="text-align:center">77.4</td></tr><tr><td style="text-align:center">8</td><td style="text-align:center">63.9</td><td style="text-align:center">66.3</td><td style="text-align:center">68.7</td><td style="text-align:center">71.2</td><td style="text-align:center">73.7</td><td style="text-align:center">76.3</td><td style="text-align:center">78.9</td></tr><tr><td style="text-align:center">9</td><td style="text-align:center">65.2</td><td style="text-align:center">67.6</td><td style="text-align:center">70.1</td><td style="text-align:center">72.6</td><td style="text-align:center">75.2</td><td style="text-align:center">77.8</td><td style="text-align:center">80.5</td></tr><tr><td style="text-align:center">10</td><td style="text-align:center">66.4</td><td style="text-align:center">68.9</td><td style="text-align:center">71.4</td><td style="text-align:center">74</td><td style="text-align:center">76.6</td><td style="text-align:center">79.3</td><td style="text-align:center">82.1</td></tr><tr><td style="text-align:center">11</td><td style="text-align:center">67.5</td><td style="text-align:center">70.1</td><td style="text-align:center">72.7</td><td style="text-align:center">75.3</td><td style="text-align:center">78</td><td style="text-align:center">80.8</td><td style="text-align:center">83.6</td></tr><tr><td style="text-align:center">12</td><td style="text-align:center">68.6</td><td style="text-align:center">71.2</td><td style="text-align:center">73.8</td><td style="text-align:center">76.5</td><td style="text-align:center">79.3</td><td style="text-align:center">82.1</td><td style="text-align:center">85</td></tr><tr><td style="text-align:center">15</td><td style="text-align:center">71.2</td><td style="text-align:center">74</td><td style="text-align:center">76.9</td><td style="text-align:center">79.8</td><td style="text-align:center">82.3</td><td style="text-align:center">85.8</td><td style="text-align:center">83.9</td></tr><tr><td style="text-align:center">18</td><td style="text-align:center">73.6</td><td style="text-align:center">76.6</td><td style="text-align:center">79.6</td><td style="text-align:center">82.7</td><td style="text-align:center">85.8</td><td style="text-align:center">89.1</td><td style="text-align:center">92.4</td></tr><tr><td style="text-align:center">21</td><td style="text-align:center">76</td><td style="text-align:center">79.1</td><td style="text-align:center">82.3</td><td style="text-align:center">85.6</td><td style="text-align:center">89</td><td style="text-align:center">92.4</td><td style="text-align:center">95.9</td></tr><tr><td style="text-align:center">24</td><td style="text-align:center">78.3</td><td style="text-align:center">81.6</td><td style="text-align:center">85.1</td><td style="text-align:center">83.5</td><td style="text-align:center">92.1</td><td style="text-align:center">95.3</td><td style="text-align:center">99.5</td></tr><tr><td style="text-align:center">27</td><td style="text-align:center">30.5</td><td style="text-align:center">83.9</td><td style="text-align:center">87.5</td><td style="text-align:center">91.1</td><td style="text-align:center">94.3</td><td style="text-align:center">93.6</td><td style="text-align:center">102.5</td></tr><tr><td style="text-align:center">30</td><td style="text-align:center">82.4</td><td style="text-align:center">85.9</td><td style="text-align:center">39.6</td><td style="text-align:center">93.3</td><td style="text-align:center">97.1</td><td style="text-align:center">101</td><td style="text-align:center">105</td></tr><tr><td style="text-align:center">33</td><td style="text-align:center">84.4</td><td style="text-align:center">83</td><td style="text-align:center">91.6</td><td style="text-align:center">95.4</td><td style="text-align:center">99.3</td><td style="text-align:center">103.2</td><td style="text-align:center">107.2</td></tr><tr><td style="text-align:center">36</td><td style="text-align:center">86.3</td><td style="text-align:center">90</td><td style="text-align:center">93.7</td><td style="text-align:center">97.5</td><td style="text-align:center">101.4</td><td style="text-align:center">105.3</td><td style="text-align:center">109.4</td></tr><tr><td style="text-align:center">39</td><td style="text-align:center">37.5</td><td style="text-align:center">91.2</td><td style="text-align:center">94.9</td><td style="text-align:center">98.8</td><td style="text-align:center">102.7</td><td style="text-align:center">106.7</td><td style="text-align:center">110.7</td></tr><tr><td style="text-align:center">42</td><td style="text-align:center">89.3</td><td style="text-align:center">93</td><td style="text-align:center">96.7</td><td style="text-align:center">100.6</td><td style="text-align:center">104.5</td><td style="text-align:center">108.6</td><td style="text-align:center">112.7</td></tr><tr><td style="text-align:center">45</td><td style="text-align:center">90.9</td><td style="text-align:center">94.6</td><td style="text-align:center">93.5</td><td style="text-align:center">102.4</td><td style="text-align:center">106.4</td><td style="text-align:center">110.4</td><td style="text-align:center">114.6</td></tr><tr><td style="text-align:center">48</td><td style="text-align:center">92.5</td><td style="text-align:center">96.3</td><td style="text-align:center">100.2</td><td style="text-align:center">104.1</td><td style="text-align:center">108.2</td><td style="text-align:center">112.3</td><td style="text-align:center">116.5</td></tr><tr><td style="text-align:center">51</td><td style="text-align:center">94</td><td style="text-align:center">97.9</td><td style="text-align:center">101.9</td><td style="text-align:center">105.9</td><td style="text-align:center">110</td><td style="text-align:center">114.2</td><td style="text-align:center">113.5</td></tr><tr><td style="text-align:center">54</td><td style="text-align:center">95.6</td><td style="text-align:center">99.5</td><td style="text-align:center">103.6</td><td style="text-align:center">107.7</td><td style="text-align:center">111.9</td><td style="text-align:center">116.2</td><td style="text-align:center">120.6</td></tr><tr><td style="text-align:center">57</td><td style="text-align:center">97.1</td><td style="text-align:center">101.1</td><td style="text-align:center">105.3</td><td style="text-align:center">109.5</td><td style="text-align:center">113.8</td><td style="text-align:center">113.2</td><td style="text-align:center">122.6</td></tr><tr><td style="text-align:center">60</td><td style="text-align:center">98.7</td><td style="text-align:center">102.8</td><td style="text-align:center">107</td><td style="text-align:center">111.3</td><td style="text-align:center">115.7</td><td style="text-align:center">120.1</td><td style="text-align:center">124.7</td></tr><tr><td style="text-align:center">63</td><td style="text-align:center">100.2</td><td style="text-align:center">104.4</td><td style="text-align:center">108.7</td><td style="text-align:center">113</td><td style="text-align:center">117.5</td><td style="text-align:center">122</td><td style="text-align:center">126.7</td></tr><tr><td style="text-align:center">66</td><td style="text-align:center">101.6</td><td style="text-align:center">105.9</td><td style="text-align:center">110.2</td><td style="text-align:center">114.7</td><td style="text-align:center">119.2</td><td style="text-align:center">123.8</td><td style="text-align:center">128.6</td></tr><tr><td style="text-align:center">69</td><td style="text-align:center">103</td><td style="text-align:center">107.3</td><td style="text-align:center">111.7</td><td style="text-align:center">116.3</td><td style="text-align:center">120.9</td><td style="text-align:center">125.6</td><td style="text-align:center">130.4</td></tr><tr><td style="text-align:center">72</td><td style="text-align:center">104.1</td><td style="text-align:center">103.6</td><td style="text-align:center">113.1</td><td style="text-align:center">117.7</td><td style="text-align:center">122.4</td><td style="text-align:center">127.2</td><td style="text-align:center">132.1</td></tr><tr><td style="text-align:center">75</td><td style="text-align:center">105.3</td><td style="text-align:center">109.3</td><td style="text-align:center">114.4</td><td style="text-align:center">119.2</td><td style="text-align:center">124</td><td style="text-align:center">128.8</td><td style="text-align:center">133.3</td></tr><tr><td style="text-align:center">78</td><td style="text-align:center">106.5</td><td style="text-align:center">111.1</td><td style="text-align:center">115.8</td><td style="text-align:center">120.7</td><td style="text-align:center">125.6</td><td style="text-align:center">130.5</td><td style="text-align:center">135.6</td></tr><tr><td style="text-align:center">81</td><td style="text-align:center">107.9</td><td style="text-align:center">112.6</td><td style="text-align:center">117.4</td><td style="text-align:center">122.3</td><td style="text-align:center">127.3</td><td style="text-align:center">132.4</td><td style="text-align:center">137.6</td></tr></tbody></table><h2 id="女孩体重标准表"><a href="#女孩体重标准表" class="headerlink" title="女孩体重标准表"></a>女孩体重标准表</h2><table><thead><tr><th style="text-align:center">月龄</th><th style="text-align:center">-3SD（轻）</th><th style="text-align:center">-2SD（偏轻）</th><th style="text-align:center">-1SD（正常）</th><th style="text-align:center">中位数（正常）</th><th style="text-align:center">+1SD（正常）</th><th style="text-align:center">+2SD（偏重）</th><th style="text-align:center">+3SD（重）</th></tr></thead><tbody><tr><td style="text-align:center">0</td><td style="text-align:center">2.26</td><td style="text-align:center">2.54</td><td style="text-align:center">2.85</td><td style="text-align:center">3.21</td><td style="text-align:center">3.63</td><td style="text-align:center">4.1</td><td style="text-align:center">4.65</td></tr><tr><td style="text-align:center">1</td><td style="text-align:center">2.98</td><td style="text-align:center">3.33</td><td style="text-align:center">3.74</td><td style="text-align:center">4.2</td><td style="text-align:center">4.74</td><td style="text-align:center">5.35</td><td style="text-align:center">6.05</td></tr><tr><td style="text-align:center">2</td><td style="text-align:center">3.72</td><td style="text-align:center">4.15</td><td style="text-align:center">4.65</td><td style="text-align:center">5.21</td><td style="text-align:center">5.86</td><td style="text-align:center">6.6</td><td style="text-align:center">7.46</td></tr><tr><td style="text-align:center">3</td><td style="text-align:center">4.4</td><td style="text-align:center">4.9</td><td style="text-align:center">5.47</td><td style="text-align:center">6.13</td><td style="text-align:center">6.87</td><td style="text-align:center">7.73</td><td style="text-align:center">8.71</td></tr><tr><td style="text-align:center">4</td><td style="text-align:center">4.93</td><td style="text-align:center">5.48</td><td style="text-align:center">6.11</td><td style="text-align:center">6.83</td><td style="text-align:center">7.65</td><td style="text-align:center">8.59</td><td style="text-align:center">9.66</td></tr><tr><td style="text-align:center">5</td><td style="text-align:center">5.33</td><td style="text-align:center">5.92</td><td style="text-align:center">6.59</td><td style="text-align:center">7.36</td><td style="text-align:center">8.23</td><td style="text-align:center">9.23</td><td style="text-align:center">10.38</td></tr><tr><td style="text-align:center">6</td><td style="text-align:center">5.64</td><td style="text-align:center">6.26</td><td style="text-align:center">6.96</td><td style="text-align:center">7.77</td><td style="text-align:center">8.68</td><td style="text-align:center">9.73</td><td style="text-align:center">10.93</td></tr><tr><td style="text-align:center">7</td><td style="text-align:center">5.9</td><td style="text-align:center">6.55</td><td style="text-align:center">7.28</td><td style="text-align:center">8.11</td><td style="text-align:center">9.06</td><td style="text-align:center">10.15</td><td style="text-align:center">11.4</td></tr><tr><td style="text-align:center">8</td><td style="text-align:center">6.13</td><td style="text-align:center">6.79</td><td style="text-align:center">7.55</td><td style="text-align:center">8.41</td><td style="text-align:center">9.39</td><td style="text-align:center">10.51</td><td style="text-align:center">11.8</td></tr><tr><td style="text-align:center">9</td><td style="text-align:center">6.34</td><td style="text-align:center">7.03</td><td style="text-align:center">7.81</td><td style="text-align:center">8.69</td><td style="text-align:center">9.7</td><td style="text-align:center">10.86</td><td style="text-align:center">12.18</td></tr><tr><td style="text-align:center">10</td><td style="text-align:center">6.53</td><td style="text-align:center">7.23</td><td style="text-align:center">8.03</td><td style="text-align:center">8.94</td><td style="text-align:center">9.98</td><td style="text-align:center">11.16</td><td style="text-align:center">12.52</td></tr><tr><td style="text-align:center">11</td><td style="text-align:center">6.71</td><td style="text-align:center">7.43</td><td style="text-align:center">8.25</td><td style="text-align:center">9.18</td><td style="text-align:center">10.24</td><td style="text-align:center">11.46</td><td style="text-align:center">12.85</td></tr><tr><td style="text-align:center">12</td><td style="text-align:center">6.87</td><td style="text-align:center">7.61</td><td style="text-align:center">8.45</td><td style="text-align:center">9.4</td><td style="text-align:center">10.48</td><td style="text-align:center">11.73</td><td style="text-align:center">13.15</td></tr><tr><td style="text-align:center">15</td><td style="text-align:center">7.34</td><td style="text-align:center">8.12</td><td style="text-align:center">9.01</td><td style="text-align:center">10.02</td><td style="text-align:center">11.18</td><td style="text-align:center">12.5</td><td style="text-align:center">14.02</td></tr><tr><td style="text-align:center">18</td><td style="text-align:center">7.79</td><td style="text-align:center">8.63</td><td style="text-align:center">9.57</td><td style="text-align:center">10.65</td><td style="text-align:center">11.88</td><td style="text-align:center">13.29</td><td style="text-align:center">14.9</td></tr><tr><td style="text-align:center">21</td><td style="text-align:center">8.26</td><td style="text-align:center">9.15</td><td style="text-align:center">10.15</td><td style="text-align:center">11.3</td><td style="text-align:center">12.61</td><td style="text-align:center">14.12</td><td style="text-align:center">15.85</td></tr><tr><td style="text-align:center">24</td><td style="text-align:center">8.7</td><td style="text-align:center">9.64</td><td style="text-align:center">10.7</td><td style="text-align:center">11.92</td><td style="text-align:center">13.31</td><td style="text-align:center">14.92</td><td style="text-align:center">16.77</td></tr><tr><td style="text-align:center">27</td><td style="text-align:center">9.1</td><td style="text-align:center">10.09</td><td style="text-align:center">11.21</td><td style="text-align:center">12.5</td><td style="text-align:center">13.97</td><td style="text-align:center">15.67</td><td style="text-align:center">17.63</td></tr><tr><td style="text-align:center">30</td><td style="text-align:center">9.48</td><td style="text-align:center">10.52</td><td style="text-align:center">11.7</td><td style="text-align:center">13.05</td><td style="text-align:center">14.6</td><td style="text-align:center">16.39</td><td style="text-align:center">18.47</td></tr><tr><td style="text-align:center">33</td><td style="text-align:center">9.86</td><td style="text-align:center">10.94</td><td style="text-align:center">12.18</td><td style="text-align:center">13.59</td><td style="text-align:center">15.22</td><td style="text-align:center">17.11</td><td style="text-align:center">19.29</td></tr><tr><td style="text-align:center">36</td><td style="text-align:center">10.23</td><td style="text-align:center">11.36</td><td style="text-align:center">12.65</td><td style="text-align:center">14.13</td><td style="text-align:center">15.83</td><td style="text-align:center">17.81</td><td style="text-align:center">20.1</td></tr><tr><td style="text-align:center">39</td><td style="text-align:center">10.6</td><td style="text-align:center">11.77</td><td style="text-align:center">13.11</td><td style="text-align:center">14.65</td><td style="text-align:center">16.43</td><td style="text-align:center">18.5</td><td style="text-align:center">20.9</td></tr><tr><td style="text-align:center">42</td><td style="text-align:center">10.95</td><td style="text-align:center">12.16</td><td style="text-align:center">13.55</td><td style="text-align:center">15.16</td><td style="text-align:center">17.01</td><td style="text-align:center">19.17</td><td style="text-align:center">21.69</td></tr><tr><td style="text-align:center">45</td><td style="text-align:center">11.29</td><td style="text-align:center">12.55</td><td style="text-align:center">14</td><td style="text-align:center">15.67</td><td style="text-align:center">17.6</td><td style="text-align:center">19.85</td><td style="text-align:center">22.49</td></tr><tr><td style="text-align:center">48</td><td style="text-align:center">11.62</td><td style="text-align:center">12.93</td><td style="text-align:center">14.44</td><td style="text-align:center">16.17</td><td style="text-align:center">18.19</td><td style="text-align:center">20.54</td><td style="text-align:center">23.3</td></tr><tr><td style="text-align:center">51</td><td style="text-align:center">11.96</td><td style="text-align:center">13.32</td><td style="text-align:center">14.88</td><td style="text-align:center">16.69</td><td style="text-align:center">18.79</td><td style="text-align:center">21.25</td><td style="text-align:center">24.14</td></tr><tr><td style="text-align:center">54</td><td style="text-align:center">12.3</td><td style="text-align:center">13.71</td><td style="text-align:center">15.33</td><td style="text-align:center">17.22</td><td style="text-align:center">19.42</td><td style="text-align:center">22</td><td style="text-align:center">25.04</td></tr><tr><td style="text-align:center">57</td><td style="text-align:center">12.62</td><td style="text-align:center">14.08</td><td style="text-align:center">15.78</td><td style="text-align:center">17.75</td><td style="text-align:center">20.05</td><td style="text-align:center">22.75</td><td style="text-align:center">25.96</td></tr><tr><td style="text-align:center">60</td><td style="text-align:center">12.93</td><td style="text-align:center">14.44</td><td style="text-align:center">16.2</td><td style="text-align:center">18.26</td><td style="text-align:center">20.66</td><td style="text-align:center">23.5</td><td style="text-align:center">26.87</td></tr><tr><td style="text-align:center">63</td><td style="text-align:center">13.23</td><td style="text-align:center">14.8</td><td style="text-align:center">16.64</td><td style="text-align:center">18.78</td><td style="text-align:center">21.3</td><td style="text-align:center">24.28</td><td style="text-align:center">27.84</td></tr><tr><td style="text-align:center">66</td><td style="text-align:center">13.54</td><td style="text-align:center">15.18</td><td style="text-align:center">17.09</td><td style="text-align:center">19.33</td><td style="text-align:center">21.98</td><td style="text-align:center">25.12</td><td style="text-align:center">28.89</td></tr><tr><td style="text-align:center">69</td><td style="text-align:center">13.84</td><td style="text-align:center">15.54</td><td style="text-align:center">17.53</td><td style="text-align:center">19.88</td><td style="text-align:center">22.65</td><td style="text-align:center">25.96</td><td style="text-align:center">29.95</td></tr><tr><td style="text-align:center">72</td><td style="text-align:center">14.11</td><td style="text-align:center">15.87</td><td style="text-align:center">17.94</td><td style="text-align:center">20.37</td><td style="text-align:center">23.27</td><td style="text-align:center">26.74</td><td style="text-align:center">30.94</td></tr><tr><td style="text-align:center">75</td><td style="text-align:center">14.38</td><td style="text-align:center">16.21</td><td style="text-align:center">18.35</td><td style="text-align:center">20.89</td><td style="text-align:center">23.92</td><td style="text-align:center">27.57</td><td style="text-align:center">32</td></tr><tr><td style="text-align:center">78</td><td style="text-align:center">14.66</td><td style="text-align:center">16.55</td><td style="text-align:center">18.78</td><td style="text-align:center">21.44</td><td style="text-align:center">24.61</td><td style="text-align:center">28.46</td><td style="text-align:center">33.14</td></tr><tr><td style="text-align:center">81</td><td style="text-align:center">14.96</td><td style="text-align:center">16.92</td><td style="text-align:center">19.25</td><td style="text-align:center">22.03</td><td style="text-align:center">25.37</td><td style="text-align:center">29.42</td><td style="text-align:center">34.4</td></tr></tbody></table><h2 id="女孩身高标准表"><a href="#女孩身高标准表" class="headerlink" title="女孩身高标准表"></a>女孩身高标准表</h2><table><thead><tr><th style="text-align:center">月龄</th><th style="text-align:center">-3SD（矮）</th><th style="text-align:center">-2SD（偏矮）</th><th style="text-align:center">-1SD（正常）</th><th style="text-align:center">中位数（正常）</th><th style="text-align:center">+1SD（正常）</th><th style="text-align:center">+2SD（偏高）</th><th style="text-align:center">+3SD（高）</th></tr></thead><tbody><tr><td style="text-align:center">0</td><td style="text-align:center">44.7</td><td style="text-align:center">46.4</td><td style="text-align:center">48</td><td style="text-align:center">49.7</td><td style="text-align:center">51.4</td><td style="text-align:center">53.2</td><td style="text-align:center">55</td></tr><tr><td style="text-align:center">1</td><td style="text-align:center">47.9</td><td style="text-align:center">49.8</td><td style="text-align:center">51.7</td><td style="text-align:center">53.7</td><td style="text-align:center">55.7</td><td style="text-align:center">57.8</td><td style="text-align:center">59.9</td></tr><tr><td style="text-align:center">2</td><td style="text-align:center">51.1</td><td style="text-align:center">53.2</td><td style="text-align:center">55.3</td><td style="text-align:center">57.4</td><td style="text-align:center">59.6</td><td style="text-align:center">61.8</td><td style="text-align:center">64.1</td></tr><tr><td style="text-align:center">3</td><td style="text-align:center">54.2</td><td style="text-align:center">56.3</td><td style="text-align:center">58.4</td><td style="text-align:center">60.6</td><td style="text-align:center">62.8</td><td style="text-align:center">65.1</td><td style="text-align:center">67.5</td></tr><tr><td style="text-align:center">4</td><td style="text-align:center">56.7</td><td style="text-align:center">58.8</td><td style="text-align:center">61</td><td style="text-align:center">63.1</td><td style="text-align:center">65.4</td><td style="text-align:center">67.7</td><td style="text-align:center">70</td></tr><tr><td style="text-align:center">5</td><td style="text-align:center">58.6</td><td style="text-align:center">60.8</td><td style="text-align:center">62.9</td><td style="text-align:center">65.2</td><td style="text-align:center">67.4</td><td style="text-align:center">69.8</td><td style="text-align:center">72.1</td></tr><tr><td style="text-align:center">6</td><td style="text-align:center">60.1</td><td style="text-align:center">62.3</td><td style="text-align:center">64.5</td><td style="text-align:center">66.8</td><td style="text-align:center">69.1</td><td style="text-align:center">71.5</td><td style="text-align:center">74</td></tr><tr><td style="text-align:center">7</td><td style="text-align:center">61.3</td><td style="text-align:center">63.6</td><td style="text-align:center">65.9</td><td style="text-align:center">68.2</td><td style="text-align:center">70.6</td><td style="text-align:center">73.1</td><td style="text-align:center">75.6</td></tr><tr><td style="text-align:center">8</td><td style="text-align:center">62.5</td><td style="text-align:center">64.8</td><td style="text-align:center">67.2</td><td style="text-align:center">69.6</td><td style="text-align:center">72.1</td><td style="text-align:center">74.7</td><td style="text-align:center">77.3</td></tr><tr><td style="text-align:center">9</td><td style="text-align:center">63.7</td><td style="text-align:center">66.1</td><td style="text-align:center">68.5</td><td style="text-align:center">71</td><td style="text-align:center">73.6</td><td style="text-align:center">76.2</td><td style="text-align:center">78.9</td></tr><tr><td style="text-align:center">10</td><td style="text-align:center">64.9</td><td style="text-align:center">67.3</td><td style="text-align:center">69.8</td><td style="text-align:center">72.4</td><td style="text-align:center">75</td><td style="text-align:center">77.7</td><td style="text-align:center">80.5</td></tr><tr><td style="text-align:center">11</td><td style="text-align:center">66.1</td><td style="text-align:center">68.6</td><td style="text-align:center">71.1</td><td style="text-align:center">73.7</td><td style="text-align:center">76.4</td><td style="text-align:center">79.2</td><td style="text-align:center">82</td></tr><tr><td style="text-align:center">12</td><td style="text-align:center">67.2</td><td style="text-align:center">69.7</td><td style="text-align:center">72.3</td><td style="text-align:center">75</td><td style="text-align:center">77.7</td><td style="text-align:center">80.5</td><td style="text-align:center">83.4</td></tr><tr><td style="text-align:center">15</td><td style="text-align:center">70.2</td><td style="text-align:center">72.9</td><td style="text-align:center">75.6</td><td style="text-align:center">78.5</td><td style="text-align:center">81.4</td><td style="text-align:center">84.3</td><td style="text-align:center">87.4</td></tr><tr><td style="text-align:center">18</td><td style="text-align:center">72.8</td><td style="text-align:center">75.6</td><td style="text-align:center">78.5</td><td style="text-align:center">81.5</td><td style="text-align:center">84.6</td><td style="text-align:center">87.7</td><td style="text-align:center">91</td></tr><tr><td style="text-align:center">21</td><td style="text-align:center">75.1</td><td style="text-align:center">78.1</td><td style="text-align:center">81.2</td><td style="text-align:center">84.4</td><td style="text-align:center">87.7</td><td style="text-align:center">91.1</td><td style="text-align:center">94.5</td></tr><tr><td style="text-align:center">24</td><td style="text-align:center">77.3</td><td style="text-align:center">80.5</td><td style="text-align:center">83.8</td><td style="text-align:center">87.2</td><td style="text-align:center">90.7</td><td style="text-align:center">94.3</td><td style="text-align:center">98</td></tr><tr><td style="text-align:center">27</td><td style="text-align:center">79.3</td><td style="text-align:center">82.7</td><td style="text-align:center">86.2</td><td style="text-align:center">89.8</td><td style="text-align:center">93.5</td><td style="text-align:center">97.3</td><td style="text-align:center">101.2</td></tr><tr><td style="text-align:center">30</td><td style="text-align:center">81.4</td><td style="text-align:center">84.8</td><td style="text-align:center">88.4</td><td style="text-align:center">92.1</td><td style="text-align:center">95.9</td><td style="text-align:center">99.8</td><td style="text-align:center">103.8</td></tr><tr><td style="text-align:center">33</td><td style="text-align:center">83.4</td><td style="text-align:center">86.9</td><td style="text-align:center">90.5</td><td style="text-align:center">94.3</td><td style="text-align:center">98.1</td><td style="text-align:center">102</td><td style="text-align:center">106.1</td></tr><tr><td style="text-align:center">36</td><td style="text-align:center">85.4</td><td style="text-align:center">88.9</td><td style="text-align:center">92.5</td><td style="text-align:center">96.3</td><td style="text-align:center">100.1</td><td style="text-align:center">104.1</td><td style="text-align:center">108.1</td></tr><tr><td style="text-align:center">39</td><td style="text-align:center">86.6</td><td style="text-align:center">90.1</td><td style="text-align:center">93.8</td><td style="text-align:center">97.5</td><td style="text-align:center">101.4</td><td style="text-align:center">105.4</td><td style="text-align:center">109.4</td></tr><tr><td style="text-align:center">42</td><td style="text-align:center">88.4</td><td style="text-align:center">91.9</td><td style="text-align:center">95.6</td><td style="text-align:center">99.4</td><td style="text-align:center">103.3</td><td style="text-align:center">107.2</td><td style="text-align:center">111.3</td></tr><tr><td style="text-align:center">45</td><td style="text-align:center">90.1</td><td style="text-align:center">93.7</td><td style="text-align:center">97.4</td><td style="text-align:center">101.2</td><td style="text-align:center">105.1</td><td style="text-align:center">109.2</td><td style="text-align:center">113.3</td></tr><tr><td style="text-align:center">48</td><td style="text-align:center">91.7</td><td style="text-align:center">95.4</td><td style="text-align:center">99.2</td><td style="text-align:center">103.1</td><td style="text-align:center">107</td><td style="text-align:center">111.1</td><td style="text-align:center">115.3</td></tr><tr><td style="text-align:center">51</td><td style="text-align:center">93.2</td><td style="text-align:center">97</td><td style="text-align:center">100.9</td><td style="text-align:center">104.9</td><td style="text-align:center">109</td><td style="text-align:center">113.1</td><td style="text-align:center">117.4</td></tr><tr><td style="text-align:center">54</td><td style="text-align:center">94.8</td><td style="text-align:center">98.7</td><td style="text-align:center">102.7</td><td style="text-align:center">106.7</td><td style="text-align:center">110.9</td><td style="text-align:center">115.2</td><td style="text-align:center">119.5</td></tr><tr><td style="text-align:center">57</td><td style="text-align:center">96.4</td><td style="text-align:center">100.3</td><td style="text-align:center">104.4</td><td style="text-align:center">108.5</td><td style="text-align:center">112.8</td><td style="text-align:center">117.1</td><td style="text-align:center">121.6</td></tr><tr><td style="text-align:center">60</td><td style="text-align:center">97.8</td><td style="text-align:center">101.8</td><td style="text-align:center">106</td><td style="text-align:center">110.2</td><td style="text-align:center">114.5</td><td style="text-align:center">118.9</td><td style="text-align:center">123.4</td></tr><tr><td style="text-align:center">63</td><td style="text-align:center">99.3</td><td style="text-align:center">103.4</td><td style="text-align:center">107.6</td><td style="text-align:center">111.9</td><td style="text-align:center">116.2</td><td style="text-align:center">120.7</td><td style="text-align:center">125.3</td></tr><tr><td style="text-align:center">66</td><td style="text-align:center">100.7</td><td style="text-align:center">104.9</td><td style="text-align:center">109.2</td><td style="text-align:center">113.5</td><td style="text-align:center">118</td><td style="text-align:center">122.6</td><td style="text-align:center">127.2</td></tr><tr><td style="text-align:center">69</td><td style="text-align:center">102</td><td style="text-align:center">106.3</td><td style="text-align:center">110.7</td><td style="text-align:center">115.2</td><td style="text-align:center">119.7</td><td style="text-align:center">124.4</td><td style="text-align:center">129.1</td></tr><tr><td style="text-align:center">72</td><td style="text-align:center">103.2</td><td style="text-align:center">107.6</td><td style="text-align:center">112</td><td style="text-align:center">116.6</td><td style="text-align:center">121.2</td><td style="text-align:center">126</td><td style="text-align:center">130.8</td></tr><tr><td style="text-align:center">75</td><td style="text-align:center">104.4</td><td style="text-align:center">108.8</td><td style="text-align:center">113.4</td><td style="text-align:center">118</td><td style="text-align:center">122.7</td><td style="text-align:center">127.6</td><td style="text-align:center">132.5</td></tr><tr><td style="text-align:center">78</td><td style="text-align:center">105.5</td><td style="text-align:center">110.1</td><td style="text-align:center">114.7</td><td style="text-align:center">119.4</td><td style="text-align:center">124.3</td><td style="text-align:center">129.2</td><td style="text-align:center">134.2</td></tr><tr><td style="text-align:center">81</td><td style="text-align:center">106.7</td><td style="text-align:center">111.4</td><td style="text-align:center">116.1</td><td style="text-align:center">121</td><td style="text-align:center">125.9</td><td style="text-align:center">130.9</td><td style="text-align:center">136.1</td></tr></tbody></table><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="http://www.yoonper.com/post.php?id=109" target="_blank" rel="noopener">中国婴幼儿身高体重参照表</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今天在一位技术博主的网站看到了他整理的这个表格，我也存过来备用一下吧。&lt;/p&gt;
    
    </summary>
    
      <category term="孩子" scheme="https://michael728.github.io/categories/%E5%AD%A9%E5%AD%90/"/>
    
    
      <category term="资源" scheme="https://michael728.github.io/tags/%E8%B5%84%E6%BA%90/"/>
    
      <category term="Blog" scheme="https://michael728.github.io/tags/Blog/"/>
    
      <category term="博客" scheme="https://michael728.github.io/tags/%E5%8D%9A%E5%AE%A2/"/>
    
      <category term="List" scheme="https://michael728.github.io/tags/List/"/>
    
  </entry>
  
  <entry>
    <title>Java 泛型知识笔记</title>
    <link href="https://michael728.github.io/2020/07/13/java-basic-generic/"/>
    <id>https://michael728.github.io/2020/07/13/java-basic-generic/</id>
    <published>2020-07-13T12:49:10.000Z</published>
    <updated>2021-02-12T13:27:05.289Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://gitee.com/michael_xiang/images/raw/master/uPic/pastries-756601_640.jpg" alt="pastries-模板"></p><h2 id="泛型概念"><a href="#泛型概念" class="headerlink" title="泛型概念"></a>泛型概念</h2><p>泛型（ <code>Generic</code>）是一种编译器机制，您可通过该机制获取通用的代码并参数化（或模板化）剩余部分，从而以一种一般化方式创建（和使用）一些类型的实体（比如类或接口和方法）。这种编程方法被称为泛型编程。</p><p>所谓泛型，就是允许在定义类、接口、方法时使用类型形参，这个类型形参(或叫泛型)将在声明变量、创建对象、调用方法时动态地指定(即传入实际的类型参数，也可以称为「类型实参」)。</p><a id="more"></a><p>JDK 5.0（2004 年发布）向 Java 语言中引入了泛型类型（泛型）和关联的语法。增加泛型支持，很大程度上都是为了让集合能记住其元素的数据类型。在没有泛型之前，一旦把一个对象「丢进」 Java 集合中，集合就会忘记对象的类型，把所有的对象当成 Object 类型处理。当程序从集合中取出对象后，就需要进行强制类型的转换。这种强制类型转换不仅使代码臃肿，还很容器引起 <code>ClassCastException</code> 错误。</p><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p>先通过一个简单的示例了解一下泛型是什么样的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">List strList = <span class="keyword">new</span> ArrayList();</span><br><span class="line">strList.add(<span class="string">"Name"</span>);</span><br><span class="line">strList.add(<span class="string">"Aget"</span>);</span><br><span class="line"><span class="comment">// 不小心存入一个 Integer 对象</span></span><br><span class="line">strList.add(<span class="keyword">new</span> Integer(<span class="number">1</span>));</span><br><span class="line"><span class="comment">//ArrayList可以存放任意类型，所以，下一行执行，并不会报错</span></span><br><span class="line">System.out.println(strList);</span><br><span class="line"><span class="comment">//这一行强转就出错了</span></span><br><span class="line">String str = (String)strList.get(<span class="number">2</span>);</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[Name, Aget, <span class="number">1</span>]</span><br><span class="line">Exception in thread <span class="string">"main"</span> java.lang.ClassCastException: java.lang.Integer cannot be cast to java.lang.String</span><br><span class="line">at main.main(main.java:<span class="number">14</span>)</span><br><span class="line"></span><br><span class="line">Process finished with exit code <span class="number">1</span></span><br></pre></td></tr></table></figure><p>可以看到，我们 在给 List 中元素包含了两种类型：String 和 Interger 类型。 在 JDK 5.0 之前，Java 语言对此行为没有任何约束，这导致了许多编码错误。因为不知道 List 中包含的内容，则必须检查想要访问的元素，查看是否能处理这种类型的元素，否则可能会遇到 <code>ClassCastException</code>。</p><p>借助泛型，可以事先指定 List 中的元素类型，这样编译器在编译阶段就能够发现上面的问题：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; strList = <span class="keyword">new</span> ArrayList();</span><br><span class="line">strList.add(<span class="string">"Name"</span>);</span><br><span class="line">strList.add(<span class="string">"Aget"</span>);</span><br><span class="line"><span class="comment">// 下面这一行编辑器就会提示错误，编译就不会通过</span></span><br><span class="line">strList.add(<span class="keyword">new</span> Integer(<span class="number">1</span>));</span><br><span class="line">System.out.println(strList);</span><br><span class="line">String str = (String)strList.get(<span class="number">2</span>);</span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2019/07/13/5d29407987abd35714.jpg" alt="Jietu20190713-102223-listerror.jpg"></p><p>从 Java 5 之后，Java 引入了「参数化类型」(<code>parameterized type</code>)的概念。允许程序在创建集合时指定集合元素的类型。Java 的参数化类型被称为「泛型」(<code>Generic</code>)。</p><p>上面的 <code>List&lt;String&gt;</code>，可以称 List 是带一个类型参数的泛型接口，类型参数（类型实参）是 <code>Sting</code>。集合记住了所有元素的数据类型，从而无须对集合元素进行数据类型转换。</p><p>在 Java 7 之前，如果使用带有泛型的接口、类定义变量，那么调用构造器创建对象时，构造器的构面也要带上泛型：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; strList = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br></pre></td></tr></table></figure><p>从  Java7 开始， Java 允许在构造器后不需要带完整的泛型信息，只需要给出尖括号即可，Java 可以自动推断出尖括号里的是什么泛型信息：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; strList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br></pre></td></tr></table></figure><h2 id="常见的-T，E，K，V，？"><a href="#常见的-T，E，K，V，？" class="headerlink" title="常见的 T，E，K，V，？"></a>常见的 T，E，K，V，？</h2><p>本质上这些个都是通配符，没啥区别，只不过是编码时的一种约定俗成的东西。比如上述代码中的 T ，我们可以换成 A-Z 之间的任何一个 字母都可以，并不会影响程序的正常运行，但是如果换成其他的字母代替 T ，在可读性上可能会弱一些。通常情况下，T，E，K，V，？ 是这样约定的：</p><ul><li>？ 表示不确定的 java 类型</li><li>T (type) 表示具体的一个java类型</li><li>K V (key value) 分别代表java键值中的Key Value</li><li>E (element) 代表Element</li></ul><h2 id="泛型的应用"><a href="#泛型的应用" class="headerlink" title="泛型的应用"></a>泛型的应用</h2><p>泛型有三种使用方式：</p><ol><li>泛型类</li><li>泛型接口</li><li>泛型方法</li></ol><h3 id="泛型类"><a href="#泛型类" class="headerlink" title="泛型类"></a>泛型类</h3><p>泛型类型用于类的定义中，这个类称为「泛型类」。最典型的泛型类就是各种容器类，例如：List、Set、Map。</p><p>泛型类的定义语法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> 类名称&lt;泛型标识&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> 泛型标识 成员变量；</span><br><span class="line">    ……</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>泛型标识：可以随便写任意标识号，标识指定的泛型的类型，比如常用的 <code>T</code></li></ul><p>举个栗子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 泛型类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Card</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> T id;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">getId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setId</span><span class="params">(T id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Card</span><span class="params">(T id)</span></span>&#123;</span><br><span class="line">        setId(id);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// main 函数</span></span><br><span class="line">Card&lt;String&gt; card1 = <span class="keyword">new</span> Card&lt;&gt;(<span class="string">"One"</span>);</span><br><span class="line">System.out.println(<span class="string">"card1 id is: "</span>+card1.getId());</span><br><span class="line"></span><br><span class="line">Card&lt;Integer&gt; card2 = <span class="keyword">new</span> Card&lt;&gt;(<span class="number">2</span>);</span><br><span class="line">System.out.println(<span class="string">"card2 id is: "</span>+card2.getId());</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出</span></span><br><span class="line">card1 id is: One</span><br><span class="line">card2 id is: <span class="number">2</span></span><br></pre></td></tr></table></figure><p>怎么样，看到区别了吗？同样一个类创建的两个实例，成员变量名都是 <code>id</code>，但是二者的类型却可以不同。<code>T</code> 感觉有种 <code>template</code> 的意思，模板嘛，占坑渲染即可。</p><p>定义的泛型类实例化对象时并不一定要春如泛型类型实参。比如一开始的例子 <code>ArrayList</code>，当不传入泛型类型实参时，默认的就是 <code>Object</code> 类型。这时候，就不会起到限制类型的作用了。</p><p>注意点：</p><ol><li>泛型的类型参数只能是「类类型」，不能是原始类型（<code>Primitive Type</code>）——byte/short/ int/long/float/ double/ boolean/char</li><li>定义泛型类中的构造器时，构造器名还是原来的类型，不需要增加泛型声明。</li><li>不能对确切的泛型类型使用 <code>instanceof</code>操作，比如 <code>card1 instanceof Card&lt;String&gt;</code>，会报 <code>instanceof 的泛型类型不合法</code> 错误，但是 <code>card1 instance Card</code> 是不会报错的，并返回 <code>true</code>。因为不管泛型的实际类型参数是什么，他们在运行时总有同样的类，对于 Java 来说，它们依然被当成同一个类处理，在内存中也只占用一块内存空间。</li></ol><p><code>List&lt;Integer&gt;</code> 并不是 <code>List&lt;Number&gt;</code> 的子类！<br><code>List&lt;Integer&gt;</code> 并不是 <code>List&lt;Number&gt;</code> 的子类！<br><code>List&lt;Integer&gt;</code> 并不是 <code>List&lt;Number&gt;</code> 的子类！</p><h3 id="泛型接口"><a href="#泛型接口" class="headerlink" title="泛型接口"></a>泛型接口</h3><p>泛型接口和泛型类的定义语法差不多。泛型接口经常被用在各种类的生成器中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义泛型接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Generaotr</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">next</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>泛型接口实现类，未传入泛型实参时：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FruitGenerator</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">Generaotr</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">// 这个 Override 可不能少</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">next</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接口实现类定义时，也需要将泛型的声明加上。如果不加，例如<code>public class FruitGenerator implements Generaotr&lt;T&gt;</code>，这样就会报错，<code>cannot resolve symbol T</code>。</p><p>泛型接口实现类，传入泛型实参，比如 <code>String</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FruitGenerator</span> <span class="keyword">implements</span> <span class="title">Generaotr</span>&lt;<span class="title">String</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String[] fruits = <span class="keyword">new</span> String[]&#123;<span class="string">"Apple"</span>, <span class="string">"Banana"</span>, <span class="string">"Pear"</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">next</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Random rand = <span class="keyword">new</span> Random();</span><br><span class="line">        <span class="keyword">return</span> fruits[rand.nextInt(<span class="number">3</span>)];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里我们传入了泛型实参，接口实现类中的泛型都改为了这个传入的实参。并且，此时，接口实行类就不用加上泛型声明了，加入的话，反而会提示 <code>attempting to use incompatible return type</code>错误。</p><h3 id="泛型通配符"><a href="#泛型通配符" class="headerlink" title="泛型通配符"></a>泛型通配符</h3><p><code>Integer</code> 是 <code>Number</code> 的一个子类。那么，在使用 <code>Card&lt;Numer&gt;</code> 作为方法形参的方法中，是否可以传入 <code>Card&lt;Interger&gt;</code> 的实参呢？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">showKeyValue1</span><span class="params">(Card&lt;Number&gt; card)</span></span>&#123;</span><br><span class="line">    System.out.println(card.getId());</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 测试</span></span><br><span class="line">Card&lt;Integer&gt; card2 = <span class="keyword">new</span> Card&lt;&gt;(<span class="number">2</span>);</span><br><span class="line">System.out.println(<span class="string">"card2 id is: "</span> + card2.getId());</span><br><span class="line"></span><br><span class="line">showKeyValue1(card2);</span><br></pre></td></tr></table></figure><p>编译器会报错 ：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Generic&lt;java.lang.Integer&gt; cannot be applied to Card&lt;java.lang.Number&gt;</span><br></pre></td></tr></table></figure><p>通过提示信息我们可以看到 <code>Card&lt;Integer&gt;</code> 不能被看作为 <code>Card&lt;Number&gt;</code> 的子类。</p><div class="note warning no-icon">            <p>如果 Apple 是 Fruit 的一个子类型（子类或者子接口），G 是一个具有泛型声明的类或接口，<code>G&lt;Apple&gt;</code> 并不是 <code>G&lt;Fruit&gt;</code> 的子类型！这一点值得注意，因为与大部分人第一感觉是不同的。</p>          </div><p>如何解决上面的问题呢？</p><p>我们需要在逻辑上引入一个同时是 <code>Card&lt;Number&gt;</code> 和 <code>Card&lt;Interger</code> 父类的引用类型。由此，「类型通配符」产生了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 其实，这里不用通配符，直接是 Card 也会 OK</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">showKeyValue1</span><span class="params">(Card&lt;?&gt; card)</span></span>&#123;</span><br><span class="line">    System.out.println(card.getId());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>类型通配符一般是使用 <code>?</code> 代替具体的类型实参。注意，<code>?</code> 是类型实参，不是类型形参。简单理解，这里的 <code>?</code> 就和 <code>Number</code>、<code>String</code> 一样，都是一种实际的类型。可以把 <code>?</code> 看成所有类型的父亲，是一种真实的类型，当成 Object 来处理。</p><h4 id="通配符上界"><a href="#通配符上界" class="headerlink" title="通配符上界"></a>通配符上界</h4><p>为了表示限制类型，泛型提供了被限制的通配符。通配符上界使用 <code>&lt;? extends T&gt;</code> 的格式，意思是需要一个 T 类型或者 T 类型的子类，一般T 类型都是一个具体的类型。示例如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">printIntValue</span><span class="params">(List&lt;? extends Number&gt; list)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (Number number : list) &#123;</span><br><span class="line">        System.out.print(number.intValue()+<span class="string">" "</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此处，未知类型一定是 <code>Number</code> 的子类型，因此，可以把 <code>Number</code> 称为这个通配符的上界(<code>upper bnound</code>)。</p><p>写入操作过以上给定的赋值语句，你能把一个什么类型的元素合法地插入到 list 中呢？</p><ul><li>你不能插入一个 Integer 元素，因为 list 可能指向 <code>List&lt;Double&gt;</code>。</li><li>你不能插入一个 Double 元素，因为 list 可能指向 <code>List&lt;Integer&gt;</code>。</li><li>你不能插入一个 Number 元素，因为 list 可能指向 <code>List&lt;Integer&gt;</code>。</li></ul><p>你不能往 <code>List&lt;? extends T&gt;</code> 中插入任何类型的对象，因为你不能保证列表实际指向的类型是什么，你并不能保证列表中实际存储什么类型的对象。唯一可以保证的是，你可以从中读取到 T 或者 T 的子类。</p><h4 id="通配符下界"><a href="#通配符下界" class="headerlink" title="通配符下界"></a>通配符下界</h4><p>除了可以指定通配符的上限之外，Java 还允许指定通配符的下限。通配符下界使用 <code>&lt;? super T&gt;</code> 的格式，意思是需要一个T类型或者 T 类型的父类，一般 T 类型都是一个具体的类型。示例如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fillNumberList</span><span class="params">(List&lt;? <span class="keyword">super</span> Number&gt; list)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Number 及它子类的实例就可以加入 list 中</span></span><br><span class="line">    list.add(<span class="keyword">new</span> Integer(<span class="number">0</span>));</span><br><span class="line">    list.add(<span class="keyword">new</span> Float(<span class="number">1.0</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其实，Java 泛型不仅允许在使用通配符形参时设定上限，还可以在定义泛型形参时设定上限，用以表示传给泛型形参的实际参数类型要么是该上限类型，要么是该上限类型的子类。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Apple</span>&lt;<span class="title">T</span> <span class="keyword">extends</span> <span class="title">Number</span>&gt; </span>&#123;</span><br><span class="line">    T col;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Apple&lt;Integer&gt; ai = <span class="keyword">new</span> Apple&lt;&gt;();</span><br><span class="line">        Apple&lt;Double&gt; ad = <span class="keyword">new</span> Apple&lt;&gt;();</span><br><span class="line">        <span class="comment">// 下面编译就会出错，因为设置了上限是 Number</span></span><br><span class="line">        Apple&lt;String&gt; as = <span class="keyword">new</span> Apple&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2019/07/13/5d294c385b14039332.jpg" alt="Jietu20190713-111233-bound.jpg"></p><h4 id="总结-PECS"><a href="#总结-PECS" class="headerlink" title="总结 PECS"></a>总结 PECS</h4><div class="note success no-icon">            <p>上面的知识点可以概括为 PECS 原则，方便记忆。</p><ul><li>Producer 生产者，则用 extends。因为你想从列表中获取 T 类型的的元素。看着就像是「生产」元素的效果。不能明确存入元素的类型，因此它的主要总用不在「存」。</li><li>Conumer 消费者，则用 super。想把 T 类型的子元素放入到列表中。不能保证明确读取到的元素的类型，因此它的主要作用不在于「读」。</li></ul>          </div><p>详细理解这里的 PECS 原则，还可以阅读：</p><ul><li><a href="https://www.zhihu.com/question/20400700/answer/117464182" target="_blank" rel="noopener">知乎/Java 泛型 &lt;? super T&gt; 中 super 怎么 理解？与 extends 有何不同？</a>。</li><li><a href="http://ifeve.com/difference-between-super-t-and-extends-t-in-java/" target="_blank" rel="noopener">并发编程网/泛型中? super T和? extends T的区别</a> <a href="https://stackoverflow.com/questions/4343202/difference-between-super-t-and-extends-t-in-java" target="_blank" rel="noopener">原文 URL</a></li></ul><h3 id="泛型方法"><a href="#泛型方法" class="headerlink" title="泛型方法"></a>泛型方法</h3><p>在一些情况下，定义类、接口时没有使用泛型形参，但定义方法时想自己定义泛型形参，这也是可以的。Java 5 提供了对泛型方法的支持。</p><p>判断一个方法是否是泛型方法关键看方法返回值前面有没有使用 <code>&lt;&gt;</code> 标记的类型，有就是，没有就不是。</p><p>假设需要实现这样一个方法：将一个 Object 数组所有的元素添加到一个 Collection 集合中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">fromArrayToCollection</span><span class="params">(Object[] a, Collection&lt;Object&gt; c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (Object o : a) &#123;</span><br><span class="line">        c.add(o);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面这么写将会引起编译错误：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">String[] strArr = &#123;<span class="string">"a"</span>,<span class="string">"b"</span>&#125;;</span><br><span class="line">List&lt;String&gt; strList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"><span class="comment">// Collection&lt;String&gt;对象不能当成 Collection&lt;Oject&gt;使用</span></span><br><span class="line">fromArrayToCollection(strArr, strList);</span><br><span class="line">System.out.println(strList);</span><br></pre></td></tr></table></figure><p><code>Collection&lt;String&gt;</code> 并不是 <code>Collection&lt;Object&gt;</code> 的子类型，所以上面这个方法只能将 <code>Object[]</code> 数组中的元素复制到元素为 <code>Object</code> 的 Collection 集合中。</p><p><code>Collection&lt;Object&gt; c</code> 改为通配符 <code>Collection&lt;?&gt; c</code> 是否可行呢？也不行。</p><p>为了解决上面这个问题，可以使用泛型方法(<code>Generic Method</code>)。所谓泛型方法，就是在声明方法时，定义一个或多个泛型形参。多个泛型形参声明放在方法修饰符和方法返回值类型之间。泛型方法语法格式如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">修饰符 &lt;T,S,...&gt; 返回值类型 方法名(形参列表)&#123;</span><br><span class="line">    <span class="comment">// 方法体</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的方法改进如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">fromArrayToCollection</span><span class="params">(T[] a, Collection&lt;T&gt; c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (T o : a) &#123;</span><br><span class="line">        c.add(o);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>与泛型类和泛型接口的使用不同，泛型方法中的泛型形参不需要显示传入实际参数类型。编译器会根据实参推断泛型所代表的类型。但是小心，避免制造迷惑。比如下面的栗子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        List&lt;String&gt; as = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        List&lt;Object&gt; ao = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 下面会编译错误</span></span><br><span class="line">        test(as, ao);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">(Collection&lt;T&gt; from, Collection&lt;T&gt; to)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (T ele : from) &#123;</span><br><span class="line">            to.add(ele);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2019/07/13/5d295bf0741a761687.jpg" alt="Jietu20190713-121930-method-error.jpg"></p><p><code>test</code> 方法传入两个实参，<code>ao</code> 的数据类型是 <code>List&lt;Object&gt;</code>，而 <code>as</code> 的数据类型是 <code>List&lt;String&gt;</code>。与泛型方法签名进行对比，<code>test(Collection&lt;T&gt; from, Collection&lt;T&gt; to)</code>，编译器无法正确识别 T 所代表的实际类型。为了避免这种错误，可以改为如下形式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">(Collection&lt;? extends T&gt; from, Collection&lt;T&gt; to)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (T ele : from) &#123;</span><br><span class="line">        to.add(ele);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Collection&lt;? extends T&gt;</code> 这种采用类型通配符并设置通配符上限的表示方式，只要 test 方法的第一个 Collection 集合里的元素类型是后一个 Collection 集合里元素类型的子类即可。</p><h2 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h2><p>对于类中变量的类型，绘制了一个简单的图：</p><p><img src="https://i.loli.net/2019/07/13/5d2961d5155f246541.png" alt="变量"></p><p>作图工具：<a href="https://www.processon.com/i/55ddb6bae4b04fe84c504c5f" target="_blank" rel="noopener">ProcessOn</a>，强烈安利</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>经过上面的学习，我对泛型(<code>Generic</code>)有了初步的认识。类似于一个「模板」的概念，「占坑」等着渲染，提供了对类、接口、方法定义的灵活性，使用起来具有了「动态性」。当然，这只是我的个人理解，方便记忆的，可能表述并不是很准确。在实际的生产代码中，也有应用泛型类、泛型方法的，能够想到去使用它，无疑需要对泛型有比较好的理解。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://docs.oracle.com/javase/tutorial/java/generics/index.html" target="_blank" rel="noopener">Oracle-Generics Documentation</a></li><li><a href="https://blog.csdn.net/s10461/article/details/53941091" target="_blank" rel="noopener">CSDN-java 泛型详解-绝对是对泛型方法讲解最详细的，没有之一</a></li><li><a href="https://blog.csdn.net/ShuSheng0007/article/details/80720406#%E5%A6%82%E4%BD%95%E8%B0%83%E7%94%A8%E4%B8%80%E4%B8%AA%E6%B3%9B%E5%9E%8B%E6%96%B9%E6%B3%95" target="_blank" rel="noopener">CSDN-ShuSheng007-秒懂Java泛型</a></li><li><a href="https://juejin.im/post/5b614848e51d45355d51f792" target="_blank" rel="noopener">掘金-深入理解Java泛型</a></li><li><a href="http://hinylover.space/2016/06/25/relearn-java-generic-1/" target="_blank" rel="noopener">重新认识Java——泛型（基础、使用和实现原理）</a></li><li><a href="http://www.glmapper.com/2019/08/19/base-java-generics/#%E5%B8%B8%E7%94%A8%E7%9A%84-T%EF%BC%8CE%EF%BC%8CK%EF%BC%8CV%EF%BC%8C%EF%BC%9F" target="_blank" rel="noopener">glmapper—聊一聊-JAVA 泛型中的通配符 T，E，K，V，？</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://gitee.com/michael_xiang/images/raw/master/uPic/pastries-756601_640.jpg&quot; alt=&quot;pastries-模板&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;泛型概念&quot;&gt;&lt;a href=&quot;#泛型概念&quot; class=&quot;headerlink&quot; title=&quot;泛型概念&quot;&gt;&lt;/a&gt;泛型概念&lt;/h2&gt;&lt;p&gt;泛型（ &lt;code&gt;Generic&lt;/code&gt;）是一种编译器机制，您可通过该机制获取通用的代码并参数化（或模板化）剩余部分，从而以一种一般化方式创建（和使用）一些类型的实体（比如类或接口和方法）。这种编程方法被称为泛型编程。&lt;/p&gt;
&lt;p&gt;所谓泛型，就是允许在定义类、接口、方法时使用类型形参，这个类型形参(或叫泛型)将在声明变量、创建对象、调用方法时动态地指定(即传入实际的类型参数，也可以称为「类型实参」)。&lt;/p&gt;
    
    </summary>
    
      <category term="Java" scheme="https://michael728.github.io/categories/Java/"/>
    
    
      <category term="基础" scheme="https://michael728.github.io/tags/%E5%9F%BA%E7%A1%80/"/>
    
      <category term="Java" scheme="https://michael728.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>2020 疫情年一次说走就走的端午重庆游</title>
    <link href="https://michael728.github.io/2020/07/05/life-travel-chongqing/"/>
    <id>https://michael728.github.io/2020/07/05/life-travel-chongqing/</id>
    <published>2020-07-05T16:29:08.000Z</published>
    <updated>2021-02-12T13:27:05.289Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://gitee.com/michael_xiang/images/raw/master/uPic/RL3xCV.png" alt="fly"></p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>前阵子趁着端午放假，媳妇儿张罗了一次去重庆的三天游的计划！确实属于一次说走就走的旅行了，因为我们提前 5 天才买好了机票、订好了住宿……虽然订票仓促，但是媳妇儿还是做了很详细的攻略！👏</p><p>年轻人嘛，就是得「浪」~</p><blockquote><p>1189年，宋光宗赵惇先封恭王再即帝位，自诩“双重喜庆”，重庆由此得名（摘自百度百科）。因古代流经重庆的嘉陵江称为渝水，故重庆古名为渝州。重庆还有很多简称，巴或渝，既以江城、雾都著称，又以山城扬名。</p></blockquote><a id="more"></a><h2 id="Day-1"><a href="#Day-1" class="headerlink" title="Day 1"></a>Day 1</h2><p>期盼了几天之后，终于等到了端午假！第一天一大早，我们便从杭州出发前往重庆啦。那一天杭州大暴雨，但是重庆确实大晴天。前面的小哥拿着他的 ipad 还在抓紧时间看下载的 IT 教程视频呢，不得不感慨这位程序员小哥有点拼！</p><p><img src="https://gitee.com/michael_xiang/images/raw/master/uPic/KNJ7cm.png" alt="IT"></p><blockquote><p>不过这不太符合我的理念，玩的时候就放开尽情的玩吧！</p></blockquote><p>在前往重庆之前，机智的媳妇儿就让我们提前在 Huawei Pay 中申请好了重庆的交通卡，因此，全程我俩都省去了排队买车票的麻烦，so 方便~</p><p><img src="https://gitee.com/michael_xiang/images/raw/master/uPic/YTFBJp.png" alt="地铁"></p><p><img src="https://gitee.com/michael_xiang/images/raw/master/uPic/yvhOcw.png" alt="路牌"></p><p>到了重庆，第一顿是在一家叫「月半（解放碑总店）」的川菜馆吃的，可谓是实惠又美味！下面这顿 98 元就搞定了！老板还热情的赠送了我们粽子和红枣，临走又送了 2 盒红枣，重庆人的火辣热情立马就赢得了我俩的好感！</p><p><img src="https://gitee.com/michael_xiang/images/raw/master/uPic/MoMAKU.png" alt="月半"></p><p>坐轻轨前往了网红打卡地「李子坝」，其实就是因为轻轨穿过居民楼而显得有些新奇。楼上的居民是否住的开心呢？个人感觉有条件的话，应该不会选择这样的居住环境吧，毕竟过于「热闹」了些~</p><p><img src="https://gitee.com/michael_xiang/images/raw/master/uPic/iWGEwe.png" alt="李子坝"></p><p>在「鹅岭公园」的最高处「瞰胜楼」，可以看到一个不错的重庆城的全貌。可惜的是，这个「瞰胜楼」造的相对比较简陋，不过可以理解，毕竟是个免费的公园观景楼。</p><p><img src="https://gitee.com/michael_xiang/images/raw/master/uPic/kIaOhg.png" alt="鹅岭公园"></p><p><img src="https://gitee.com/michael_xiang/images/raw/master/uPic/YgIi8o.png" alt="路牌"></p><p>「鹅岭公园」和「二厂文创园」离得比较近，紧接着我们就前往了这个网红地。确实是个网红地，很多小年轻在那里拍照，不过个人认为是个 IDEA 大于美景的去处，老楼弄点涂鸦、开了一些创意文化礼品店。</p><p><img src="https://gitee.com/michael_xiang/images/raw/master/uPic/pu131A.png" alt="小仙女出镜"></p><p>累了一天，晚上在「八一美食街」上吃了传说中的「玫瑰冰粉」，真是巴适啊……</p><p><img src="https://gitee.com/michael_xiang/images/raw/master/uPic/6NI7je.png" alt="玫瑰冰粉"></p><p>晚上我俩沿着「千厮门大桥」走到了江对面远观了一下「洪崖洞」。很可惜的是，当我们走回对面时，因为过了 22:30 了，洪崖洞的灯关了……不过订的住宿就在洪崖洞的上方，因此，第二天晚上弥补了这个小遗憾。</p><p><img src="https://gitee.com/michael_xiang/images/raw/master/uPic/ArRbFp.png" alt="远观洪崖洞"></p><p>作为名副其实的吃货，我俩又打包了两份好吃的带回去当夜宵了。🤣</p><p><img src="https://gitee.com/michael_xiang/images/raw/master/uPic/jrySOT.png" alt="夜宵"></p><h2 id="Day-2"><a href="#Day-2" class="headerlink" title="Day 2"></a>Day 2</h2><p>酒店提供的自助早餐真是丰富，重庆小面都有，真是赞！</p><p><img src="https://gitee.com/michael_xiang/images/raw/master/uPic/ktYDmn.png" alt="早餐"></p><p>一位拎着年代感十足的箱子的老人。</p><p><img src="https://gitee.com/michael_xiang/images/raw/master/uPic/apzhYs.png" alt="路人"></p><p>本打算去四川美院逛逛的，可惜受疫情影响，学校没有开发。在涂鸦一条街随便走了走，便打算离开了。重庆的出租车是黄色的，有点与众不同，很亮眼有活力啊。</p><p><img src="https://gitee.com/michael_xiang/images/raw/master/uPic/KzUeI9.png" alt="小黄车"></p><p>在等公交车的时候，也观察到一些老人在打扑克，懂得享受生活也是一种幸福！</p><p><img src="https://gitee.com/michael_xiang/images/raw/master/uPic/iVj6Ev.png" alt="交通茶馆"></p><p>「磁器口」就是一个商业古镇，街边都是做生意的小商贩，挺热闹的。</p><p><img src="https://gitee.com/michael_xiang/images/raw/master/uPic/dxAKB5.png" alt="合影"></p><p>下午的太阳很强烈，偶然发现了一个茶楼「转运楼」，于是我们买票进去歇息了会儿。真是有惊喜的一个选择，在里面避暑的同时，还看到了很多表演！</p><p><img src="https://gitee.com/michael_xiang/images/raw/master/uPic/Kn3f9Q.png" alt="转运楼"></p><blockquote><p>人生有时候也一样，不经意的选择，并未充分考虑好，或许反而会带来一些意料之外的收获。</p></blockquote><p>来了重庆，怎能不坐一次「长江索道」呢？本应被长江大桥替代的旧交通工具，如今演变成了旅游景点的项目。果然，「物以稀为贵」。</p><p><img src="https://gitee.com/michael_xiang/images/raw/master/uPic/achdk9.png" alt="长江索道"></p><p>在「南山一棵树观景台」可以俯视整个山城，夜景确实相当赞！</p><p><img src="https://gitee.com/michael_xiang/images/raw/master/uPic/DCqeYu.png" alt="南山一棵树"></p><blockquote><p>城市和城市之间的差异其实正越来越小，繁华的夜景和上海滩、钱塘江夜景好像也差不多……这算不算「城市同质化」？</p></blockquote><h2 id="Day-3"><a href="#Day-3" class="headerlink" title="Day 3"></a>Day 3</h2><p>第三天重庆大暴雨，约了本科同宿舍的兄弟见见，属于「怀旧」的一天。</p><p>四年的舍友，当初我们都还是懵懂少年，如今他有了自己的小家，也成为了一位父亲。恭喜 &amp; 祝福，期待杭州再聚！</p><p><img src="https://gitee.com/michael_xiang/images/raw/master/uPic/aO9xIO.png" alt="幸福的一家人"></p><p>重庆的火锅魅力就是大，平日对牛肉不感冒的媳妇儿也吃了挺多，吃撑的节奏~😋</p><p><img src="https://gitee.com/michael_xiang/images/raw/master/uPic/MQVaUt.png" alt="临江门火锅"></p><h2 id="一言"><a href="#一言" class="headerlink" title="一言"></a>一言</h2><p>「一方水土养育一方人」，重庆一游，感受到了不同的风土人情。不像江浙沪这边的含蓄、小家碧玉，重庆人的豪爽、热情给我们留下了深刻的印象。我觉得这股子乐观的精神要多多学习，人生短短几十载，在我们能够快活的岁月里，应该珍惜时光！希望余生可以和媳妇儿一起探索更多的风景~</p><p>旅行的意义是什么？回来后和小辉聊到了这个话题。他的一些观点还是给了我一些启发的。比如我们经常看到一些贫困区的新闻，但是，当我们亲眼见证了这些生活时，这种带来的震撼不是书本和新闻能够给与的。</p><p>「体验」生活，增加生命的「厚度」。辛勤工作的同时，别忘记了工作赚钱的目的是为了更好的生活！「旅行」对于你的意义是什么呢？欢迎交流~</p><p><img src="https://gitee.com/michael_xiang/images/raw/master/uPic/yWOYUz.png" alt="流光"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://gitee.com/michael_xiang/images/raw/master/uPic/RL3xCV.png&quot; alt=&quot;fly&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;前阵子趁着端午放假，媳妇儿张罗了一次去重庆的三天游的计划！确实属于一次说走就走的旅行了，因为我们提前 5 天才买好了机票、订好了住宿……虽然订票仓促，但是媳妇儿还是做了很详细的攻略！👏&lt;/p&gt;
&lt;p&gt;年轻人嘛，就是得「浪」~&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;1189年，宋光宗赵惇先封恭王再即帝位，自诩“双重喜庆”，重庆由此得名（摘自百度百科）。因古代流经重庆的嘉陵江称为渝水，故重庆古名为渝州。重庆还有很多简称，巴或渝，既以江城、雾都著称，又以山城扬名。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="Life" scheme="https://michael728.github.io/categories/Life/"/>
    
    
      <category term="Life" scheme="https://michael728.github.io/tags/Life/"/>
    
      <category term="游记" scheme="https://michael728.github.io/tags/%E6%B8%B8%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>Java 基础 —— 注解 Annotation</title>
    <link href="https://michael728.github.io/2020/07/04/java-basic-annotation/"/>
    <id>https://michael728.github.io/2020/07/04/java-basic-annotation/</id>
    <published>2020-07-04T12:49:10.000Z</published>
    <updated>2021-02-12T13:27:05.289Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://gitee.com/michael_xiang/images/raw/master/uPic/pexels-jeremy-bishop-2922672.jpg" alt="Pexels 上的 Jeremy Bishop 拍摄的图片"></p><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul><li>Annotation 是从 JDK 5.0 引入的。</li><li>注解使得我们可以以编译器验证的格式存储程序的额外信息。注解可以生成描述符文件，甚至是新的类定义，并且有助于减轻编写“样板”代码的负担。</li></ul><p>比如，我们项目中常常使用的 <code>lombok</code> 包中的注解，<code>@Data</code>、<code>@NoArgsConstructor</code>、<code>@AllArgsConstructor</code> 等注解，大大简化了代码，省了很多操作。</p><a id="more"></a><h2 id="基本注解"><a href="#基本注解" class="headerlink" title="基本注解"></a>基本注解</h2><p>Java 提供了几个基本注解，这些内置注解它们都位于 <code>java.lang</code> 包下。</p><ul><li><code>@Override</code> 作用于子类中的方法，表示该方法一定要重写父类中的方法，可以有效避免子类方法名误写错误；</li><li><code>@Deprecated</code>表示某类、方法等已过时，当它们被使用时，编译器将会给出警告；</li><li><code>@SuppressWarnings</code> 镇压警告，被修饰的程序元素及其子元素取消显示指定的编译器警告，<code>supress</code> 有抑制、废止的含义；</li><li><code>@SafeVarags</code> Java 7 新增的，抑制堆污染警告；</li><li><code>@FunctionalInterface</code>：Java 8 中加入用于表示类型声明为函数式接口</li></ul><h2 id="注解示例"><a href="#注解示例" class="headerlink" title="注解示例"></a>注解示例</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target</span>(ElementType.TYPE)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> TestAnnotation &#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">id</span><span class="params">()</span> <span class="keyword">default</span> -1</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">msg</span><span class="params">()</span> <span class="keyword">default</span> "Hi"</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>说明：</p><ul><li>通过关键字 <code>@interface</code> 定义，并不是接口；</li><li>注解的属性也叫做成员变量。注解只有成员变量，没有方法。注解的成员变量在注解的定义中以“无形参的方法”形式来声明，其方法名定义了该成员变量的名字；</li><li>这里的示例上使用了一些注解，称为「元注解」，后面会详细介绍，稍安勿躁，这里仅仅是 show 一下自定义的注解长什么样；</li></ul><p>注意点：</p><ul><li>如果一个注解内仅仅只有一个名字为 <code>value</code> 的属性时，应用这个注解时可以直接接属性值填写到括号内；</li><li>有一种情况是一个注解没有任何属性，在应用这个注解的时候，括号都可以省略，不包含任何元素的注解称为标记注解（<code>marker annotation</code>）；</li><li>在注解中定义属性时它的类型必须是 8 种基本数据类型外加 类、接口、注解及它们的数组；</li></ul><h2 id="元注解"><a href="#元注解" class="headerlink" title="元注解"></a>元注解</h2><p>JDK 除了在 <code>java.lang</code> 下提供了 4 个基本的 Annotation 之外，还在 <code>java.lang.annotation</code> 包下提供了4个 <code>Meta Annotation</code>——元注解。这 4 个注解用于修饰其他的注解。元注解是可以注解到注解上的注解，或者说元注解是一种基本注解，但是它能够应用到其它的注解上面。</p><h3 id="Retention"><a href="#Retention" class="headerlink" title="@Retention"></a>@Retention</h3><p>Retention 的英文意为保留期的意思。当 <code>@Retention</code> 应用到一个注解上的时候，它解释说明了这个注解的的存活时间。</p><ul><li><code>RetentionPolicy.SOURCE</code> 注解只在源码阶段保留，在编译器进行编译时它将被丢弃忽视；</li><li><code>RetentionPolicy.CLASS</code> 注解只被保留到编译进行的时候，它并不会被加载到 JVM 中；</li><li><code>RetentionPolicy.RUNTIME</code> 注解可以保留到程序运行的时候，它会被加载进入到 JVM 中，所以在程序运行时可以获取到它们；</li></ul><h3 id="Documented"><a href="#Documented" class="headerlink" title="@Documented"></a>@Documented</h3><p>它的作用是能够将注解中的元素包含到 Javadoc 中去。</p><h3 id="Target"><a href="#Target" class="headerlink" title="@Target"></a>@Target</h3><p><code>@Target</code> 指定了注解运用的地方，规定了只能张贴到方法上、类上、方法参数上等等。@Target 有下面的取值：</p><ul><li><code>ElementType.TYPE</code> 可以给一个类型进行注解，比如类、接口、枚举</li><li><code>ElementType.METHOD</code> 可以给方法进行注解</li><li><code>ElementType.FIELD</code> 可以给属性进行注解</li><li><code>ElementType.CONSTRUCTOR</code> 可以给构造方法进行注解</li><li><code>ElementType.LOCAL_VARIABLE</code> 可以给局部变量进行注解</li><li><code>ElementType.PACKAGE</code> 可以给一个包进行注解</li><li><code>ElementType.PARAMETER</code> 可以给一个方法内的参数进行注解</li><li><code>ElementType.ANNOTATION_TYPE</code> 可以给一个注解进行注解</li></ul><h3 id="Inherited"><a href="#Inherited" class="headerlink" title="@Inherited"></a>@Inherited</h3><p>Inherited 是继承的意思，但是它并不是说注解本身可以继承，而是说如果一个超类被 @Inherited 注解过的注解进行注解的话，那么如果它的子类没有被任何注解应用的话，那么这个子类就继承了超类的注解。</p><h2 id="自定义注解"><a href="#自定义注解" class="headerlink" title="自定义注解"></a>自定义注解</h2><p>使用 <code>@interface</code> 自定义注解时，自动继承了 <code>java.lang.annotation.Annotation</code> 接口。</p><p>一般我们使用注解，常常和验证器配合着使用。另外一种就是利用 AOP 结合使用。下面我们结合具体的示例来加深一下注解的使用。</p><h3 id="Length-注解"><a href="#Length-注解" class="headerlink" title="@Length 注解"></a>@Length 注解</h3><p>下面，我们自定义一个注解，用来实现限制字段的长度。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target</span>(&#123;ElementType.FIELD, ElementType.CONSTRUCTOR, ElementType.PARAMETER&#125;)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Constraint</span>(validatedBy = &#123;LengthValidator.class&#125;)  <span class="comment">// 与约束注解关联的验证器</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Length &#123;</span><br><span class="line">    <span class="comment">// 约束注解验证时的输出消息</span></span><br><span class="line">    <span class="function">String <span class="title">message</span><span class="params">()</span> <span class="keyword">default</span> "限制字段值的范围"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 约束注解在验证时所属的组别</span></span><br><span class="line">    Class&lt;?&gt;[] groups() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 约束注解的有效负载</span></span><br><span class="line">    Class&lt;? extends Payload&gt;[] payload() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">min</span><span class="params">()</span> <span class="keyword">default</span> 0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">max</span><span class="params">()</span> <span class="keyword">default</span> 100</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接着，我们定义对应的验证器：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LengthValidator</span> <span class="keyword">implements</span> <span class="title">ConstraintValidator</span>&lt;<span class="title">Length</span>, <span class="title">Integer</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Integer min;</span><br><span class="line">    <span class="keyword">private</span> Integer max;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">initialize</span><span class="params">(Length constraintAnnotation)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.min = constraintAnnotation.min();</span><br><span class="line">        <span class="keyword">this</span>.max = constraintAnnotation.max();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isValid</span><span class="params">(Integer value, ConstraintValidatorContext context)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (value == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (value &gt;= min &amp;&amp; value &lt;= max) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意点：</p><ul><li>只有当注解中有 <code>value</code> 成员变量时，才可以不传 <code>key</code>，因为它默认是将值赋给 <code>value</code> 成员变量的；</li><li>成员变量没有使用 <code>default</code> 定义默认值，在使用注解时，就必须要对它进行赋值，有默认值则可以不必赋值；</li><li>如果只有一个参数成员，一般参数名为 <code>value</code>；</li><li><code>but does not contain a groups parameter</code> 注解需要定义成员变量 <code>groups</code></li><li><code>xxx contains Constraint annotation, but does not contain a payload parameter.</code> 注解需要定义成员变量 <code>Payload</code></li></ul><h2 id="提取注解信息"><a href="#提取注解信息" class="headerlink" title="提取注解信息"></a>提取注解信息</h2><p>AnnotatedElement 接口是所有程序元素（如Class、Method、Constructor等）的父接口，所以程序通过反射获取了某个类的 AnnotatedElement 对象（如Class、Method、Constructor等）之后，程序就可以调用该对象的如下3个方法来访问Annotation信息：</p><ul><li><code>getAnnotation(Class&lt;T&gt; annotationClass)</code> 返回该程序元素上指定类型的注释，如果不存在，则返回 null，比如 <code>Length length = field.getAnnotation(Length.class);</code> 通过反射获取到该字段上使用的 <code>@Length</code> 注解的详细信息；</li><li><code>Annotation[] getAnnotations()</code> 返回该程序元素上的所有注释，例如 <code>Annotation annotations = Class.forName(&quot;Test&quot;).getMethod(&quot;info&quot;).getAnnotations();</code> 表示获取 <code>Test</code> 类中 <code>info</code> 方法上的注释；</li><li><code>boolean isAnnotatinPresent(Class&lt;?extends Annotation&gt; annotationClass)</code> 判断该元素上是否存在指定类型的注释，如果存在则返回 true，否则返回 false，例如 <code>methodA.isAnnotationPresent(Length.class)</code>，表示判断方法 methodA 上是否用了 <code>@Length</code>注释；</li></ul><blockquote><p>为了获得程序中的程序元素（如 Class 、Method等），必须使用反射知识。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取某个对象的类</span></span><br><span class="line">Class cl = obj.getClass();</span><br><span class="line"><span class="comment">// 获取某个类中定义的所有属性</span></span><br><span class="line">Fields[] fields = cl.getDeclaredFields();</span><br></pre></td></tr></table></figure><h2 id="编译时处理-Annotation"><a href="#编译时处理-Annotation" class="headerlink" title="编译时处理 Annotation"></a>编译时处理 Annotation</h2><p>如果希望让程序中的 Annotation 在运行时起一定的作用，只有通过某种配套的工具对Annotation中的信息进行访问和处理，访问和处理 Annotation 的工具统称 APT（Annotation ProcessingTool）。</p><p>Annotation 处理器在处理 Annotation 时可以根据源文件中的Annotation生成额外的源文件和其他的文件（文件的具体内容由 Annotation 处理器的编写者决定），APT 还会编译生成的源代码文件和原来的源文件，将它们一起生成 class 文件。</p><blockquote><p>我们可以在Java源文件中放置一些Annotation，然后使用APT工具就可以根据该 Annotation 生成另一份 XML 文件，这就是 Annotation 的作用。</p></blockquote><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://lingcoder.github.io/OnJava8/#/book/23-Annotations?id=%e7%ac%ac%e4%ba%8c%e5%8d%81%e4%b8%89%e7%ab%a0-%e6%b3%a8%e8%a7%a3" target="_blank" rel="noopener">On Java8 —— 第二十三章 注解</a></li><li><a href="https://blog.csdn.net/briblue/article/details/73824058" target="_blank" rel="noopener">csdn-frank909-秒懂，Java 注解 （Annotation）你可以这样学</a></li><li><a href="https://mp.weixin.qq.com/s?__biz=MzU4ODI1MjA3NQ==&amp;mid=2247484955&amp;idx=1&amp;sn=29b0f228415abd8542d07c898e6398ba&amp;chksm=fdded0dfcaa959c9d9fc9d04130409c392460561bdce53996261fe8973b81f4811a8ebe5c357&amp;scene=21#wechat_redirect" target="_blank" rel="noopener">啥？听说你还在手写复杂的参数校验？</a></li><li><a href="https://www.cnkirito.moe/spring-validation/" target="_blank" rel="noopener">使用 spring validation 完成数据后端校验</a></li><li><a href="https://blog.csdn.net/ZZY1078689276/article/details/79064835" target="_blank" rel="noopener">csdn-Bean Validation——自定义注解</a></li></ul><hr><blockquote><p>生命不息，折腾不止！关注 「Coder 魔法院」，祝你 Niubilitiy ！🐂🍺</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://gitee.com/michael_xiang/images/raw/master/uPic/pexels-jeremy-bishop-2922672.jpg&quot; alt=&quot;Pexels 上的 Jeremy Bishop 拍摄的图片&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;Annotation 是从 JDK 5.0 引入的。&lt;/li&gt;
&lt;li&gt;注解使得我们可以以编译器验证的格式存储程序的额外信息。注解可以生成描述符文件，甚至是新的类定义，并且有助于减轻编写“样板”代码的负担。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;比如，我们项目中常常使用的 &lt;code&gt;lombok&lt;/code&gt; 包中的注解，&lt;code&gt;@Data&lt;/code&gt;、&lt;code&gt;@NoArgsConstructor&lt;/code&gt;、&lt;code&gt;@AllArgsConstructor&lt;/code&gt; 等注解，大大简化了代码，省了很多操作。&lt;/p&gt;
    
    </summary>
    
      <category term="Java" scheme="https://michael728.github.io/categories/Java/"/>
    
    
      <category term="注解" scheme="https://michael728.github.io/tags/%E6%B3%A8%E8%A7%A3/"/>
    
  </entry>
  
  <entry>
    <title>Java 基础 —— Lambda 表达式</title>
    <link href="https://michael728.github.io/2020/07/04/java-basic-lambda/"/>
    <id>https://michael728.github.io/2020/07/04/java-basic-lambda/</id>
    <published>2020-07-04T12:49:10.000Z</published>
    <updated>2021-02-12T13:27:05.289Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://gitee.com/michael_xiang/images/raw/master/uPic/CACVrU.png" alt="重庆-南山一棵树"></p><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>阅读项目代码时，尤其是阅读一些源码时，经常会遇到 Lambda 表达式。对此之前看过相关文章，但是停留在模模糊糊的印象上。今天趁着有时间，通过一些 demo 示例，梳理一下它的用法，以备后期遗忘的时候快速查询它的用法！</p><p>Lambda 表达式是 Java 8 的重要更新，它支持将代码块作为方法参数、允许使用更简洁的代码来创建只有一个抽象方法的接口的实例。</p><blockquote><p>描述中提到的接口称为函数式接口</p></blockquote><a id="more"></a><h2 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h2><p>Lambda 表达式的主要作用就是可以用于简化创建匿名内部类对象，Lambda 表达式的代码块将会用于实现抽象方法的方法体，Lambda 表达式就相当于一个匿名方法。</p><p>Lambda 表达式由三部分组成：</p><ul><li>形参列表：形参列表允许省略类型，如果形参列表中只有一个参数，形参列表的圆括号也可以省略；</li><li>箭头（<code>-&gt;</code>）：通过英文画线和大于符号组成；</li><li>代码块：如果代码块只有一条语句，花括号可以省略。Lambda 代码块只有一条 return 语句，可以省略 return 关键字，Lambda 表达式会自动返回这条语句的值作为返回值。</li></ul><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Eatable</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">taste</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Flyable</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">fly</span><span class="params">(String weather)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Addable</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LambdaQs</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 调用该方法需要传入一个 Eatable 类型的对象</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">(Eatable e)</span> </span>&#123;</span><br><span class="line">        System.out.println(e);</span><br><span class="line">        e.taste();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用该方法需要传入 Flyable 类型的对象</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">drive</span><span class="params">(Flyable f)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"我正在驾驶："</span> + f);</span><br><span class="line">        f.fly(<span class="string">"「夏日晴天」"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用该方法需要 Addable 类型的对象</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">calc</span><span class="params">(Addable add)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"5 + 3 = "</span> + add.add(<span class="number">5</span>, <span class="number">3</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        LambdaQs lq = <span class="keyword">new</span> LambdaQs();</span><br><span class="line">        <span class="comment">// Lambda 表达式的代码块只有一句，因此省略了花括号</span></span><br><span class="line">        lq.eat(() -&gt; System.out.println(<span class="string">"雪糕的味道不错！"</span>));</span><br><span class="line">        <span class="comment">// Lambda 表达式的形参只有一个参数，因此省略了圆括号</span></span><br><span class="line">        lq.drive(weather -&gt; &#123;</span><br><span class="line">            <span class="comment">// 对接口中抽象方法 fly 的重写</span></span><br><span class="line">            System.out.println(<span class="string">"今天天气是："</span> + weather);</span><br><span class="line">            System.out.println(<span class="string">"飞机平稳飞行！"</span>);</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="comment">// Lambda 表达式只有一条语句，即使该表达式需要返回值，也可以省略 return</span></span><br><span class="line">        lq.calc((a, b) -&gt; a + b);</span><br><span class="line">        <span class="comment">// 如果不用 Lambda 表达式，就需要如下匿名类的方式去重写抽象方法</span></span><br><span class="line">        lq.calc(<span class="keyword">new</span> Addable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> a + b;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">oop.lambda.LambdaQs$$Lambda$<span class="number">1</span>/<span class="number">1607521710</span>@<span class="number">7</span>ef20235</span><br><span class="line">雪糕的味道不错！</span><br><span class="line">我正在驾驶：oop.lambda.LambdaQs$$Lambda$<span class="number">2</span>/<span class="number">1329552164</span>@<span class="number">15</span>aeb7ab</span><br><span class="line">今天天气是：「夏日晴天」</span><br><span class="line">飞机平稳飞行！</span><br><span class="line"><span class="number">5</span> + <span class="number">3</span> = <span class="number">8</span></span><br><span class="line"><span class="number">5</span> + <span class="number">3</span> = <span class="number">8</span></span><br></pre></td></tr></table></figure></p><p>以上示例可以说明，Lambda 表达式实际上可以被当做一个具体的对象。</p><h2 id="Lambda-表达式与函数式接口"><a href="#Lambda-表达式与函数式接口" class="headerlink" title="Lambda 表达式与函数式接口"></a>Lambda 表达式与函数式接口</h2><p> Lambda 表达式的类型，也被称为「目标类型（<code>target type</code>）」。<strong>Lambda 表达式的目标类型必须是「函数式接口（<code>functional interface</code>）」</strong>。函数式接口代表只包含一个抽象方法的接口。函数式接口可以包含多个默认方法、类方法，但仅能声明一个抽象方法。</p><p> 查询 Java 8 的 API 文档，可以发现大量的函数式接口，例如：Runnable、ActionListener 等接口都是函数式接口。</p><blockquote><p>Java 8 专门为函数式接口提供了 <code>@FunctionalInterface</code> 注解。该注解就是用于告诉编译器校验接口必须是函数式接口，否则就报错。</p></blockquote><p>由于 Lambda 表达式的结果就是被当做对象/实例，因此，可以使用 Lambda 表达式进行赋值，示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Runnable r = () -&gt; &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">        System.out.println(i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>我们看一下 Runnable 接口的定义：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>看一个错误示例：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Object obj = () -&gt; &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">        System.out.println(i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>上面这段代码会报错：<code>Target type of a lambda conversion must be an interface</code>。Lambda 表达式的目标类型必须是明确的函数式接口！将 Lambda 表达式赋值给 Object 类型的变量，编译器只能推断出它的表达类型为 Object，而 Object 并不是函数式接口，因此就报错了！</p><p>为了保证 Lambda 表达式的目标类型是明确的函数式接口，有如下三种常见方式：</p><ul><li>将 Lambda 表达式赋值给函数式接口类型的变量；</li><li>将 Lambda 表达式作为函数式接口类型的参数传给某个方法；</li><li>使用函数式接口对 Lambda 表达式进行强制类型转换；</li></ul><p>将上面出错的代码可以进行如下的改写：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Object obj1 = (Runnable)() -&gt; &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">        System.out.println(i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>综上，Lambda 表达式的本质很简单，就是使用简单的语法来创建函数式接口的实例，避免匿名内部类的繁琐。</p><h2 id="方法引用与构造器引用"><a href="#方法引用与构造器引用" class="headerlink" title="方法引用与构造器引用"></a>方法引用与构造器引用</h2><p>如果 Lambda 表达式的代码块只有一条代码，还可以在代码中使用方法引用和构造器引用。</p><p>方法引用和构造器引用的好处是使 Lambda 表达式的代码块更加简洁。方法引用和构造器引用都需要使用两个英文冒号 <code>::</code>。</p><table><thead><tr><th>种类</th><th>示例</th><th>说明</th><th>对应的 Lambda 表达式</th></tr></thead><tbody><tr><td>引用类方法</td><td>类名::类方法</td><td>函数式接口中被实现的方法的全部参数传给该类方法作为参数</td><td><code>(a,b,...) -&gt; 类名.类方法(a,b,...)</code></td></tr><tr><td>引用特定对象的实例方法</td><td>特定对象::实例方法</td><td>函数式接口中被实现的方法的全部参数传给该方法作为参数</td><td><code>(a,b,...) -&gt; 特定对象.实例方法(a,b,...)</code></td></tr><tr><td>引用某类对象的实例方法</td><td>类名::实例方法</td><td>函数式接口中被实现的方法的第一个参数作为调用者，后面的参数全部传给该方法作为参数</td><td><code>(a,b,...)-&gt;a.实例方法(b,...)</code></td></tr><tr><td>引用构造器</td><td>类名::new</td><td>函数式接口中被实现方法的全部参数传给该构造器作为参数</td><td><code>(a,b,...)-&gt;new 类名(a,b,...)</code></td></tr></tbody></table><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Converter</span> </span>&#123;</span><br><span class="line">    <span class="function">Integer <span class="title">convert</span><span class="params">(String from)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">MyTest</span> </span>&#123;</span><br><span class="line">    <span class="function">String <span class="title">test</span><span class="params">(String a, <span class="keyword">int</span> b, <span class="keyword">int</span> c)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">YourTest</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 抽象方法负责根据 String 参数生成一个 JFrame 返回值</span></span><br><span class="line">    <span class="function">JFrame <span class="title">win</span><span class="params">(String title)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LambdaRef</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 1 引用类方法</span></span><br><span class="line">        <span class="comment">// 下面使用 Lambda 表达式创建 Converter 对象</span></span><br><span class="line">        Converter converter1 = from -&gt; Integer.valueOf(from);</span><br><span class="line">        Integer val = converter1.convert(<span class="string">"99"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 函数式接口中被实现方法的全部参数传给该类方法作为参数</span></span><br><span class="line">        Converter converter2 = Integer::valueOf;</span><br><span class="line">        Integer val2 = converter2.convert(<span class="string">"100"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2 引用特定对象的实例方法</span></span><br><span class="line">        <span class="comment">// 使用 Lmabda 表达式创建 Converter 对象</span></span><br><span class="line">        Converter converter3 = from -&gt; <span class="string">"hello michael翔"</span>.indexOf(from);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 调用 "hello michael翔"的indexOf()实例方法</span></span><br><span class="line">        <span class="comment">// 函数式接口中被实现的全部参数传给该方法作为参数</span></span><br><span class="line">        Converter converter4 = <span class="string">"hello michael翔"</span>::indexOf;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3 引用某类对象的实例方法</span></span><br><span class="line">        <span class="comment">// 使用 Lambda 表达式创建 MyTest 对象</span></span><br><span class="line">        MyTest mt = (a, b, c) -&gt; a.substring(b, c);</span><br><span class="line">        String  str = mt.test(<span class="string">"Hello World, Hello Michael翔"</span>, <span class="number">2</span>,<span class="number">9</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 上面 Lambda 表达式只有一行，因此可以使用如下引用进行替换</span></span><br><span class="line">        <span class="comment">// 函数式接口中被实现方法的第一个参数作为调用者</span></span><br><span class="line">        <span class="comment">// 后面的参数全部传给该方法作为参数</span></span><br><span class="line">        MyTest str2 = String::substring;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4 引用构造器</span></span><br><span class="line">        <span class="comment">// 使用 Lambda 表达式创建 YourTest 对象</span></span><br><span class="line">        YourTest yt = a -&gt; <span class="keyword">new</span> JFrame(a);</span><br><span class="line">        JFrame jf = yt.win(<span class="string">"窗口"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 使用构造器引用进行替换</span></span><br><span class="line">        <span class="comment">// 函数式接口中被实现方法的全部参数传给该构造器作为参数</span></span><br><span class="line">        YourTest yt2 = JFrame::<span class="keyword">new</span>;</span><br><span class="line">        JFrame jf2 = yt.win(<span class="string">"窗口2"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Lambda-表达式与匿名内部类的联系与区别"><a href="#Lambda-表达式与匿名内部类的联系与区别" class="headerlink" title="Lambda 表达式与匿名内部类的联系与区别"></a>Lambda 表达式与匿名内部类的联系与区别</h2><p>Lambda 表达式与匿名内部类存在如下相同点：</p><ul><li>Lambda 表达式与匿名内部类一样，都可以直接访问 <code>effectively final</code> 的局部变量，以及外部类的成员变量（包括示例变量和类变量）；</li><li>Lambda 表达式创建的对象与匿名内部类生成的对象一样，都可以直接调用从接口中继承的默认方法；</li></ul><p>Lambda 表达式与匿名内部类的区别：</p><ul><li>匿名内部类可以为任意接口创建实例，不管接口包含多少个抽象方法，只要匿名内部类实现所有抽象方法即可；但是 Lambda 表达式只能为函数式接口创建实例；</li><li>匿名内部类可以为抽象类甚至普通类创建实例，但是 Lambda 表达式只能为函数式接口创建实例；</li><li>匿名内部类实现的抽象方法体允许调用接口中定义的默认方法，但是 Lambda 表达式的代码块不允许调用接口中定义的默认方法；</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Converter</span> </span>&#123;</span><br><span class="line">    <span class="function">Integer <span class="title">convert</span><span class="params">(String from)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">MyTest</span> </span>&#123;</span><br><span class="line">    <span class="function">String <span class="title">test</span><span class="params">(String a, <span class="keyword">int</span> b, <span class="keyword">int</span> c)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">YourTest</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 抽象方法负责根据 String 参数生成一个 JFrame 返回值</span></span><br><span class="line">    <span class="function">JFrame <span class="title">win</span><span class="params">(String title)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LambdaRef</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 1 引用类方法</span></span><br><span class="line">        <span class="comment">// 下面使用 Lambda 表达式创建 Converter 对象</span></span><br><span class="line">        Converter converter1 = from -&gt; Integer.valueOf(from);</span><br><span class="line">        Integer val = converter1.convert(<span class="string">"99"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 函数式接口中被实现方法的全部参数传给该类方法作为参数</span></span><br><span class="line">        Converter converter2 = Integer::valueOf;</span><br><span class="line">        Integer val2 = converter2.convert(<span class="string">"100"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2 引用特定对象的实例方法</span></span><br><span class="line">        <span class="comment">// 使用 Lmabda 表达式创建 Converter 对象</span></span><br><span class="line">        Converter converter3 = from -&gt; <span class="string">"hello michael翔"</span>.indexOf(from);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 调用 "hello michael翔"的indexOf()实例方法</span></span><br><span class="line">        <span class="comment">// 函数式接口中被实现的全部参数传给该方法作为参数</span></span><br><span class="line">        Converter converter4 = <span class="string">"hello michael翔"</span>::indexOf;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3 引用某类对象的实例方法</span></span><br><span class="line">        <span class="comment">// 使用 Lambda 表达式创建 MyTest 对象</span></span><br><span class="line">        MyTest mt = (a, b, c) -&gt; a.substring(b, c);</span><br><span class="line">        String  str = mt.test(<span class="string">"Hello World, Hello Michael翔"</span>, <span class="number">2</span>,<span class="number">9</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 上面 Lambda 表达式只有一行，因此可以使用如下引用进行替换</span></span><br><span class="line">        <span class="comment">// 函数式接口中被实现方法的第一个参数作为调用者</span></span><br><span class="line">        <span class="comment">// 后面的参数全部传给该方法作为参数</span></span><br><span class="line">        MyTest str2 = String::substring;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4 引用构造器</span></span><br><span class="line">        <span class="comment">// 使用 Lambda 表达式创建 YourTest 对象</span></span><br><span class="line">        YourTest yt = a -&gt; <span class="keyword">new</span> JFrame(a);</span><br><span class="line">        JFrame jf = yt.win(<span class="string">"窗口"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 使用构造器引用进行替换</span></span><br><span class="line">        <span class="comment">// 函数式接口中被实现方法的全部参数传给该构造器作为参数</span></span><br><span class="line">        YourTest yt2 = JFrame::<span class="keyword">new</span>;</span><br><span class="line">        JFrame jf2 = yt.win(<span class="string">"窗口2"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Lambda-表达式调用-Arrays-的类方法"><a href="#Lambda-表达式调用-Arrays-的类方法" class="headerlink" title="Lambda 表达式调用 Arrays 的类方法"></a>Lambda 表达式调用 Arrays 的类方法</h2><p>Arrays 类的有些方法需要 Comparator、XxxOperator、XxxFunction 等接口的实例，这些接口都是函数式接口。因此，可以使用 Lambda 表达式来调用 Arrays 的方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LambdaArrays</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String[] arr1 = <span class="keyword">new</span> String[]&#123;<span class="string">"java"</span>, <span class="string">"python"</span>, <span class="string">"rust"</span>, <span class="string">"go"</span>&#125;;</span><br><span class="line">        Arrays.parallelSort(arr1, (o1, o2) -&gt; o1.length() - o2.length());</span><br><span class="line">        System.out.println(Arrays.toString(arr1));</span><br><span class="line">        <span class="keyword">int</span>[] arr2 = &#123;<span class="number">3</span>, -<span class="number">4</span>, <span class="number">25</span>, <span class="number">16</span>, <span class="number">30</span>, <span class="number">18</span>&#125;;</span><br><span class="line">        <span class="comment">// left 代表数组中前一个索引处的元素，计算第一个元素时，left 为 1；</span></span><br><span class="line">        <span class="comment">// right 代表数组中的当前索引处的元素</span></span><br><span class="line">        Arrays.parallelPrefix(arr2, (left, right) -&gt; left * right);</span><br><span class="line">        System.out.println(Arrays.toString(arr2));</span><br><span class="line">        <span class="keyword">long</span>[] arr3 = <span class="keyword">new</span> <span class="keyword">long</span>[<span class="number">5</span>];</span><br><span class="line">        <span class="comment">// a 代表正在计算的元素索引</span></span><br><span class="line">        Arrays.parallelSetAll(arr3, a -&gt; a * <span class="number">5</span>);</span><br><span class="line">        System.out.println(Arrays.toString(arr3));</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 等价于用匿名内部类重写 applyAsLong 抽象方法</span></span><br><span class="line">        Arrays.parallelSetAll(arr3, <span class="keyword">new</span> IntToLongFunction() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">applyAsLong</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> value * <span class="number">5</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        System.out.println(Arrays.toString(arr3));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[go, java, rust, python]</span><br><span class="line">[<span class="number">3</span>, -<span class="number">12</span>, -<span class="number">300</span>, -<span class="number">4800</span>, -<span class="number">144000</span>, -<span class="number">2592000</span>]</span><br><span class="line">[<span class="number">0</span>, <span class="number">5</span>, <span class="number">10</span>, <span class="number">15</span>, <span class="number">20</span>]</span><br><span class="line">[<span class="number">0</span>, <span class="number">5</span>, <span class="number">10</span>, <span class="number">15</span>, <span class="number">20</span>]</span><br></pre></td></tr></table></figure></p><p>因为这些要出入 Comparator、XxxOperator、XxxFunction 等接口的实例往往都是一次性的，使用 Lambda 表达式也不用考虑重用等，反而让程序更加简洁了。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文主要参考的是 《疯狂 Java 讲义第 5 版》的第 6 章的面向对象下，通过实际的示例 demo 应该可以将 Lambda 的常用场景和用法掌握了。这样，看项目代码或者源码的话，会更加易于理解！基本功扎实，才能走得更快！</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="http://hollischuang.gitee.io/tobetopjavaer/#/basics/java-basic/syntactic-sugar?id=%e7%b3%96%e5%9d%97%e5%8d%81%e4%ba%8c%e3%80%81lambda%e8%a1%a8%e8%be%be%e5%bc%8f" target="_blank" rel="noopener">To Be Top Javaer/糖块十二、Lambda表达式</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://gitee.com/michael_xiang/images/raw/master/uPic/CACVrU.png&quot; alt=&quot;重庆-南山一棵树&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h2&gt;&lt;p&gt;阅读项目代码时，尤其是阅读一些源码时，经常会遇到 Lambda 表达式。对此之前看过相关文章，但是停留在模模糊糊的印象上。今天趁着有时间，通过一些 demo 示例，梳理一下它的用法，以备后期遗忘的时候快速查询它的用法！&lt;/p&gt;
&lt;p&gt;Lambda 表达式是 Java 8 的重要更新，它支持将代码块作为方法参数、允许使用更简洁的代码来创建只有一个抽象方法的接口的实例。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;描述中提到的接口称为函数式接口&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="Java" scheme="https://michael728.github.io/categories/Java/"/>
    
    
      <category term="Java" scheme="https://michael728.github.io/tags/Java/"/>
    
      <category term="Lambda" scheme="https://michael728.github.io/tags/Lambda/"/>
    
      <category term="面向对象" scheme="https://michael728.github.io/tags/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"/>
    
  </entry>
  
  <entry>
    <title>初识 Git 基本命令 merge 和 rebase</title>
    <link href="https://michael728.github.io/2020/06/21/git-merge-rebase/"/>
    <id>https://michael728.github.io/2020/06/21/git-merge-rebase/</id>
    <published>2020-06-21T23:21:24.000Z</published>
    <updated>2021-02-12T13:27:05.289Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://gitee.com/michael_xiang/images/raw/master/uPic/green-leaf-merge-git.jpg" alt="green-leaf-merge-git"></p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>Git 中的分支合并是一个常见的使用场景。</p><ul><li>仓库的 bugfix 分支修复完 bug 之后，要回合到主干分支，这时候两个分支需要合并； </li><li>远端仓库的分支 A 有其他小伙伴合入了代码，这时候，你需要和远端仓库的分支 A 进行合并；</li></ul><p>以上只是列举了分支合并的一些常见场景，关于 <code>merge</code> 和 <code>rebase</code> 命令你足够了解吗？</p><a id="more"></a><h2 id="HEAD-的理解"><a href="#HEAD-的理解" class="headerlink" title="HEAD 的理解"></a>HEAD 的理解</h2><p>在介绍本文的主要内容之前，我们先理解一下 <code>HEAD</code> 。</p><p><code>HEAD</code> 指向<strong>当前所在的分支</strong>，类似一个活动的指针，表示一个「引用」。例如当前在 <code>develop</code> 分支，<code>HEAD</code> 内容就是 <code>ref: refs/heads/develop</code>。</p><p><code>HEAD</code> 既可以指向「当前分支」的最新 <code>commit</code>，也可以指向历史中的某一次 <code>commit</code> (「分离头指针」的情况)。归根结底，<code>HEAD</code> 指向的就是某个提交点。</p><p>当我们做分支切换时，<code>HEAD</code> 会跟着切换到对应分支。</p><h2 id="fast-forward-与-–no-ff-的区别"><a href="#fast-forward-与-–no-ff-的区别" class="headerlink" title="fast-forward 与 –no-ff 的区别"></a>fast-forward 与 –no-ff 的区别</h2><p>假如有一个场景：有两个分支，master 分支和 feature 分支。现在，feautre 分支需要合并回 master 分支。</p><p><img src="https://gitee.com/michael_xiang/images/raw/master/uPic/wOR7JK.png" alt="fast-forward-初始状态"></p><p><code>fast-forward</code> 合并方式是<strong>条件允许</strong>的情况，通过将 master 分支的 HEAD 位置移动到 feature 分支的最新提交点上，这样就实现了快速合并。这种情况，是不会新生成 commit 的。</p><p><img src="https://gitee.com/michael_xiang/images/raw/master/uPic/QpdH5g.png" alt="fast-forward"></p><p><code>--no-ff</code> 的方式进行合并，master 分支就会新生成一次提交记录。</p><p><img src="https://gitee.com/michael_xiang/images/raw/master/uPic/BIqlQW.png" alt="--no-ff"></p><blockquote><p>如果条件满足时，merge 默认采用的 <code>fast-forward</code> 方式进行合并，除非你显示的加上 <code>--no-ff</code> 选项；而条件不满足时，merge 也是无法使用 <code>fast-forward</code> 合并成功的！</p></blockquote><h2 id="merge-操作"><a href="#merge-操作" class="headerlink" title="merge 操作"></a>merge 操作</h2><p>上面用图解的方式介绍了 <code>fast-forward</code> 和 <code>--no-ff</code> 的区别。下面，结合实际的代码仓进行合并操作，举几个栗子理解一下。</p><blockquote><p><code>git merge</code> 操作是区分上下文的。<strong>当前分支始终是目标分支</strong>，其他一个或多个分支始终合并到当前分支。这个注意点记住了，方便记忆！所以，当需要将某个分支合并到目标分支时，需要先切到目标分支上。</p></blockquote><h3 id="fast-forward-合并"><a href="#fast-forward-合并" class="headerlink" title="fast-forward 合并"></a>fast-forward 合并</h3><p>刚刚一直在强调条件允许的时候，<code>fast-forward</code> 才能合并成功。条件指的是什么呢？</p><p>其实指的是源分支和目标分支之间没有分叉（单词 <code>diverge</code>），这种情况才可以进行快速合并。如果是下图中的场景，无法通过 HEAD 的快速移动实现分支的合并！</p><p><img src="https://gitee.com/michael_xiang/images/raw/master/uPic/RQ39Rv.png" alt="分叉"></p><p>下面进行一个不分叉的场景的示例：</p><p><img src="https://gitee.com/michael_xiang/images/raw/master/uPic/A87zPe.png" alt="featuren 分支的初始状态"></p><p>现在需要将 feature 分支合入到 master 分支，默认使用 <code>fast-forward</code> 方式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># 切到目标分支</span><br><span class="line">git checkout master</span><br><span class="line">git merge feature</span><br></pre></td></tr></table></figure><p>命令行里显示了 <code>Fast-forward</code> 的提示：</p><p><img src="https://gitee.com/michael_xiang/images/raw/master/uPic/J0Zku9.png" alt="合入效果"></p><p>看一眼 master 分支合入的前后对比（注意 HEAD 的位置）：</p><p><img src="https://gitee.com/michael_xiang/images/raw/master/uPic/KmsbrV.png" alt="master 分支合入前"></p><p><img src="https://gitee.com/michael_xiang/images/raw/master/uPic/M9PM7Q.png" alt="master 分支合入后"></p><h3 id="no-ff-合并"><a href="#no-ff-合并" class="headerlink" title="no-ff 合并"></a>no-ff 合并</h3><p>不分叉的场景是否可以强制采用 <code>--no-ff</code> 方式合并呢？可以！</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span> master 回到合入前的状态</span><br><span class="line">git reset --hard d2fa1ae</span><br><span class="line">git merge feature --no-ff</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/michael_xiang/images/raw/master/uPic/LTzh9p.png" alt="no-ff"></p><p>这次命令行没有 <code>Fast-forward</code> 的提示了。</p><p>看一眼 master 分支图：</p><p><img src="https://gitee.com/michael_xiang/images/raw/master/uPic/Sklh3v.png" alt="no-ff"></p><p>这个图和上面讲解 <code>no-ff</code> 命令时的示意图一致，果然会有新 <code>commit</code> 生成。</p><h3 id="分叉场景的合并"><a href="#分叉场景的合并" class="headerlink" title="分叉场景的合并"></a>分叉场景的合并</h3><p><img src="https://gitee.com/michael_xiang/images/raw/master/uPic/X69y67.png" alt="分叉"></p><p>上面的图展示了我们经常遇到的一个场景，特性分支创建之后，源分支也会有新的提交。这就是形成分叉了。</p><p>这时候如果我们进行合并呢？</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git merge feautre</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/michael_xiang/images/raw/master/uPic/g9NjTO.png" alt="分支图"></p><p>可以看到，虽然默认会尝试 <code>fast-forward</code> 的方式进行合并，但是因为分叉了，所以此时会采用 <code>no-ff</code> 的方式进行合并！有新的 <code>commit</code> 生成了！</p><blockquote><p>fast-forward 方式对应的合并参数是 <code>--ff</code></p></blockquote><p>我们试试这个参数 <code>--ff-only</code>，顾名思义，就是强制只使用 <code>ff</code> 方式进行合并：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># 回到合并前</span><br><span class="line">git reset --hard 3793081</span><br><span class="line">git merge feature --ff-only</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/michael_xiang/images/raw/master/uPic/yIaYHq.png" alt="合并终止"></p><p>经过测试，当分叉时，因为无法使用 <code>ff</code> 方式合并，即使你强制指定使用该方式合并也不行，会提示终止！</p><p>附上 Git 官方文档中的解释，方便理解：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">With --ff, when possible resolve the merge as a fast-forward (only update the branch pointer to match the merged branch; do not create a merge commit). When not possible (when the merged-in history is not a descendant of the current history), create a merge commit.</span><br></pre></td></tr></table></figure><h2 id="rebase-操作"><a href="#rebase-操作" class="headerlink" title="rebase 操作"></a>rebase 操作</h2><p><code>rebase</code> 命令是一个经常听到，但是大多数人掌握又不太好的一个命令。<code>rebase</code> 合并往往又被称为 「变基」，我称为 「基化」🤣。「基」的理解很重要，理解了它，其实 <code>rebase</code> 命令你就掌握了。</p><p>我的描述可能并不准确，只是为了能够帮助你理解。这里的「基」就是一个「基点」、「起点」的意思。「变基」就是改变当前分支的起点。<strong>注意，是当前分支！</strong> <code>rebase</code> 命令后面紧接着的就是「基分支」。</p><p>变基前：</p><p><img src="https://gitee.com/michael_xiang/images/raw/master/uPic/RQ39Rv.png" alt="分叉"></p><p><code>git reabse master feature</code> 变基后：</p><p><img src="https://gitee.com/michael_xiang/images/raw/master/uPic/HepjTM.png" alt="变基后"></p><blockquote><p>git rebase 命令通常称为向前移植（<code>forward porting</code>）。</p></blockquote><h3 id="变基提交示例"><a href="#变基提交示例" class="headerlink" title="变基提交示例"></a>变基提交示例</h3><p>我们接下来进行实际的测试，将代码库状态构造成分叉的状态，状态图如下：</p><p><img src="https://gitee.com/michael_xiang/images/raw/master/uPic/o9hGJa.png" alt="分叉初始状态"></p><p>以 master 分支为基，对 feautre 分支进行变基：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git checout feature</span><br><span class="line">git rebase master</span><br></pre></td></tr></table></figure><p>以上两行命令，其实可以简写为：<code>git rebase master feature</code></p><blockquote><p>特性分支 feature 向前移植到了 master 分支。经常使用 git rebase 操作把本地开发分支移植到远端的 <code>origin/&lt;branch&gt;</code> 追踪分支上。也就是经常说的，「把你的补丁变基到 xxx 分支的头」</p></blockquote><p><img src="https://gitee.com/michael_xiang/images/raw/master/uPic/8jMmax.png" alt="变基后"></p><p>可以发现，在 master 分支的最新节点（<code>576cb7b</code>）后面多了 2 个提交（生成了新的提交记录，仅仅提交信息保持一致），而这两个提交内容就是来自变基前  feature 分支，feature 分支的提交历史发生了改变。</p><p>观察上图还可以发现，变基后，改变的只是 feature 分支，基分支（master 分支）的 HEAD 指针依然在之前的 commit （<code>576cb7b</code>）处。这时候要将 feature 分支合入到 master 分支上，就满足 <code>fast-forward</code> 的条件了，<code>master</code> 分支执行快速合并，将 HEAD 指针指向刚刚最新合入的提交点：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git checkout master</span><br><span class="line">git merge feature</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/michael_xiang/images/raw/master/uPic/BUiz44.png" alt="快速合并"></p><p>看下图 master 分支图，观察 HEAD 指针的位置：<br><img src="https://gitee.com/michael_xiang/images/raw/master/uPic/dgYPmX.png" alt="分支图"></p><p>rebase 变基操作最适合的是本地分支和远端对应跟踪分支之间的合并。这样理解可能会更清晰一点。比如，远端仓库里有一个特性分支 feature，除了你开发之外，还有其他人往这个分支进行合入。当你每次准备提交到远端之前，其实可以尝试变基，这时候基分支就是远端的追踪分支。</p><p>下图是仓库的分支图：</p><p><img src="https://gitee.com/michael_xiang/images/raw/master/uPic/PDdv1I.png" alt="与远端分支分叉"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git fetch</span><br><span class="line">git rebase origin/feature feature</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/michael_xiang/images/raw/master/uPic/UBCOSo.png" alt="变基后"></p><p>观察上图，我们本地的提交以远端分支的最新提交为「基」，将差异提交重新进行了提交！远端分支的提交记录依然是一条直线~如果分叉的情况，不采用这种「变基操作」，而直接采用 <code>merge</code> 的方式合并，就会有如下这种分支提交图：</p><p><img src="https://gitee.com/michael_xiang/images/raw/master/uPic/hkVfzT.png" alt="no-ff 合并"></p><p>因为分叉了，采用 <code>git pull</code> 时默认也没法 <code>fast-forward</code> 合并，只能采用 <code>no-ff</code> 方式合并，最后的提交历史就会像上图那样。会产生一个合并提交。同时，分支图也显得稍微杂乱了一点，因为 feature 分支不是一条直线了。但是，其实也有好处，可以实际的看出来合并的提交历史。该选择哪个，往往取决于团队的选择策略。</p><blockquote><p>养成习惯，使用 <code>git pull --rebase</code> 方式同步远端分支也是一个不错的习惯，这样，就不会多出多余的 commit 记录了。具体可以看这篇文章 <a href="https://www.cnblogs.com/wangiqngpei557/p/6056624.html" target="_blank" rel="noopener">博客园/聊下git pull –rebase</a></p></blockquote><h3 id="rebase-总结"><a href="#rebase-总结" class="headerlink" title="rebase 总结"></a>rebase 总结</h3><p><code>rebase</code> 命令其实关键在于理解「基」，<code>git rebase &lt;基分支&gt;</code>，就是将当前基分支与当前分支的差异提交获取到，然后在「基分支」最新提交点后面将差异提交逐个再次提交，最后将当前分支的 HEAD 指针指向最新的提交点。</p><p>「基分支」的 HEAD 位置是不变的。要想完成分支合并，完成变基之后，需要再进行分支间的合并等操作。</p><p>rebase 命令的用法也不止于此，计划后期会专门写一篇介绍她的文章。本文本来是计划介绍 merge 命令的，但是合并的方式中，其实也经常涉及变基操作之后的合并，因此，干脆就放一起比较好了，这样易于理解记忆。 </p><h2 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h2><ul><li><code>git merge --abort</code> 当合并的过程中，由于冲突难解决，你想放弃合并，回到未合并之前的状态；</li><li><code>git log --graph --pretty=oneline --abbrev-commit</code> 可以在命令行方便地查看提交图</li></ul><h2 id="一言"><a href="#一言" class="headerlink" title="一言"></a>一言</h2><p>在 Git 这个专辑里有一篇介绍 cherry-pick 的文章，有个小伙伴给了如下的留言，说明自己分享的内容获得了肯定，欣慰啊！</p><p><img src="https://gitee.com/michael_xiang/images/raw/master/uPic/vhpyi8.png" alt="留言"></p><p>今天肝的这篇文章，介绍了 Git 中的 merge 和 rebase 的基本概念和用法，同时，又自己手动绘制了图！俗话说，一图胜千言，但写完才发现，是真的耗时啊……不过，总结绘图的过程，自己也加深了理解，有些概念也变得更加清晰了！希望，我的总结也能让其他人读懂~</p><p>之前我经常会开启文章的「赞赏」，但发现收效甚微，很少有小伙伴会打赏。后来我就每次发文就关闭了这个选项。本文应该是 6 月份的「月末总结」了，就开启一次「月末赞赏」吧！期待小伙伴的支持与鼓励！</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>我将本文的参考文章也都注明了，他们也都很有阅读的价值。但由于微信外链的缘故，可以点击右下角的「阅读原文」浏览！</p><ul><li><a href="https://stackoverflow.com/questions/9069061/what-is-the-difference-between-git-merge-and-git-merge-no-ff" target="_blank" rel="noopener">StackoverFlow-What is the difference between <code>git merge</code> and <code>git merge --no-ff</code>?</a></li><li><a href="https://git-scm.com/docs/git-merge" target="_blank" rel="noopener">git-scm-git-merge</a></li><li><a href="https://backlog.com/git-tutorial/cn/stepup/stepup1_4.html" target="_blank" rel="noopener">分支的合并</a></li><li><a href="https://docs.gitlab.com/ee/user/project/merge_requests/fast_forward_merge.html" target="_blank" rel="noopener">Gitlab-Fast-forward merge requests</a></li><li><a href="https://yanhaijing.com/git/2017/07/14/four-method-for-git-merge/" target="_blank" rel="noopener">颜海镜-图解4种git合并分支方法</a></li><li><a href="https://www.jetbrains.com/help/idea/sync-with-a-remote-repository.html#update" target="_blank" rel="noopener">Sync with a remote Git repository (fetch, pull, update)</a> IDEA 的帮助文档</li></ul><hr><blockquote><p>生命不息，折腾不止！关注 「Coder 魔法院」，祝你 Niubilitiy ！🐂🍺</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://gitee.com/michael_xiang/images/raw/master/uPic/green-leaf-merge-git.jpg&quot; alt=&quot;green-leaf-merge-git&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;Git 中的分支合并是一个常见的使用场景。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;仓库的 bugfix 分支修复完 bug 之后，要回合到主干分支，这时候两个分支需要合并； &lt;/li&gt;
&lt;li&gt;远端仓库的分支 A 有其他小伙伴合入了代码，这时候，你需要和远端仓库的分支 A 进行合并；&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;以上只是列举了分支合并的一些常见场景，关于 &lt;code&gt;merge&lt;/code&gt; 和 &lt;code&gt;rebase&lt;/code&gt; 命令你足够了解吗？&lt;/p&gt;
    
    </summary>
    
      <category term="ToolsDev" scheme="https://michael728.github.io/categories/ToolsDev/"/>
    
    
      <category term="Git" scheme="https://michael728.github.io/tags/Git/"/>
    
  </entry>
  
</feed>
